<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deep Neural Networks for YouTube Recommendations 论文笔记</title>
      <link href="/2019/04/08/YouTube_recsys/"/>
      <url>/2019/04/08/YouTube_recsys/</url>
      
        <content type="html"><![CDATA[<p>YouTube的推荐系统架构主要有两部分组成，首先是从百万级数据中产生一个候选集，这个候选集可能只包含数百个待推荐的视频，其次是对这个候选集中的视频进行排序，如下图所示：</p><p><img src="/2019/04/08/YouTube_recsys/struct.png" alt="struct"></p><p>这个系统的每一部分都对应着一个推荐模型，首先看一下产生候选集的模型。</p><h1 id="候选集生成模型"><a href="#候选集生成模型" class="headerlink" title="候选集生成模型"></a>候选集生成模型</h1><p>生成候选集的这一模型将推荐视为一个多分类问题，用户u在时间t观看视频i的概率可用公式计算：<br>$$<br>P(w_t=i | U, C) = \frac{e^{v_iu}}{\sum_{j \in V} e^{v_ju}}<br>$$<br>其中$u,v_i$分别是用户和视频的embedding向量，是在模型的训练过程中产生的，正如下面的架构图所示的，u应该是三层全连接网络的输出，而v是softmax层的权重。这一模型的整体架构如下图所示</p><p><img src="/2019/04/08/YouTube_recsys/candidate.png" alt="candidate"></p><h2 id="模型的输入"><a href="#模型的输入" class="headerlink" title="模型的输入"></a>模型的输入</h2><p>输入特征主要包括视频的embedding向量，用户搜索关键词的embedding，若一个用户同时有多个视频embedding和多个搜索关键词则采取的操作是简单平均法，需要注意的是，这些embedding向量都是训练学习得到的，也就是说模型实际输入的是视频和关键词的one-hot编码，然后将这些稀疏的编码映射为稠密的embedding作为网络的输入。另外输入特征还包括了用户的一些属性特征和视频的自身属性特征，将这些特征拼接起来作为深度网络的输入层。</p><h2 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h2><p>隐藏层是金字塔形的全连接网络，使用Relu作为激活函数。</p><h2 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h2><p>在训练的时候，全连接网络的最后一层输出作为用户的embedding向量u，而全连接最后一层到softmax的权重作为视频的embedding向量。在线上预测的时候，模型并没有使用softmax计算概率，而是采用了近邻搜索的方法。</p><h2 id="如何构造样本和标签"><a href="#如何构造样本和标签" class="headerlink" title="如何构造样本和标签"></a>如何构造样本和标签</h2><p>从模型的结构上来看，这一模型实际上是借鉴了CBOW语言模型，也就是说一个用户的观看历史可以看做一个序列，这一序列中的每个时间节点观看的视频都是一个带分类的label，而这一label周围的固定长度的视频则作为它的输入特征，如下如的a图所示<img src="/2019/04/08/YouTube_recsys/label-context.png" alt="label-context"></p><p>但是若采用a图的方式构造样本，容易泄露未来的信息，因为视频序列和文本信息不同，视频序列是一种非对称的序列，下一时刻的视频是还没有观看的，所以不能用未来的视频信息来预测当前视频的label，故文章中所使用的构造样本的方式是b图中方法，只用过去看过的视频作为当前label的输入。</p><p>#排序模型</p><p>生成候选集之后，候选集中的视频大概有上百个，也不能把所有的视频推荐给用户，还需要对这些视频进行进一步的打分排序，在这一阶段，同样使用了与产生候选集相识的模型结构，如图所示</p><p><img src="/2019/04/08/YouTube_recsys/ranking.png" alt="ranking"></p><p>所不同的是排序模型把推荐问题看成一个二分类问题，最后一层使用的带权重的逻辑回归。</p><h2 id="特征构造"><a href="#特征构造" class="headerlink" title="特征构造"></a>特征构造</h2><p>整体上还是把特征分为continuous特征和categorical特征，categorical特征（视频ID编码和用户语言视频语言编码）的处理方式依旧是学习出embedding向量作为DNN的输入；continuous特征包括一些上下文信息和用户与视频交互的一些历史信息，在输入continuous特征之前需要标准化处理。</p><h2 id="对观看时间建模"><a href="#对观看时间建模" class="headerlink" title="对观看时间建模"></a>对观看时间建模</h2><p>这部分主要介绍为什么使用带权重的逻辑回归作为损失函数。论文中给的理由是模型的主要目的是预测视频观看的时长而非只预测用户是否点击视频，因为如果只预测用户是否点击作为目标，很容易受标题党的影响。给定正样本，正样本的权重是用户观看的时长（但是没有明确时长的单位是s还是min），负样本的权重是单位1。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wide &amp; Deep Learning for Recommender Systems阅读笔记</title>
      <link href="/2019/03/26/wide_deep/"/>
      <url>/2019/03/26/wide_deep/</url>
      
        <content type="html"><![CDATA[<p>#Wide &amp; Deep Learning for Recommender Systems阅读笔记</p><p>Wide指的是线性模型，Deep指的是DNN。这篇论文提出了一个联合训练线性模型和DNN的的算法，可以同时发挥出两个不同模型的优势：线性模型有“Memorization”的优点，DNN有”Generalization”的优点。”Memorization”是指模型的记忆能力，也即是可以记住item之间或者features之间的组合是否同时出现过；”Generalization”是指模型探索发现特征之间新的组合的能力，对比与”Memorization”，”Generalization”可以使推荐系统的推荐更加多元化。</p><h1 id="Wide-amp-Deep-Learning"><a href="#Wide-amp-Deep-Learning" class="headerlink" title="Wide &amp; Deep Learning"></a>Wide &amp; Deep Learning</h1><p>Wide&amp;Deep的结构如下图中间所示<img src="/2019/03/26/wide_deep/wide_deep.png" alt="wide_deep"></p><h2 id="Wide-component"><a href="#Wide-component" class="headerlink" title="Wide component"></a>Wide component</h2><p>上图的左侧就是Wide的部分，其实就是一个线性模型，这一侧的输入特征主要包括原始的特征以及经过非线性变换后的特征</p><h2 id="Deep-component"><a href="#Deep-component" class="headerlink" title="Deep component"></a>Deep component</h2><p>上图的右侧就是Deep的部分，这是一个DNN结构，这一侧的输入特征为经过one-hot编码后的稀疏特征，然后学习一个稠密的embedding作为DNN的输入。</p><h2 id="联合训练Wide-amp-Deep"><a href="#联合训练Wide-amp-Deep" class="headerlink" title="联合训练Wide&amp;Deep"></a>联合训练Wide&amp;Deep</h2><p>将wide部分以及Deep部分的输出层组合联合训练得到：<br>$$<br>P(Y=1|x) = \sigma(w_{wide}^T[x, \phi(x)] + w_{deep}^Ta^{l}+b)<br>$$<br>论文中提到，在实际中是使用FTRL训练Wide部分，使用AdaGrad训练Deep部分。</p><h1 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h1><p><img src="/2019/03/26/wide_deep/apps.png" alt="apps"></p><p>在将此模型应用于APPs推荐的框架中，Deep侧首先将categorical特征的热编码学习一个embedding，然后将embedding和continuous特征连接起来作为DNN的输入；Wide侧一些categorical特征的交叉积变换作为特征输入。</p><p>附上自己实现模型的代码<a href="https://github.com/TFeiMa/Resys-Model/tree/master/wide_deep" target="_blank" rel="noopener">wide_deep</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning and Transferring IDs Representation in E-commerce阅读笔记</title>
      <link href="/2019/03/14/ali%20embedding/"/>
      <url>/2019/03/14/ali%20embedding/</url>
      
        <content type="html"><![CDATA[<p>除了用户的隐式反馈，论文还考虑了不同ID类特征之间的连接结构，通过这些连接，在ItemID序列中的信息可以传播到其它类型的ID特征，并且可以同时学习这些ID特征的表示，如下图</p><p><img src="/2019/03/14/ali embedding/conected.png" alt="conected"></p><h1 id="hema-的推荐框架"><a href="#hema-的推荐框架" class="headerlink" title="hema 的推荐框架"></a>hema 的推荐框架</h1><p>这篇论文是应用在盒马鲜生这个APP中的，在这个APP中，推荐的过程主要分为4个过程：</p><ol><li><strong>准备阶段：</strong>离线计算出user-to-trigger和trigger-to-item的评分，并且把结果存储在数据库中。</li><li><strong>匹配：</strong>首先根据用户的ID取出他们的<code>triggers</code>，然后基于这些<code>triggers</code>产生一些<code>items</code>的推荐候选集。</li><li><strong>筛选：</strong>移除无效和重复的<code>items</code>.</li><li><strong>排序：</strong>综合一些评分指标，给这些筛选后的<code>items</code>排序。</li></ol><h1 id="学习IDs的表示"><a href="#学习IDs的表示" class="headerlink" title="学习IDs的表示"></a>学习IDs的表示</h1><h2 id="用户交互序列的Skip-gram模型"><a href="#用户交互序列的Skip-gram模型" class="headerlink" title="用户交互序列的Skip-gram模型"></a>用户交互序列的Skip-gram模型</h2><p>将用户的一个交互会话视作一个<code>documents</code>，形式上来讲就是，给定一个item IDs ${ item_1,\cdots,itme_i,\cdots,item_N },$skip-gram模型最大化：<br>$$<br>J = \frac{1}{N} \sum_{n=1}^N \sum_{-C\leq j \leq C}^{1 \leq n+j \leq N} \log p(item_{n+j}| item_n)<br>$$<br>C是上下文窗口的长度。比如文中给的例子,每个用户都有一个序列，第一个用户的梨子就是上面公式中的$item_n$：</p><p><img src="/2019/03/14/ali embedding/skip context.png" alt="skip context"></p><p>在基本的skip-gram模型中，$p(item_{j}| item_i)​$是由softmax函数定义的：<br>$$<br>p(item_{j}| item_i) = \frac{\exp(e^{‘T}_je_i)}{\sum_{d=1}^D\exp(e^{‘T}_de_i)}<br>$$<br>其中$e^{‘} \in E^{‘}\subset R^{m\times D}, e \in E\subset R^{m\times D}$.$E^{‘},E$分别是与上下文和目标相关的表示矩阵。$m，D$是分别是嵌入向量的维度和包含所有item IDs字典的大小。</p><h2 id="Log-uniform-负采样"><a href="#Log-uniform-负采样" class="headerlink" title="Log-uniform 负采样"></a>Log-uniform 负采样</h2><p>上式中计算$\nabla p(item_{j}| item_i)$的时间复杂度与D成正比，当D很大的时候，上面的模型很难实际使用。所以这篇论文使用负采样的方法代替softmax函数：<br>$$<br>p(item_{j}| item_i) = \sigma(e^{‘T}_je_i) \Pi_{s=1}^S \sigma(-e^{‘T}_se_i)<br>$$<br>负样本是从$P_{neg}(item)$的分布采样得到，$P_{neg}(item)$最简单的选择是均匀分布，但是对于样本不均衡的情况下，均匀分布并不是一个好的选择，因为往往流行的item IDs都提供了很少的信息，这样的样本在目标样本的上下文窗口中出现多次却提供较少信息，这篇论文中选择了<a href="https://en.wikipedia.org/wiki/Zipf%27s_law" target="_blank" rel="noopener">Zipfian</a>分布作为$P_{neg}(item)​$.<br>$$<br>p(index) = \frac{\log(index+2) - \log(index+1)}{\log(D+1)}<br>$$<br>首先根据items的频率按照降序排序，然后每个item都对应着一个index，index的范围从0到D-1。累积概率分布为<br>$$<br>\begin{align}<br>F(x) &amp;= p(x \leq index) \<br>&amp;= \sum_{i=1}^{index} \frac{\log(i+2) - \log(i+1)}{\log(D+1)} \<br>&amp;= \frac{\log(index +2 )}{\log(D+1)}<br>\end{align}<br>$$<br>令$F(x)=r$,r为$(0,1]$之间的一个随机数，那么我们可以随机抽到一个index为<br>$$<br>index = \lceil (D+1)^r \rceil - 2.<br>$$</p><h2 id="IDs-以及他们他们之间的结构连接"><a href="#IDs-以及他们他们之间的结构连接" class="headerlink" title="IDs 以及他们他们之间的结构连接"></a>IDs 以及他们他们之间的结构连接</h2><h3 id="Item-ID-以及它的属性IDs"><a href="#Item-ID-以及它的属性IDs" class="headerlink" title="Item ID 以及它的属性IDs"></a>Item ID 以及它的属性IDs</h3><p>item是交互的核心单位，它有许多属性id，包括<code>product id</code>,<code>store id</code>,<code>brand id</code>,<code>category id</code>等。</p><h3 id="User-ID"><a href="#User-ID" class="headerlink" title="User ID"></a>User ID</h3><h2 id="属性IDs的联合嵌入"><a href="#属性IDs的联合嵌入" class="headerlink" title="属性IDs的联合嵌入"></a>属性IDs的联合嵌入</h2><p>论文提出了一个层次化的嵌入模型，去联合学习item ID以及它们的属性ID之间的低维表示，如下图</p><p><img src="/2019/03/14/ali embedding/join embedding.png" alt="join embedding"></p><p>假设K类IDs，令$IDs(item_i) = [id_1{item_i},\cdots,id_K(item_i)]$,那么可以得到<br>$$<br>p(IDs(item_j) | IDs(item_i))<br>= \sigma \big(\sum_{k=1}^K (w_{jk}e^{‘}<em>{jk})^T(w</em>{ik}e_{ik})\big) \Pi_{s=1}^S\sigma \big(-\sum_{k=1}^K(w_{sk}e^{‘}<em>{sk})^T(w</em>{ik}e_{ik})\big)<br>$$</p><p>其中 $ w_{ik} $ 为 $ id_{i}( item_{i}) $ 的权重，计算方法为：</p><p>$$<br>w_{ik} = \frac{1}{\sum_{j=1}^D I(id_k(item_i) = id_k(item_j))}<br>$$</p><p>定义<br>$$<br>p(item_i|ID(item_i)) = \sigma \big( \sum_{k=2}^K w_{ik}e^T_{i1} M_k e_{ik} \big),<br>$$<br>其中$M_k \in R^{m_1 \times m_k}(k=2\cdots K)$是为了使$e_{i1}$变换到$e_{ik}$相同维度的矩阵。然后最大化<br>$$<br>J = \frac{1}{N} \sum_{n=1}^N \big( \sum_{-C\leq j \leq C}^{1 \leq n+j \leq N,j\neq 0} \log p(IDs(item_{n+j})| IDs(item_n)) + \alpha \log p(item_n| IDs(item_n)) - \beta \sum_{k=1}^K \Vert M_k \Vert_2 \big)<br>$$<br>这种方法将Item ID 和属性ID 嵌入到一个同语义空间。</p><h2 id="嵌入用户ID"><a href="#嵌入用户ID" class="headerlink" title="嵌入用户ID"></a>嵌入用户ID</h2><p>使用简单平均法：<br>$$<br>Embedding(u) = \frac{1}{T} \sum_{t=1}^T e_t<br>$$<br>$e_t$是$item_t$的嵌入向量。</p><h1 id="利用ID的表示"><a href="#利用ID的表示" class="headerlink" title="利用ID的表示"></a>利用ID的表示</h1><h2 id="item相似性度量"><a href="#item相似性度量" class="headerlink" title="item相似性度量"></a>item相似性度量</h2><p>$$<br>sim(item_i,item_j) = cos(v_i,v_j) = \frac{v_i^Tv_j}{\Vert v_i \Vert_2\Vert v_j \Vert_2}<br>$$</p><h2 id="从已知item迁移到未知item"><a href="#从已知item迁移到未知item" class="headerlink" title="从已知item迁移到未知item"></a>从已知item迁移到未知item</h2><p>为了解决冷启动问题，论文提出了一个迁移方法，对新的item ID构建一个近似的嵌入向量。因为即使是一个新的item ID，通常它的属性id也有历史记录，论文的想法是最大化概率<br>$$<br>\max p(item_i | IDs(items_i))<br>$$<br>也就是令<br>$$<br>p(item_i | IDs(items_i)) \rightarrow 1<br>$$<br>所以令<br>$$<br>e_{i1} = \sum_{k=2}^K w_{ik}e^T_{i1} M_k e_{ik}<br>$$<br>实际中只使用那些有历史记录的$id_k$.</p><h2 id="从不同的领域迁移"><a href="#从不同的领域迁移" class="headerlink" title="从不同的领域迁移"></a>从不同的领域迁移</h2><p>本节讲了如何从淘宝用户喜好迁移到盒马平台。</p><p><img src="/2019/03/14/ali embedding/trans domanin.png" alt="trans domanin"></p><p>$U^s,U^t$分别表示<code>source domain</code>和<code>target domain</code>的用户集合，$U^i = U^s \bigcap U^t$。如上图所示，迁移的过程为</p><ol><li>在淘宝计算出$U^s$的嵌入向量</li><li>基于嵌入向量的相似度，$U^i$中的用户使用k-means聚类为1000个组</li><li>对于每个组，选择出 top N 个盒马中的item作为候选集</li><li>根据相似性度量，将新用户分配到最相近的组中</li><li>新用户被分配到组中后，组里使用第3步选出来的候选集筛选排序后推荐给他</li></ol><h2 id="迁移到不同的任务"><a href="#迁移到不同的任务" class="headerlink" title="迁移到不同的任务"></a>迁移到不同的任务</h2><p>可以使用嵌入向量和历史销售作为输入做销售预测任务，使用的模型为全连接神经网络。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xDeepFM--Combining Explicit and Implicit Feature Interactions for Recommender Systems阅读笔记</title>
      <link href="/2019/03/08/xDeepFM/"/>
      <url>/2019/03/08/xDeepFM/</url>
      
        <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="嵌入层"><a href="#嵌入层" class="headerlink" title="嵌入层"></a>嵌入层</h2><p>​    一般我们会对离散特征进行热编码，比如论文中给的例子：</p><p><img src="/2019/03/08/xDeepFM/cat_onehot.png" alt="cat_onehot"></p><p>使用FM可以为每一个特征（热编码后的）学习一个隐向量（假设每个隐向量都固定维度D），因为一个field（热编码前的特征）包含多个编码，所以每一个field就包含多个隐向量。对于一个样本，每一个field只有一个或几个隐向量出现，即热编码后特征为1的特征的隐向量，若field中只有一个隐向量出现，那么这个特征的隐向量就作为field的隐向量，若有多个隐向量出现，多个隐向量的和作为field的隐向量。</p><p><img src="/2019/03/08/xDeepFM/embedding.png" alt="embedding"></p><h2 id="隐式高阶交叉特征"><a href="#隐式高阶交叉特征" class="headerlink" title="隐式高阶交叉特征"></a>隐式高阶交叉特征</h2><p>​    由DNN学习到的特征就叫做隐式的高阶交叉特征（Implicit High-order Interactions），如下图，DeepFM和PNN的结构画在了一起，两者都可以学习到低阶特征和隐式的高阶特征，但他俩的区别在于DeepFM是用FM层学习低阶交叉特征，PNN用product层学习低阶交叉特征。</p><p><img src="/2019/03/08/xDeepFM/deepFM&amp;pnn.png" alt="deepFM&amp;pnn"></p><h2 id="显式高阶交叉特征"><a href="#显式高阶交叉特征" class="headerlink" title="显式高阶交叉特征"></a>显式高阶交叉特征</h2><p>​    CrossNet能够学习到显式高阶交叉特征（Explicit High-order Interactions），它的网络结构如下图，<img src="/2019/03/08/xDeepFM/crossNet.png" alt="crossNet"></p><p>网络之间的传播公式为</p><p>$$x_k = x_0x_{k-1}^Tw_k + b_k + x_{k-1}$$</p><p>本文提出的CIN的结构就借鉴了CrossNet的网络结构。</p><h1 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h1><h2 id="CIN（Compressed-Interaction-Network）"><a href="#CIN（Compressed-Interaction-Network）" class="headerlink" title="CIN（Compressed Interaction Network）"></a>CIN（Compressed Interaction Network）</h2><p>   CIN考虑：</p><ol><li>向量级别的特征交互</li><li>显式的高阶特征交互</li><li>网络的复杂度不能随着交叉的阶数指数增长</li></ol><p>CIN的网络结构可以种下列三个图解释：<img src="/2019/03/08/xDeepFM/CIN.png" alt="CIN"></p><p>​    如（c）图所示，网络的输入为field的嵌入，并且用矩阵$X^0 \in R^{m\times D}​$表示，其中m表示field的个数，D表示嵌入的维度，它的第i行即为第i个field的嵌入。网络的输出用$X^k \in R^{H_k\times D}​$表示，$H_k​$表示第k层特征向量的个数。网络之间的传播公式为</p><p>$$<br>X_{h,\ast}^k = \sum_{i=1}^{H_{k-1}} \sum_{j=1}^m W_{i,j}^{k,h}(X_{i,\ast}^{k-1}\circ X_{j,\ast}^{0})<br>$$</p><p>$\circ​$的定义为$(a,b,c)\circ(x,y,z)=(ax,by,cz)​$。由于下一个隐藏层的输出依赖于上一个隐藏层的输入，所以CIN的结构与RNN非常类似。</p><p>​    从上面的传播公式还能够看出CIN还有类似CNN的结构，如上图（a）所示，$x^k​$的一列（$H_k=3​$维）与$x^0​$的一列（$m=4​$维）作用可以生成一个$3*4​$的矩形，总共有D列，所以最终生成了D个这样的矩形，也就是一个$H_k \times m \times D​$维的tensor，所生成到每个矩阵的权重矩阵$W^{k,h}​$可以视作一个滤波器，最终如图（b）所示，每个生成的 $H_k \times m​$ 矩阵映射为一个 $H_{k+1}​$ 维向量。</p><p>​    假设CIN有T个隐藏层，每个隐藏层的$X^k$的行向量都做一个sum pooling：</p><p>$$p_i^k = \sum_{j=1}^DX^k_{i,j}$$,最终能够得到一个pooling后的向量，$p^k = [p^k_1,\cdots,p^k_{H_k}]$,正如图（c）的输出层所示，T个这样的隐藏层的输出单元即为$p^+ = [p^1,\cdots,p^T]$.如果使用CIN直接只用作二分类，则输出单元可以为</p><p>$$<br>y = \frac{1}{1+\exp(p^+Tw^o)}<br>$$</p><h2 id="CIN分析"><a href="#CIN分析" class="headerlink" title="CIN分析"></a>CIN分析</h2><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>CIN共包含$\sum_{k=1}^T H_k \times H_{k-1} \times m + \sum_{k=1}^T H_k$个参数</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(mHD+H^2T)$</p><h3 id="多项式近似"><a href="#多项式近似" class="headerlink" title="多项式近似"></a>多项式近似</h3><p>​    假设每一层特征映射的维度都为m。第一层第h个特征映射：</p><p>$$x^1_h = \sum_{i,j}^m W_{i,j}^{1,h}(x_i^0\circ x_j^0),​$$</p><p>可以看出这是一个二阶特征交叉。第二层的第h个特征映射为：<br>$$<br>\begin{array}{c l}<br>x^2_h &amp;= \sum_{i,j}^m W_{i,j}^{2,h}(x_i^1\circ x_j^0),\<br>      &amp;= \sum_{i,j}^m \sum_{l,k}^m W_{i,j}^{2,h}W_{l,k}^{1,i}(x_l^0 \circ x_k^0 \circ x_j^0)<br>\end{array}<br>$$</p><p>容易看出这是输入特征的3阶特征交互。能够推出第k层的特征为输入特征的k+1阶特征交互，这也叫做CIN的显示高阶特征交互的特性。</p><h2 id="与隐式网络的组合"><a href="#与隐式网络的组合" class="headerlink" title="与隐式网络的组合"></a>与隐式网络的组合</h2><p>​    DNN能够学习出隐式高阶特征，所以DNN与CIN再加上线性模型就一起构成了xDeepFM，如下图所示即为xDeepFM的结构。<br><img src="/2019/03/08/xDeepFM/xdeepfm.png" alt="xdeepfm"></p><p>整个xDeepFM的输出单元为<br>$$<br>\hat{y}=\sigma(w_{linear}^Ta + w_{dnn}^Tx_{dnn}^k+w_{cin}^Tp^+ + b)<br>$$<br>损失函数为<br>$<br>L = -\frac{1}{N}\sum_{i=1}^N \lbrace yi \log\hat{y}i + (1-yi) \log(1-\hat{y}i)\rbrace +\lambda^{\ast}\Vert\Theta \Vert<br>​$<br>后面一项为正则项。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/2019/02/03/GIt%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/02/03/GIt%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Git的三种状态"><a href="#Git的三种状态" class="headerlink" title="Git的三种状态"></a>Git的三种状态</h1><ul><li>已提交：数据已安全的保存在数据库中</li><li>已修改：修改了文件还没保存到数据库中</li><li>已暂存：对一个已修改的文件做了标记，使之包含在下次提交的快照中</li></ul><h2 id="Git的三种工作区"><a href="#Git的三种工作区" class="headerlink" title="Git的三种工作区"></a>Git的三种工作区</h2><ul><li>Git仓库：Git用来保存项目的元数据和对象数据库的地方</li><li>工作目录：供修改的文件</li><li>暂存区域：它是一个文件，保存了下次将提交的文件列表信息</li></ul><p><img src="/2019/02/03/GIt基础/Git工作区.png" alt="Git工作区"></p><h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><ol><li>/etc/gitconfig文件：包含系统上每个用户的仓库的通用配置；查看系统配置的命令<code>git config --system --list</code></li><li>~/.gitconfig或者~/.config/git/config文件：只针对当前用户;查看当前用户配置的命令<code>git config --global --list</code></li><li>当前仓库Git目录的config文件，.git/config：针对该仓库;查看当前仓库配置的命令<code>git config --local --list</code></li></ol><p>每一个级别覆盖上一级别的配置.可以通过输入<code>git config &lt;key&gt;</code>来检查Git的某一项配置，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">tfei ma</span><br></pre></td></tr></table></figure><h1 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h1><ol><li><code>git help &lt;verb&gt;</code></li><li><code>git &lt;verb&gt; --help</code></li><li><code>man git-&lt;verb&gt;</code></li></ol><h1 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h1><h2 id="在现有项目中初始化仓库"><a href="#在现有项目中初始化仓库" class="headerlink" title="在现有项目中初始化仓库"></a>在现有项目中初始化仓库</h2><p>在该项目目录输入</p><blockquote><p>git init</p></blockquote><p>该命令创建一个<code>.git</code>子目录，这个子目录包含初始化的Git仓库中所有的必须文件。</p><h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><blockquote><p>git clone [url]</p></blockquote><p>如果克隆仓库的时候想自定义本地仓库的名字，可以使用如下命令：</p><blockquote><p>git clone [url] newName</p></blockquote><h1 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h1><p>如下为使用Git时文件的生命周期：</p><p><img src="/2019/02/03/GIt基础/Git文件生命周期.png" alt="Git文件生命周期"></p><h2 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h2><blockquote><p>git status</p></blockquote><ul><li>在untracked files 下面的就是未被跟踪状态的文件</li><li>在Changes to be comitted下面的是已暂存状态的文件</li></ul><p>运行<code>git status -s</code>会得到更为紧凑的输出格式。 </p><h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><blockquote><p>Git add filename</p></blockquote><p><code>git add</code>命令将文件放到暂存区</p><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>我们可以创建一个<code>.gitignore</code>文件，列出要忽略的文件模式，列出的文件将不会别Git跟踪管理。</p><p><code>.gitignore</code>文件的格式规范：</p><ul><li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，即shell使用的正则表达式。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><blockquote><p>git diff</p></blockquote><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p><h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><blockquote><p>git commit -m “information”</p></blockquote><h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><blockquote><p>git rm</p></blockquote><p>这个命令会从工作目录中删除指定的文件，并且从已跟踪的文件清单中移除。</p><h1 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h1><blockquote><p>git log </p></blockquote><p>一些选项：</p><ul><li>-p：用来显示每次提交内容的差异</li><li>-number：显示最近number此提交</li></ul><h1 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h1><h2 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h2><blockquote><p>git reset HEAD filename</p></blockquote><h2 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h2><blockquote><p>git checkout –filename</p></blockquote><p>这是一个很危险的命令，因为对那个文件的任何修改都会消失。</p><h1 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h1><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><blockquote><p>git remote </p></blockquote><p>使用<code>-v</code>参数会显示远程仓库的简写及对应的URL</p><blockquote><p>git remote -v</p></blockquote><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><blockquote><p>git remote add <shortname> <url></url></shortname></p></blockquote><p><shortname>是指定一个可以轻松引用的简写。</shortname></p><h2 id="从远程仓库中拉取和抓取"><a href="#从远程仓库中拉取和抓取" class="headerlink" title="从远程仓库中拉取和抓取"></a>从远程仓库中拉取和抓取</h2><blockquote><p>git fetch [remote-name]</p></blockquote><p>这个命令会访问远程仓库，并从中拉取所有还没有的数据，执行完成后将会拥有那个远程仓库中所有的分支的引用，可以随时查看或者合并。</p><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><blockquote><p>git push [remote-name]</p></blockquote><h2 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h2><blockquote><p>git remote rename oldname newname</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Linux命令行大全》读书笔记</title>
      <link href="/2019/02/02/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/02/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-什么是shell"><a href="#第一章-什么是shell" class="headerlink" title="第一章 什么是shell"></a>第一章 什么是shell</h1><p>shell就是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统执行。当使用图像用户界面时，我们需要一个叫做终端仿真器的程序和shell作交互。超级用户的提示符是<code>$</code>,普通用户的提示符为<code>#</code>.</p><h2 id="一些简单的命令"><a href="#一些简单的命令" class="headerlink" title="一些简单的命令"></a>一些简单的命令</h2><ul><li>date：显示系统当前的日期和时间</li><li>cal：显示当前月份的日历</li><li>df: 查看磁盘剩余空间的数量</li><li>free：显示内存空闲的数量</li><li>exit: 结束终端会话</li></ul><h1 id="第二章-文件系统中跳转"><a href="#第二章-文件系统中跳转" class="headerlink" title="第二章 文件系统中跳转"></a>第二章 文件系统中跳转</h1><h2 id="显示当前工作目录"><a href="#显示当前工作目录" class="headerlink" title="显示当前工作目录"></a>显示当前工作目录</h2><p>pwd</p><h2 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a>列出目录内容</h2><p>ls</p><h2 id="更改当前工作目录"><a href="#更改当前工作目录" class="headerlink" title="更改当前工作目录"></a>更改当前工作目录</h2><p>cd</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><ul><li><code>.</code>: 工作目录</li><li><code>..</code>: 工作目录的父目录</li><li><code>~</code>: 家目录</li></ul><h1 id="第三章-研究操作系统"><a href="#第三章-研究操作系统" class="headerlink" title="第三章 研究操作系统"></a>第三章 研究操作系统</h1><h2 id="ls命令选项和参数"><a href="#ls命令选项和参数" class="headerlink" title="ls命令选项和参数"></a>ls命令选项和参数</h2><table><thead><tr><th>选项</th><th>长选项</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>–all</td><td>列出所有文件包括隐藏文件</td></tr><tr><td>-h</td><td>–human-readable</td><td>以人们可读的格式列出</td></tr><tr><td>-l</td><td></td><td>以长格式显示结果</td></tr><tr><td>-r</td><td>–reverse</td><td>以相反的顺序显示结果</td></tr><tr><td>-S</td><td></td><td>按文件大小来排序</td></tr><tr><td>-t</td><td></td><td>按修改时间来排序</td></tr></tbody></table><h3 id="深入研究长格式"><a href="#深入研究长格式" class="headerlink" title="深入研究长格式"></a>深入研究长格式</h3><blockquote><p>-rw-r–r–    1 ma  staff     4579  2  3 10:09 debug.log</p></blockquote><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>-rw-r–r–</td><td>文件的访问权限。第一个字符指明文件类型，‘-’是一个普通文件，‘d’是一个目录。后面三个是所有者的权限，再三个是群组成员的权限，后三个是其它人的权限。</td></tr><tr><td>1</td><td>文件的硬链接数目</td></tr><tr><td>Ma</td><td>文件所属的用户名</td></tr><tr><td>staff</td><td>文件所属的群组名</td></tr><tr><td>4579</td><td>以字节数表示的文件大小</td></tr><tr><td>—-</td><td>上次修改的文件日期</td></tr><tr><td>***</td><td>文件名</td></tr></tbody></table><h2 id="确定文件类型"><a href="#确定文件类型" class="headerlink" title="确定文件类型"></a>确定文件类型</h2><blockquote><p>file filename</p></blockquote><h2 id="用less浏览文件内容"><a href="#用less浏览文件内容" class="headerlink" title="用less浏览文件内容"></a>用less浏览文件内容</h2><blockquote><p>Less filename</p></blockquote><p>less常用的键盘命令：</p><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td>page up or b</td><td>向上翻页</td></tr><tr><td>page down or space</td><td>向下翻页</td></tr><tr><td>G</td><td>移动到最后一个行</td></tr><tr><td>1G or g</td><td>移动到开头一行</td></tr><tr><td>/characters</td><td>向前查找指定的字符串</td></tr><tr><td>n</td><td>向下查找下一个出现的字符</td></tr><tr><td>h</td><td>显示帮助</td></tr><tr><td>q</td><td>退出less</td></tr></tbody></table><h1 id="第四章-操作文件和目录"><a href="#第四章-操作文件和目录" class="headerlink" title="第四章 操作文件和目录"></a>第四章 操作文件和目录</h1><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table><thead><tr><th>通配符</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>匹配任意多个字符，包括0个和1个</td></tr><tr><td>？</td><td>匹配任意一个字符</td></tr><tr><td>[characters]</td><td>匹配任意一个属于字符集中的字符</td></tr><tr><td>[!characters]</td><td>匹配任意一个非字符集中的字符</td></tr><tr><td>[[:class:]]</td><td>匹配任意一个指定类中的字符</td></tr></tbody></table><p>常用的字符类：<br>| 字符符                 | 意义                           |<br>| ———————- | —————————— |<br>| [:alnum:]              | 匹配任意一个字母或数字         |<br>| [:alpha:]              | 匹配任意一个字母               |<br>| [:digit:]              | 匹配任意一个数字               |<br>| [:upper:]或者[:lower:] | 匹配任意一个大写或者小写字母   |</p><h2 id="mkdir创建目录"><a href="#mkdir创建目录" class="headerlink" title="mkdir创建目录"></a>mkdir创建目录</h2><blockquote><p>mkdir dir1 dir2</p></blockquote><p>创建目录dir1和dir2</p><h2 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="headerlink" title="cp 复制文件和目录"></a>cp 复制文件和目录</h2><blockquote><p>cp item1 item2</p><p>cp item1… directory</p></blockquote><p>一些有用的选项</p><table><thead><tr><th>选项</th><th>意义</th></tr></thead><tbody><tr><td>-a, –archive</td><td>复制文件和目录，以及他们的属性</td></tr><tr><td>-i, –interactive</td><td>-i, –interactive</td></tr><tr><td>-r, –recursive</td><td>递归地复制目录和文件，复制目录时，需要这个选项</td></tr><tr><td>-u, –update</td><td>仅复制目标目录中不存在的文件</td></tr></tbody></table><h2 id="mv-移动和重命名文件"><a href="#mv-移动和重命名文件" class="headerlink" title="mv 移动和重命名文件"></a>mv 移动和重命名文件</h2><blockquote><p>mv item1 item2</p></blockquote><p>一些选项</p><table><thead><tr><th>选项</th><th>意义</th></tr></thead><tbody><tr><td>-i, –interactive</td><td>-i, –interactive</td></tr><tr><td>-u, –update</td><td>仅复制目标目录中不存在的文件</td></tr></tbody></table><h2 id="rm-删除文件和目录"><a href="#rm-删除文件和目录" class="headerlink" title="rm 删除文件和目录"></a>rm 删除文件和目录</h2><p>rm选项和意义：</p><table><thead><tr><th>选项</th><th>意义</th></tr></thead><tbody><tr><td>-i,–interactive</td><td>删除前提示用户</td></tr><tr><td>-r,–recursive</td><td>递归地删除文件，若删除目录则需指定这个选项</td></tr><tr><td>-f,–force</td><td>忽视不存在的文件，不显示提示信息</td></tr><tr><td>-v,–verbose</td><td>执行命令时，显示详实的信息</td></tr></tbody></table><p>Linux系统没有复原命令，一旦用rm删除一些东西，就永远消失了，所以无论啥时候，rm命令用到通配符的时候，先用<code>ls</code>测试通配符。</p><h1 id="第五章-使用命令"><a href="#第五章-使用命令" class="headerlink" title="第五章 使用命令"></a>第五章 使用命令</h1><h2 id="命令是什么"><a href="#命令是什么" class="headerlink" title="命令是什么"></a>命令是什么</h2><p>命令可以是下列4种形式之一：</p><ol><li>是一个可执行程序</li><li>是一个内建于shell自身的命令</li><li>是一个shell函数</li><li>是一个命令别名</li></ol><h2 id="显示命令的类型"><a href="#显示命令的类型" class="headerlink" title="显示命令的类型"></a>显示命令的类型</h2><p><code>type</code>是shell的内部命令，它会显示命令的类别，给出一个特定的命令名。</p><h2 id="显示一个可执行程序的位置"><a href="#显示一个可执行程序的位置" class="headerlink" title="显示一个可执行程序的位置"></a>显示一个可执行程序的位置</h2><p>使用<code>which</code>命令可以确定所给定的执行程序的准确位置。</p><h2 id="得到shell内部命令的帮助文档"><a href="#得到shell内部命令的帮助文档" class="headerlink" title="得到shell内部命令的帮助文档"></a>得到shell内部命令的帮助文档</h2><p>使用<code>help command</code>命令得到命令的帮助文档；许多可执行程序支持<code>--help</code>选项，显示此命令支持的语法和选项说明。</p><h2 id="man-显示程序手册页"><a href="#man-显示程序手册页" class="headerlink" title="man 显示程序手册页"></a>man 显示程序手册页</h2><h2 id="whatis-显示非常简洁的命令说明"><a href="#whatis-显示非常简洁的命令说明" class="headerlink" title="whatis 显示非常简洁的命令说明"></a>whatis 显示非常简洁的命令说明</h2><h2 id="info-显示程序的Info条目"><a href="#info-显示程序的Info条目" class="headerlink" title="info 显示程序的Info条目"></a>info 显示程序的Info条目</h2><h2 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h2><p>使用<code>alias</code>命令创建命令的别名，使用方法</p><blockquote><p>alias name=’string’</p></blockquote><p>注意：name与string之间没有空格。string是一系列的命令，name是这一系列命令的别名，下次输入name时等价于输入string。</p><p>使用<code>unalias</code>命令删除别名。</p><h1 id="第六章-重定向"><a href="#第六章-重定向" class="headerlink" title="第六章 重定向"></a>第六章 重定向</h1><h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><p>一般地，输出送到屏幕，输入来自键盘，但是通过I/O重定向我们可以改变输入输出的方向。</p><h2 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h2><p>使用<code>&gt;</code>重定向符，后面跟着文件名，则会把原本输出到标准输出的内容输出到重定向符后面的文件中。需要注意的是使用<code>&gt;</code>重定向符重定向输出结果时，目标文件总是从头开始被重写。所以当我们需要删除一个文件内容或者新建一个空文件的时候，可以使用这样一个技巧：</p><blockquote><p>> filename</p></blockquote><p>使用<code>&gt;&gt;</code>重定向符可以把重定向结果追加到文件内容后面，而不是重头开始写文件,如果文件不存在，文件会被新建。</p><blockquote><p>>&gt; filename</p></blockquote><h2 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h2><p>文件描述符0，1，2分别表示标准输入、输出和错误。</p><blockquote><p>ls -l /bin/usr 2&gt; ls-error.txt</p></blockquote><p>文件描述符’2‘紧挨着放在重定向符之前，执行重定向标准错误到文件ls-error.txt任务。</p><h2 id="重定向标准输出和错误到同一个文件"><a href="#重定向标准输出和错误到同一个文件" class="headerlink" title="重定向标准输出和错误到同一个文件"></a>重定向标准输出和错误到同一个文件</h2><p>第一种方法：</p><blockquote><p>ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</p></blockquote><p>这里使用了两次重定向，首先重定向标准输出到文件ls-output.txt，然后重定向文件描述符2到文件描述符1，使用表示法2&gt;&amp;1.</p><p>第二种方法：</p><blockquote><p>ls -l /bin/usr &amp;&gt; ls-output.txt</p></blockquote><h2 id="处理不需要的输出"><a href="#处理不需要的输出" class="headerlink" title="处理不需要的输出"></a>处理不需要的输出</h2><blockquote><p>ls -l /bin/usr 2&gt; /dev/null</p></blockquote><h2 id="重定向标准输入"><a href="#重定向标准输入" class="headerlink" title="重定向标准输入"></a>重定向标准输入</h2><h3 id="cat-连接文件"><a href="#cat-连接文件" class="headerlink" title="cat 连接文件"></a>cat 连接文件</h3><p>cat命令读取一个或多个文件，然后复制他们到标准输出,cat经常用来显示简短的文本文件。</p><blockquote><p>cat [file]</p></blockquote><p>cat可以将多个文件连接成或者合并为一个文件：</p><blockquote><p>cat file1 … filem &gt; cat_file</p></blockquote><h2 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h2><p>管道线操作符<code>|</code>可以使一个命令的标准输出作为另一个命令的标准输入：</p><blockquote><p>command1 | command2</p></blockquote><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul><li>sort，排序</li><li>uniq，忽略重复行</li><li>wc，打印行，字和字节数</li><li>grep，打印匹配行</li><li>head/tail，打印文件开头、结尾部分</li></ul><h1 id="第七章-从shell眼中看世界"><a href="#第七章-从shell眼中看世界" class="headerlink" title="第七章 从shell眼中看世界"></a>第七章 从shell眼中看世界</h1><h2 id="字符展开"><a href="#字符展开" class="headerlink" title="字符展开"></a>字符展开</h2><h2 id="算术表达式展开"><a href="#算术表达式展开" class="headerlink" title="算术表达式展开"></a>算术表达式展开</h2><h2 id="花括号展开"><a href="#花括号展开" class="headerlink" title="花括号展开"></a>花括号展开</h2><p>通过它可以从一个包含花括号的模式中创建多个字符串。</p><blockquote><p>ma$ echo F-{a,b,c}-B</p><p>F-a-B F-b-B F-c-B</p></blockquote><blockquote><p>ma$ echo {1..10}</p><p>1 2 3 4 5 6 7 8 9 10</p></blockquote><blockquote><p>echo {A..Z}</p><p>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p></blockquote><h2 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h2><p>其实就是shell中的变量。</p><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><blockquote><p>ma\$ ls -l ​\$(which cd)</p><p>-rwxr-xr-x  15 root  wheel  190  8 18 08:20 /usr/bin/cd</p></blockquote><p><code>which cd</code>会返回一个路径。</p><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>双引号中的文本被当做普通字符看待，但是参数展开和算术表达式展开仍然有效。</p><h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><p>所有的展开将被禁止。</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><table><thead><tr><th>转移序列</th><th>含义</th></tr></thead><tbody><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格键</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>制表符</td></tr></tbody></table><h1 id="第八章-键盘高级技巧"><a href="#第八章-键盘高级技巧" class="headerlink" title="第八章 键盘高级技巧"></a>第八章 键盘高级技巧</h1><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-a</td><td>移动光标到行首</td></tr><tr><td>Ctrl-e</td><td>行尾</td></tr><tr><td>Ctrl-f</td><td>右键头</td></tr><tr><td>Ctrl-b</td><td>左箭头</td></tr><tr><td>Alt-f</td><td>光标前移一个字</td></tr><tr><td>Alt-b</td><td>光标后移一个字</td></tr><tr><td>Ctrl-l</td><td>清空屏幕，同clear命令相同</td></tr></tbody></table><h2 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h2><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-d</td><td>删除光标位置的字符</td></tr><tr><td>Ctrl-t</td><td>光标位置的字符和光标前面的字符互换位置</td></tr><tr><td>Alt-t</td><td>光标位置的字和前面的字互换位置</td></tr><tr><td>Alt-l</td><td>把光标位置到字尾的字符换成小写字母</td></tr><tr><td>Alt-u</td><td>把光标位置到字尾的字符换成大写字母</td></tr></tbody></table><h2 id="剪切和粘贴"><a href="#剪切和粘贴" class="headerlink" title="剪切和粘贴"></a>剪切和粘贴</h2><table><thead><tr><th>按键</th><th>行动</th></tr></thead><tbody><tr><td>Ctrl-k</td><td>剪切光标位置到行尾的文本</td></tr><tr><td>Ctrl-u</td><td>剪切光标位置到行首的文本</td></tr><tr><td>Alt-d</td><td>剪切光标位置到词尾的文本</td></tr><tr><td>Alt-backspace</td><td>剪切光标位置到词头的文本</td></tr><tr><td>Ctrl-y</td><td>把剪切板的内容粘贴到光标位置</td></tr></tbody></table><h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><p><code>history</code>显示历史命令。</p><p>可以通过</p><blockquote><p>history | less</p></blockquote><p>来浏览历史命令。通过执行</p><blockquote><p>history | grep 目录</p></blockquote><p>来找到此目录中的命令。通过</p><blockquote><p>!行号</p></blockquote><p>来执行历史命令中此行号对应的命令。</p><h1 id="第九章-权限"><a href="#第九章-权限" class="headerlink" title="第九章 权限"></a>第九章 权限</h1><p>创建一个文件并显示它的详细信息</p><blockquote><p>$ &gt; foo.txt</p><p>$ ls -l foo.txt</p><p>-rw-r–r–  1 ma  staff  0  2 16 19:46 foo.txt</p></blockquote><p>显示的前十个字符是文件的属性，第一个字符表示文件的类型。下表是文件常见的类型：</p><table><thead><tr><th>属性</th><th>文件类型</th></tr></thead><tbody><tr><td>-</td><td>普通文件</td></tr><tr><td>d</td><td>目录</td></tr><tr><td>l</td><td>符号链接</td></tr><tr><td>c</td><td>字符设备文件</td></tr><tr><td>b</td><td>快设备文件</td></tr></tbody></table><p>剩下的九个字符代表文件所有者、文件组所有者、其他人的读写和执行权限。</p><h2 id="chmod-更改文件模式"><a href="#chmod-更改文件模式" class="headerlink" title="chmod 更改文件模式"></a>chmod 更改文件模式</h2><p>可以使用两种方法改变文件模式：八进制数字表示法和符号表示法。</p><h3 id="数字表示法"><a href="#数字表示法" class="headerlink" title="数字表示法"></a>数字表示法</h3><p>因为对所有者、群组和其他人分别有r、w、x三种权限，所以假如对于所有者的权限来讲，所有者对文件有r权限和w权限，但是x权限没有，那么他有的权限的位置就置为1，反之为0，那么对应地二进制表示为110，与此对应的八进制为6，即所有者的权限用一个4表示，其它群组和其他人时同理，所以一个文件可以用3个八进制数字表示它的权限模式。例如改变foo.txt的文件权限：</p><blockquote><p>$ chmod 600 foo.txt</p><p>$ ls -l foo.txt</p><p>-rw——-  1 ma  staff  0  2 16 19:46 foo.txt</p></blockquote><h3 id="符号表示法"><a href="#符号表示法" class="headerlink" title="符号表示法"></a>符号表示法</h3><p>符号表示法分为3个部分：更改会影响谁，要执行那个操作，要设置哪种权限。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>u</td><td>文件所有者</td></tr><tr><td>g</td><td>用户组</td></tr><tr><td>o</td><td>其他人</td></tr><tr><td>a</td><td>u、g、o三者的组合</td></tr></tbody></table><p>若没有指定字符，则假定使用a。</p><p>执行的操作有两种：<code>+</code>增加一个权限，<code>-</code>删掉一个权限。</p><p>权限用r、w、x指定。例如</p><blockquote><p>$ chmod g+r foo.txt </p><p>$ ls -l foo.txt </p><p>-rw-r—–  1 ma  staff  0  2 16 19:46 foo.txt</p></blockquote><h2 id="更改身份"><a href="#更改身份" class="headerlink" title="更改身份"></a>更改身份</h2><h2 id="su-以其他用户和组ID运行一个shell"><a href="#su-以其他用户和组ID运行一个shell" class="headerlink" title="su 以其他用户和组ID运行一个shell"></a>su 以其他用户和组ID运行一个shell</h2><p>su命令以另一个用户的身份来启动shell：</p><blockquote><p>su [-[l]] [user]</p></blockquote><p>如果包含-l选项，那么会为指定用户启动一个需要登录的shell，意味着会加载这个用户的shell环境，并且工作目录会更改到这个用户的家目录。如果不指定用户，则默认启动超级用户。-l可以缩写为-，例如启动超级用户：</p><blockquote><p>su -</p></blockquote><p>当工作完成后，输入<code>exit</code>返回原来的shell。也可以只执行单个命令，而不是启动一个新的可交互的shell，</p><blockquote><p>su -c ‘command’</p></blockquote><p>命令用单引号括起来。</p><h3 id="sudo-以另一个用户身份执行命令"><a href="#sudo-以另一个用户身份执行命令" class="headerlink" title="sudo 以另一个用户身份执行命令"></a>sudo 以另一个用户身份执行命令</h3><p>sudo很多方面类似于su，但sudo还有其他一些总要的功能。管理员可以配置sudo命令，从而使用户以不同身份通过一种可控的方式来执行命令。sudo命令不要求超级用户的密码，而是需要自己的密码来认证。sudo命令不会重新启动一个shell，命令不必用单引号括起来。</p><h2 id="chown-更改文件所有者和用户组"><a href="#chown-更改文件所有者和用户组" class="headerlink" title="chown 更改文件所有者和用户组"></a>chown 更改文件所有者和用户组</h2><p>使用这个命令需要超级用户权限。命令语法：</p><blockquote><p>chown [owner][:[grou]] file…</p></blockquote><h2 id="更改用户密码"><a href="#更改用户密码" class="headerlink" title="更改用户密码"></a>更改用户密码</h2><p>只要输入<code>passwd</code>命令，就能更改你的密码。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>William E.Shotts,Linux命令行大全</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《流畅的Python》----第五章 一等函数</title>
      <link href="/2018/12/06/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/06/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第五章-一等函数"><a href="#第五章-一等函数" class="headerlink" title="第五章 一等函数"></a>第五章 一等函数</h1><p>函数是一等对象，一等对象需满足</p><ul><li>在运行时创建</li><li>能赋值给对象或者数据结构中的元素</li><li>能作为参数传递给函数</li><li>能作为函数的返回结果</li></ul><p>在Python中，整数、字符串、字典等都是一等对象，函数也是一等对象，只是把函数视作一等对象的时候，简称为一等函数。</p><h2 id="把函数视作对象"><a href="#把函数视作对象" class="headerlink" title="把函数视作对象"></a>把函数视作对象</h2><p>函数也是对象，本身是<code>function</code>类的实例</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>接受函数作为参数，或者把函数作为返回结果的函数叫做高阶函数。常见的高阶函数有<code>map</code>,<code>filter</code>,<code>sorted</code>等，其中<code>map</code>和<code>filter</code>返回的是生成器。</p><p> <strong><code>all</code>和<code>any</code>的用法:</strong></p><ul><li>all(iterable),如果iterable的每个元素都是真值则返回True，all([])返回True</li><li>any(iterable),只要iterable有元素为真则返回true，all([])返回False</li></ul><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>能使用<code>()</code>的都被叫做可调用对象，可使用<code>callable()</code>判断一个对象是否是可调用对象，python中有7中可调用对象：</p><ol><li>用户定义的函数</li><li>内置函数</li><li>内置方法</li><li>方法</li><li>类，调用时会运行<code>__new__</code>方法创建一个实例，然后运行<code>__init__</code>方法初始化实例，最后把实例返回给调用方。</li><li>类的实例，前提是类定义了<code>__call__</code>方法。</li><li>生成器函数，在函数中使用了<code>yieled</code>语句的</li></ol><h2 id="用户定义的可调用类型"><a href="#用户定义的可调用类型" class="headerlink" title="用户定义的可调用类型"></a>用户定义的可调用类型</h2><p>只需实现<code>__call__</code>方法。</p><p><strong>例子，从打乱的列表中取出一个元素</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">calss BingoCage:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,items)</span>:</span></span><br><span class="line">        self._items = list(items)</span><br><span class="line">        random.shuffle(self._items)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._items.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty BingCage'</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.pick()</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bingo = BingoCage(range(<span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bingo.pick()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bingo()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># bingo.pick()和bingo()的作用是一样的</span></span><br></pre></td></tr></table></figure><h2 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h2><p>Wikipedia<a href="https://zh.wikipedia.org/zh-hans/%E5%86%85%E7%9C%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener"><strong>内省</strong></a>)的定义：<br>内省是指计算机程序在运行时（Run time）检查对象（Object）类型的一种能力，通常也可以称作运行时类型检查。</p><p>通俗来讲就是Python在运行时能够知道这个对象是什么，它能做什么，它包含哪些内容。</p><p><strong>一些内省函数</strong>：</p><ul><li><code>dir(object)</code>:它返回一个列表，这个列表中包含object的所有属性</li><li><code>type</code>:返回一个对象的类型</li><li><code>id</code>：返回一个对象的id</li></ul><h2 id="获取关于参数的信息"><a href="#获取关于参数的信息" class="headerlink" title="获取关于参数的信息"></a>获取关于参数的信息</h2><p>函数对象有个<code>__defaults__</code>属性，它的值是一个元组，里面保存着定位参数和关键字参数的默认值。<code>__kwdefaults__</code>包含仅限关键字参数的默认值。参数的名称在<code>__code__</code>属性中，它的值是一个code对象引用。</p><h2 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h2><p>函数声明中的各个参数可以在：之后增加注解表达式。如果参数有默认值放在参数名和=之间。如果想添加返回值注解，在）和函数声明末尾：之间添加-&gt;和一个表达式。<br>注解存储在<code>__annotations__</code>属性中</p><h2 id="支持函数式编程的包"><a href="#支持函数式编程的包" class="headerlink" title="支持函数式编程的包"></a>支持函数式编程的包</h2><h3 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h3><p><code>itmegetter</code>和<code>attrgetter</code>会自行构建函数，所起的作用类似于使用lambda表达式从序列中取出元素或者读取对象的属性。</p><p><strong>itemgetter</strong><br><strong>下例</strong>利用<code>itemgetter</code>排序一个数组，<code>itemgetter()</code>的作用与<code>lambda fields: fields[1]</code>相同，创建一个接收集合的函数，返回索引位1的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>metro_data = [(<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),(<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),(<span class="string">'Sao Paulo'</span>, <span class="string">'BR'</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_data, key=itemgetter(<span class="number">1</span>)):</span><br><span class="line"><span class="meta">... </span>    print(city)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'Sao Paulo'</span>, <span class="string">'BR'</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>))</span><br><span class="line">(<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line">(<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>))</span><br></pre></td></tr></table></figure><p><strong>attrgetter</strong></p><p>它创建的函数根据名称提取对象的属性，如果把多个属性名传给<code>attrgetter</code>，它也会返回提取的值构成的元组。</p><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LatLong = namedtuple(<span class="string">'LatLong'</span>, <span class="string">'lat long'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Metropolis = namedtuple(<span class="string">'Metropolis'</span>, <span class="string">'name cc pop coord'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long)) <span class="keyword">for</span> name,cc,pop,(lat,long) <span class="keyword">in</span> metro_data]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>metro_areas[<span class="number">0</span>]</span><br><span class="line">Metropolis(name=<span class="string">'Tokyo'</span>, cc=<span class="string">'JP'</span>, pop=<span class="number">36.933</span>, coord=LatLong(lat=<span class="number">35.689722</span>, long=<span class="number">139.691667</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>metro_areas[<span class="number">0</span>].coord.lat</span><br><span class="line"><span class="number">35.689722</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name_lat = attrgetter(<span class="string">'name'</span>,<span class="string">'coord.lat'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_areas,key=attrgetter(<span class="string">'coord.lat'</span>)):</span><br><span class="line"><span class="meta">... </span>    print(name_lat(city))</span><br><span class="line">...</span><br><span class="line">(<span class="string">'Sao Paulo'</span>, <span class="number">-23.547778</span>)</span><br><span class="line">(<span class="string">'Delhi NCR'</span>, <span class="number">28.613889</span>)</span><br><span class="line">(<span class="string">'Tokyo'</span>, <span class="number">35.689722</span>)</span><br></pre></td></tr></table></figure></p><p><strong>methodcaller</strong></p><p><code>methodcaller</code>创建的函数会在对象上调用参数指定的方法。</p><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'good good study, day day up'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase = methodcaller(<span class="string">'upper'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase(s)</span><br><span class="line"><span class="string">'GOOD GOOD STUDY, DAY DAY UP'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h3 id="使用functools-partial冻结参数"><a href="#使用functools-partial冻结参数" class="headerlink" title="使用functools.partial冻结参数"></a>使用<code>functools.partial</code>冻结参数</h3><p><code>functools.partial</code>这个高阶函数用于部分应用一个函数。部分应用指的是，基于一个函数创建一个新的可调用对象，把原函数的某些参数固定。</p><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = partial(mul,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[triple(i) <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">6</span>)]</span><br><span class="line">    [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《流畅的Python》----第三章 字典和集合</title>
      <link href="/2018/11/21/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
      <url>/2018/11/21/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第三章-字典和集合"><a href="#第三章-字典和集合" class="headerlink" title="第三章 字典和集合"></a>第三章 字典和集合</h1><h2 id="泛化映射类型"><a href="#泛化映射类型" class="headerlink" title="泛化映射类型"></a>泛化映射类型</h2><p>标准库里所有的映射类型都是利用dict实现的，只有可散列的数据类型才可以用作这些映射的键。</p><p>什么是可散列的数据类型?</p><ol><li>在这个对象的生命周期中，它的散列值是不变的</li><li>而且这个对象需实现<code>__hash__()</code>方法</li><li>还要有<code>__qe__()</code>方法，这样才能跟其他键比较</li></ol><p>可散列的数据类型有哪些？</p><ul><li>原子不可变类型：<code>str</code>,<code>bytes</code>,<code>数值类型</code></li><li><code>frozenset</code>（返回一个冻结的集合，冻结后集合不能再添加或删除任何元素）</li><li>元组，只有当元组中所有元素都是可散列的，它才是可散列的</li><li>一般用户自定义的对象，散列值就是id()函数返回的值</li></ul><h2 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><p>与列表推导式类似，看下面的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple_list = [(<span class="number">1</span>,<span class="string">'a'</span>),(<span class="number">2</span>,<span class="string">'b'</span>),(<span class="number">3</span>,<span class="string">'c'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple_list</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dictcomp = &#123;str(i):j <span class="keyword">for</span> i,j <span class="keyword">in</span> tuple_list&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dictcomp</span><br><span class="line">&#123;<span class="string">'1'</span>: <span class="string">'a'</span>, <span class="string">'2'</span>: <span class="string">'b'</span>, <span class="string">'3'</span>: <span class="string">'c'</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="处理找不到的键"><a href="#处理找不到的键" class="headerlink" title="处理找不到的键"></a>处理找不到的键</h2><h3 id="用d-get-k-default）处理找不到的键"><a href="#用d-get-k-default）处理找不到的键" class="headerlink" title="用d.get(k,default）处理找不到的键"></a>用d.get(k,default）处理找不到的键</h3><p>字典d[k]找不到正确的键的时候，会抛出异常，可以使用<code>d.get(k,default)</code>代替，但这个用法效率较低。参数default表示当键k不存在的时候，默认返回一个值。</p><p>书中例子的一段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">occurrences = index.get(word,[])</span><br><span class="line"><span class="comment"># 如果word不存在，则会返回一个list</span></span><br><span class="line">occurrences.append(loction)</span><br><span class="line">index[word] = occurrences</span><br></pre></td></tr></table></figure></p><h3 id="用setdefault处理找不到的键"><a href="#用setdefault处理找不到的键" class="headerlink" title="用setdefault处理找不到的键"></a>用setdefault处理找不到的键</h3><p>用法为<code>d.setdefault(key,default)</code>,如果键不存在，就创建这个键，并令这个键指向默认default</p><p>上面Python代码与下面等价：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.setdefault(word,[]).append(location)</span><br></pre></td></tr></table></figure></p><h3 id="collections-defaultdict处理找不到的键"><a href="#collections-defaultdict处理找不到的键" class="headerlink" title="collections.defaultdict处理找不到的键"></a>collections.defaultdict处理找不到的键</h3><p>在创建defaultdict对象的时候，首先需要给它配置一个当找不到键时候的默认值。具体地，实例化一个defaultdict的时候，需要给构造方法提供一个可调用的对象，这个可调用对象会在<code>__getitem__</code>找不到键的时候被调用，让<code>__getitem__</code>返回某种默认值。</p><p>当创建字典:<code>dd = collections.defaultdict(list)</code>时，如果<code>dd[key]</code>找不到键key，表达式<code>dd[key]</code>会执行3个步骤：</p><ol><li>调用<code>list()</code>创建一个列表</li><li>把这个列表作为值，key作为键放到dd中</li><li>返回这个列表的引用</li></ol><p>上面的python语句可修改为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line">index[word].append(location)</span><br></pre></td></tr></table></figure></p><h2 id="特殊方法-missing"><a href="#特殊方法-missing" class="headerlink" title="特殊方法__missing__"></a>特殊方法<code>__missing__</code></h2><p>所有的映射类型在找不到键的时候，即在<code>__getitem__</code>找不到键的时候，Python会自动调用<code>__missing__</code>方法。<code>__missing__</code>方法只会被<code>__getitem__</code>调用。</p><p>例子StrKeyDict0类,这个类可以同时使用非字符和字符类型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict0</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="comment"># 这里继承了dict类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self,str)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key,str):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="comment"># 如果key本身就是str类型，则抛出异常，这里是为了防止死循环</span></span><br><span class="line">        <span class="keyword">return</span> self[str(key)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,default=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line">        <span class="comment"># 如果抛出异常，说明__missing__也失败了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self,key)</span>:</span></span><br><span class="line">        retrurn key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()</span><br></pre></td></tr></table></figure></p><h2 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h2><ol><li>collections.OrderedDict<br>这个类型在添加键的时候会保持键顺序，所以在迭代的时候，键的次序总是一致的。</li><li>collections.ChainMap<br>这个类型可以容纳数个不同的映射对象，当进行键查找的时候，这些对象会被当做一个整体，逐个被查找，直到找到建为止。</li><li>collections.Counter<br>计数</li><li>collections.UserDict<br>UserDict有一个data属性，这个属性是UserDict最终存储数据的地方</li></ol><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><ol><li>set类型和frozneset类型</li><li>使用{1,2,3}要比set([1,2,3])速度快很多，因为后者首先查询构造语法，然后生成一个list，最后把这个list传入构造语法中</li><li>集合推导式，用{}括起来</li></ol><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>dict和set的底层实现都是<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">散列表</a></p><h3 id="查询的过程"><a href="#查询的过程" class="headerlink" title="查询的过程"></a>查询的过程</h3><p>为了获取 my_dict[search_key] 背后的值， Python首先会调用hash(search_key) 来计算 search_key 的散列值，把这个值最低的几位数字当作偏移量，在散列表里查找表元（具体取几位， 得看当前散列表的大小） 。 若找到的表元是空的， 则抛出 KeyError 异常。 若不是空的， 则表元里会有一对 found_key:found_value。这时候 Python 会检验 search_key == found_key 是否为真， 如果它们相等的话， 就会返回 found_value。如果search_key ！= found_key，则发生散列冲突，需根据解决冲突的办法，继续下一个搜索。</p><h3 id="dict-set的实现及其导致的后果"><a href="#dict-set的实现及其导致的后果" class="headerlink" title="dict/set的实现及其导致的后果"></a>dict/set的实现及其导致的后果</h3><ol><li><strong>键必须是可hash的</strong></li><li>字典在<strong>内存上需要巨大的开销</strong>，因为散列表的稀疏性质，导致它在空间上的效率低下。</li><li><strong>查询快</strong></li><li><strong>往字典里添加新键可能会改变已有键的次序</strong>，因为Python会设法保证大概有三分之一的表元是空的，所以快要到达这个阈值的时候，原有的散列表会被复制到一个更大的空间。所以当添加新键的时候，Python解释器都有可能会对字典扩容，建立一个更大的散列表，这时候会产生新的和原来不一样的hash冲突，导致新散列表中的键的次序发生变化。<strong>故当迭代一个字典的时候同时对这个字典修改，这个循环有可能会跳过一些键，所以最好不要同时对一个字典进行迭代和修改</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《流畅的Python》读书笔记----第二章 序列构成的数组</title>
      <link href="/2018/11/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2018/11/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第二章-序列构成的数组"><a href="#第二章-序列构成的数组" class="headerlink" title="第二章 序列构成的数组"></a>第二章 序列构成的数组</h1><h2 id="Python内置序列类型"><a href="#Python内置序列类型" class="headerlink" title="Python内置序列类型"></a>Python内置序列类型</h2><p>两种分类：</p><blockquote><ul><li>容器序列：这些序列能存放不同类型的数据，并且存放的是它们所包含的对象的引用，比如list,tuple,collection.deque</li><li>扁平序列：这类序列只能容纳一种数据类型，是一段连续的内存空间，比如str,bytes,bytearray,memoryview,array.array</li></ul></blockquote><p>按照元素能否被修改分类：</p><blockquote><ul><li>可变序列：list,collection.deque，bytearray,memoryview,array.array</li><li>不可变序列：str,tuple,bytes</li></ul></blockquote><h2 id="列表推导式和生成器表达式"><a href="#列表推导式和生成器表达式" class="headerlink" title="列表推导式和生成器表达式"></a>列表推导式和生成器表达式</h2><p>列表推导式的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">symbols = <span class="string">'abd79u'</span></span><br><span class="line">codes = [ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价的for循环</span></span><br><span class="line">codes = []</span><br><span class="line"><span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">    codes.append(ord(symbol))</span><br></pre></td></tr></table></figure></p><p><strong>使用列表推导式的一般原则:</strong></p><ol><li>只用列表推导式创建列表，并尽量保持简洁</li><li>如果列表推导式超过两行，最好使用for loop</li></ol><h3 id="列表推导式与filter和map的比较"><a href="#列表推导式与filter和map的比较" class="headerlink" title="列表推导式与filter和map的比较"></a>列表推导式与filter和map的比较</h3><p><strong>例子：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symbols = <span class="string">'abd79u'</span></span><br><span class="line">beyond_ascii = [ord(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> ord(s)&gt;<span class="number">127</span>]</span><br><span class="line"><span class="comment"># 用filter和map实现</span></span><br><span class="line">beyond_ascii = list(filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">127</span>,map(ord,symbols)))</span><br></pre></td></tr></table></figure></p><p>函数map有两个参数，第一个参数为函数名，第二个列表，函数将会作用于列表的每个元素，然后返回作用后的列表。filter也是两个参数，第一个为用于筛选的函数。</p><h3 id="生成表达式"><a href="#生成表达式" class="headerlink" title="生成表达式"></a>生成表达式</h3><p>把列表推导式的<code>[]</code>改成<code>()</code>，表达式就变为了生成表达式，列表推导式与生成表达式的区别在于，若想要迭代一个按规则生成的序列，列表推导式会一次性地生成整个列表，然后将其保存在内存中，而生成表达式只有要迭代到某个元素的时候，才会去生成这个元素，并没有事先建立一个完整的列表，这样做可以大大的节省内存。</p><h2 id="元组不仅仅是不可变的列表"><a href="#元组不仅仅是不可变的列表" class="headerlink" title="元组不仅仅是不可变的列表"></a>元组不仅仅是不可变的列表</h2><h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>元组拆包可以应用到任何可迭代对象上，但是可迭代对象元素数量必须跟接受这些元素的元组的空档数一样，可以用*忽略多余的元素。<br>例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name,age = (tengfei,<span class="number">25</span>)</span><br><span class="line"><span class="comment"># *运算符可以把一个可迭代对象拆开作为函数的参数</span></span><br><span class="line">t = (<span class="number">25</span>,<span class="number">3</span>)</span><br><span class="line">divmod(*t)</span><br><span class="line"><span class="comment"># 输出：（8，1）,商和余数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 平行赋值</span></span><br><span class="line">a,b,*rest = range(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># a:0,b:1,rest:[2,3,4]</span></span><br></pre></td></tr></table></figure></p><h3 id="具名元组namedtuple"><a href="#具名元组namedtuple" class="headerlink" title="具名元组namedtuple"></a>具名元组namedtuple</h3><p>它可以用来构建一个带字段名的元组和一个有名字的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="comment"># 需要两个参数：类名，类的各个字段的名字。后者可由数个字符串组成可迭代的对象或者用空格分开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>City = namedtuple(<span class="string">'City'</span>,<span class="string">'name country population coordinates'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beijing = City(<span class="string">'Beijing'</span>,<span class="string">'China'</span>,<span class="number">1000</span>,(<span class="number">35</span>,<span class="number">110</span>))</span><br><span class="line"><span class="comment"># 可以使用.或者索引来获取字段的信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beijign.country</span><br><span class="line"><span class="string">'China'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beijing[<span class="number">1</span>]</span><br><span class="line"><span class="string">'China'</span></span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>s[a:b:c],在a，b之间以间隔c取值。当使用s[a:b:c]取值的时候，Python会自动调用<code>s.__getitem__(slice[a:b:c])</code></p><h3 id="切片赋值"><a href="#切片赋值" class="headerlink" title="切片赋值"></a>切片赋值</h3><p>如果赋值的对象是一个切片，那么赋值语句的左边必须是一个可迭代的对象，即使只有一个值。</p><h3 id="使用-和"><a href="#使用-和" class="headerlink" title="使用+和*"></a>使用+和*</h3><p>需要注意的是，<code>a*n</code>语句中，如果a里的元素是其他可变对象的引用，比如a里的元素是list，比如<code>a=[[1]]</code>,那么<code>a = a*3</code>语句得到的是包含3个引用的列表<code>[[1],[1],[1]]</code>，如果要修改a中的某个元素，比如<code>a[1][0]=2</code>,那么会得到a变为<code>[[2],[2],[2]]</code></p><h2 id="序列的增量赋值-和"><a href="#序列的增量赋值-和" class="headerlink" title="序列的增量赋值+=和*="></a>序列的增量赋值+=和*=</h2><p>当使用+=或*=时，Python会自动调用<code>__iadd__</code>和<code>__imul__</code></p><h2 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h2><p>list.sort会对列表就地排序，它的返回值是None，所以不能使用max(list.sort)等串联的用法。sorted(list)会对list进行排序，并返回排序后的结果，但不是原地的，也就是list并不会发生改变。</p><p>它俩都有一个<code>key</code>参数，这个参数接受一个只有一个参数的函数（比如<code>len</code>,<code>srt.lower</code>），这个函数作用于list的每一个元素，并返回一个结果，sorted就按照这个返回的结果给list排序。</p><h2 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h2><p>实际应用中，除了list，在一些特殊的场景中，可以使用其他的序列结构，以提高效率。<strong>比如</strong></p><blockquote><ul><li>存储浮点数可以使用<code>array</code>，</li><li>如果需要频繁的先进先出操作，可以选择使用<code>deque</code>。</li><li>如果频繁需要检查一个元素是否在集合中，可以选择<code>set</code></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《流畅的Python》读书笔记----第一章  Python数据模型</title>
      <link href="/2018/11/11/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/11/11/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第一章-Python数据模型"><a href="#第一章-Python数据模型" class="headerlink" title="第一章 Python数据模型"></a>第一章 Python数据模型</h1><h2 id="一摞Python风格的纸牌"><a href="#一摞Python风格的纸牌" class="headerlink" title="一摞Python风格的纸牌"></a>一摞Python风格的纸牌</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>,[<span class="string">'rank'</span>,<span class="string">'suit'</span>])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>)] + list(<span class="string">"JQKA"</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__cards = [Card(rank,suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__cards)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__cards[position]</span><br></pre></td></tr></table></figure><p>由FrenchDeck类生成的对象，可以使用<strong>len()</strong>和<strong>按下标取值</strong>，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(deck)</span><br><span class="line"><span class="number">52</span></span><br><span class="line">&gt;&gt;&gt;deck[<span class="number">0</span>]</span><br><span class="line">Card(rank=<span class="string">'2'</span>,suit=<span class="string">'spades'</span>)</span><br></pre></td></tr></table></figure></p><p>当使用<code>len()</code>时，Python的解释器会自动的调用FrenchDeck类中的__len__方法，对deck对象用下标取值时，自动调用__getitem__方法。</p><h2 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h2><p>特殊方法是给Python解释器调用的，我们自己并不需要调用他们。</p><h3 id="模拟数值类型"><a href="#模拟数值类型" class="headerlink" title="模拟数值类型"></a>模拟数值类型</h3><p>下例是一个Vector类（向量，模拟向量的加法数乘等运算）的实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"><span class="comment"># hypot() 返回欧几里德范数 sqrt(x*x + y*y)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x=<span class="number">0</span>,y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y </span><br><span class="line">    <span class="comment"># repr 的作用是把一个对象用字符串的形式表达出来</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r,%r)'</span> % (self.x,self.y)</span><br><span class="line">    <span class="comment"># 向量的绝对值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x,self.y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self,other)</span>:</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x,y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self,scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x*scalar,self.y*scalar)</span><br></pre></td></tr></table></figure></p><h2 id="为什么len不是普通方法"><a href="#为什么len不是普通方法" class="headerlink" title="为什么len不是普通方法"></a>为什么len不是普通方法</h2><p>如果x是一个内置类型，那么，CPython会直接从一个C结构体里读取对象的长度，完全不用调用任何方法，速度很快。也可以把len用于我们自定义的类型。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解主成分分析（PCA）</title>
      <link href="/2018/08/08/%E7%90%86%E8%A7%A3%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90(PCA)/"/>
      <url>/2018/08/08/%E7%90%86%E8%A7%A3%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90(PCA)/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="理解主成分分析-PCA"><a href="#理解主成分分析-PCA" class="headerlink" title="理解主成分分析(PCA)"></a>理解主成分分析(PCA)</h1><p>PCA的推导过程涉及较多的数学知识，主要有SVD、特征值分解、Lagrange乘子法求解带约束优化问题、矩阵求导、子空间的概念等，如果对这些数学知识没有兴趣的话，可以只看下面一句话概括PCA。</p><blockquote><p>PCA是用来降维的（废话），我们知道在n维空间正交基有无数组，一般我们使用的都是标准正交基，有了标准正交基就可以得到任意一个向量的坐标表示，开始时我们拿到的样本都是标准正交基下的坐标，PCA本质上是在n维特征空间重新找一组正交基（可以理解为将坐标轴旋转了一下），然后计算出样本在这组新正交基下的坐标，这就是PCA所做的工作，如何找这样的一组正交基呢，就是下文中的推导过程了。</p></blockquote><p>本文介绍PCA的两种推导方式，分别是基于最小重构残差和最大投影方差推导出PCA的最终形式,为了便于讨论，以下均假设样本是经过中心化的结果，也就是说样本的均值为0。</p><h2 id="最小重构残差"><a href="#最小重构残差" class="headerlink" title="最小重构残差"></a>最小重构残差</h2><p>假设我们有m个样本，每个样本具有n维特征，这m个样本所构成的样本矩阵为$X = [x_1, x_2, \cdots, x_m] \in R^{m\times n}.$ 现在我们知道每个样本都是在一个n维特征空间中，n可能是一个比较大的数字，由于某些原因我们需要对这些样本进行降维，不妨假设降维到$k$维，我们肯定不希望降维前后丢失太多的信息，也就是说对于所有的样本降维之后损失的信息应该极小化。那么，如何进行降维呢，正如我们假设的已经将每个样本降维至$k$维了，降维后每个样本落在一个k维子空间，所以我们需要找到这样一个k维子空间，并且保证原样本投影到这个k维子空间中，损失的信息最少。如何描述一个k维空间呢？答案就是只需找到一组k个互相正交的向量即可。具体来说，假设要找的k维子空间的k个正交向量为$\lbrace    w_1,w_2,\cdots,w_k \rbrace$,他所构成的矩阵为$W = [w_1,w_2,\cdots,w_k],$那么对于每一个样本$x_i$，它在这个子空间下的投影坐标为$z_i = W^T x_i$ （注意：$z_i$ 是 $x_i$ 投影后的坐标！）,有了坐标，便很容易计算出$x_i$在$k$维子空间的投影向量为$y_i = z_{i1}w_1 + z_{i2}w_2 + \cdots + z_{ik} w_k = Wz_i$. </p><p>举一个具体的例子，如下图所示，在一个二维坐标系内，$w=(\frac{\sqrt{2}}{2},\frac{\sqrt{2}}{2})$是一个单位向量，$x_1 = (4,3)$是一个点，$y_1 = (\frac{7}{2}\sqrt{2},\frac{7}{2}\sqrt{2})$是$x_1$在方向向量$w$上的一个投影向量，若以$w$为坐标轴，那么$y_1$在$w$坐标轴上的坐标为<strong>7</strong>,所以7就是上面公式中的$z_i$，$\overrightarrow{y_1} = 7\overrightarrow{w}$就是$w$对于$x$的重构，那么我们可以计算出它对于$x_1$的重构残差为$| y_1 - x_1 |^2 .$<br><img src="/2018/08/08/理解主成分分析(PCA)/理解主成分分析(PCA" alt="project-emp">project-emp.png)</p><p>回到n维m个样本的情况，我们希望这m个样本的投影后的重构残差$\sum_{i=1}^m \lVert y_i - x_i\rVert^2$最小，并且对于这个$k$维子空间的正交基我们只关心它们的方向，不关心它们的大小，于是约定$w_i^Tw_i= 1$,并且令$y_i = Wz_i$故得到如下优化目标：</p><p>\begin{equation}<br>\begin{array}{r,l}<br>\min &amp; \sum_{i=1}^m \lVert y_i - x_i\rVert^2 \<br>\text{s.t.} &amp; W^TW = I<br>\end{array}<br>\end{equation}</p><p>化简下目标函数,因为<br>\begin{equation}<br>\begin{array}{r,l}<br> &amp; \lVert y_i - x_i\rVert^2  \<br> = &amp; y_i^Ty_i - 2y_i^Tx_i + const \<br> = &amp;-z_i^Tz_i + const \<br> = &amp;- x_i^TWW^Tx_i + const \<br>\end{array}<br>\end{equation}<br>并且<br>\begin{equation}<br>\begin{array}{r,l}<br>&amp; \sum_{i=1}^m-x_i^TWW^Tx_i  \<br>= &amp; \sum_{i=1}^mTr(-x_i^TWW^Tx_i) \<br>= &amp; \sum_{i=1}^mTr(-W^Tx_ix_i^TW) \<br>= &amp; Tr(\sum_{i=1}^m-W^Tx_ix_i^TW) \<br>= &amp; -Tr(W^TXX^TW)<br>\end{array}<br>\end{equation}</p><p>最终的形式为<br>\begin{equation}<br>\begin{array}{r,l}<br>\max_W &amp; Tr(W^TXX^TW) \<br>\text{s.t.} &amp; W^TW = I<br>\end{array}<br>\end{equation}<br>对上面问题使用Lagrange乘子法得到：<br>$$<br>L(W,\Lambda) = Tr(W^TXX^TW) + Tr(\Lambda (W^TW - I))<br>$$<br>对Lagrange函数关于$W$求导并令其等0得到：<br>$$<br>XX^TW = \Lambda W<br>$$<br>显然是一个特征值分解问题。</p><h2 id="最大投影方差"><a href="#最大投影方差" class="headerlink" title="最大投影方差"></a>最大投影方差</h2><h2 id="实际应用时的trick"><a href="#实际应用时的trick" class="headerlink" title="实际应用时的trick"></a>实际应用时的trick</h2><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KKT条件是怎么来的--约束优化问题的最优性条件</title>
      <link href="/2018/07/23/KKT%E6%9D%A1%E4%BB%B6--%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%80%E4%BC%98%E6%80%A7%E6%9D%A1%E4%BB%B6/"/>
      <url>/2018/07/23/KKT%E6%9D%A1%E4%BB%B6--%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%80%E4%BC%98%E6%80%A7%E6%9D%A1%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="KKT条件–约束优化问题的最优性条件"><a href="#KKT条件–约束优化问题的最优性条件" class="headerlink" title="KKT条件–约束优化问题的最优性条件"></a>KKT条件–约束优化问题的最优性条件</h1><p>&emsp;&emsp;对于一些问题，利用最优性条件，往往能够求出问题的解析解，所以优化问题的最优性条件是最优化理论的重要组成部分。KKT条件是带约束问题取得最优解的必要条件（目标函数和约束可微的条件下），在某些时候可变为充要条件。</p><p>&emsp;&emsp;首先介绍下什么是充分条件、必要条件和充要条件：</p><ul><li><strong>充分条件：</strong>若条件C为问题P在$x^{\ast}$取得极值的充分条件，那么我们能够利用条件C直接求出$x^{\ast}$，但并不意味着所有的极值点$x^{\ast}$都满足条件C</li><li><strong>必要条件：</strong>若条件C为问题P在$x^{\ast}$取得极值的必要条件，那么要想求出P的极值点$x^{\ast}$,极值点$x^{\ast}$必须满足C，但是满足条件C的点$x$却不一定是极值点</li><li><strong>充要条件：</strong>满足条件C的一定是极值点，极值点一定满足条件C</li></ul><p>&emsp;&emsp;本文要研究的问题的形式为：<br>\begin{equation}<br>\begin{array}{r,l}<br>\min &amp; \quad f(x), x\in R^n \<br>\text{s.t.} &amp; \quad c_i(x) = 0,i \in E=\left( 1,2,\cdots,l \right) \<br> &amp; \quad c_i{x} \geq 0, i \in I = \left( l+1,\cdots,m \right)<br>\end{array}<br>\end{equation}</p><p>即在有等式和不等式约束的条件下极小化一个目标函数，我们记 $D=\left( x \in R^n | c_i(x)=0 , i \in E;c_i(x)\geq 0, i\in I\right)$ 为问题的可行域，$g$为$f$的一阶梯度，$G$为$f$的二阶梯度，并且<strong>我们假设目标函数和约束函数都至少是一阶可微的。</strong></p><h2 id="无约束优化的最优性条件"><a href="#无约束优化的最优性条件" class="headerlink" title="无约束优化的最优性条件"></a>无约束优化的最优性条件</h2><p>&emsp;&emsp;其实从形式上看，带约束的优化问题与无约束优化问题的最优性条件挺相似的，所以首先看下无约束优化问题的最优性条件，即$$\min f(x),\quad x \in R^n$$在取得极值点的时候要满足哪些条件。</p><blockquote><p>定理1 一阶必要条件：若$x^{\ast}$为无约束优化问题的极小点，那么$g(x^{\ast})=0$</p></blockquote><hr><blockquote><p>定理2 二阶必要条件：若$x^{\ast}$为无约束优化问题的极小点，并且$f$二阶连续可微，那么$g(x^{\ast}=0),G(x^{\ast})\text{半正定}$</p></blockquote><p>举个一维函数例子：<br><img src="/2018/07/23/KKT条件--约束优化问题的最优性条件/2order-f.png" alt="2order-f"><br>&emsp;&emsp;$f_1(x)=x^2, f_2(x)=x^3$,他们的一阶梯度和二阶梯度分别是$g_1(x) = 2x, g_2(x) = 3x^2,G_1(x)=2,G_2(x) = 6x$,在$x=0$处，它们分别等于$g_1(0) = 0, g_2(0) = 0,G_1(0)=2,G_2(0) = 0$,对于$f_1(x)$，它在$x=0$处满足定理1和定理2，$f_2(x)$也满足定理1和定理2，但是它并不是极值点，所以定理1和定理2只是<strong>必要条件</strong>，下面给出一个充分条件。</p><blockquote><p>定理3，二阶充分条件：若$f$为二阶连续可微，并且$g(x^{\ast})=0,G(x^{\ast})$正定，则$x^{\ast}$是极小点。</p></blockquote><p>对于$f_2(x)$满足定理3，所以我们断言$f_1(x)$在$x=0$处取得极小点。</p><h2 id="等式约束的最优性条件"><a href="#等式约束的最优性条件" class="headerlink" title="等式约束的最优性条件"></a>等式约束的最优性条件</h2><p>&emsp;&emsp;对于等式问题：<br>\begin{equation}<br>\begin{array}{r,l}<br>\min &amp; \quad f(x), x\in R^n \<br>\text{s.t.} &amp; \quad c_i(x) = 0,i \in E=\left( 1,2,\cdots,l \right)<br>\end{array}<br>\end{equation}<br>的最优性条件有如下定理。</p><blockquote><p><strong>定理4，等式约束的KKT条件：</strong>若$x^{\ast}$为上述问题的局部极小点，并且$f(x)$和$c_i(x)$在$x^{\ast}$的某邻域内连续可微。若$\nabla c_i(x^{\ast}),i = 1,2,\cdots,l$线性无关，则存在一组实数$\lambda_1^{\ast},\lambda_2^{\ast},\cdots,\lambda_l^{\ast}$，使得$$\nabla f(x^{\ast}) = \sum_{i=1}^l \lambda_i^{\ast} \nabla c_i (x^{\ast})$$</p></blockquote><p><strong>证明：</strong>略。</p><p>此定理为等式约束问题取得最优解的一阶必要条件，令等式约束问题的Lagrange函数为<br>$$L(x,\lambda) = f(x) - \sum_{i=1}^{l} \lambda_i c_i (x),$$<br>此定理表明，等式约束问题的最优解和最优Lagrange乘子为Lagrange函数的驻点：</p><p>\begin{gather}<br>\begin{pmatrix}<br>\nabla_x L(x^{\ast},\lambda^{\ast}) \<br>\nabla_{\lambda} L(x^{\ast},\lambda^{\ast})<br>\end{pmatrix} = 0<br>\end{gather}</p><h2 id="不等式约束问题的最优性条件"><a href="#不等式约束问题的最优性条件" class="headerlink" title="不等式约束问题的最优性条件"></a>不等式约束问题的最优性条件</h2><p>对于不等式约束问题<br>$$<br>\begin{equation}<br>\begin{array}{r,l}<br>\min &amp; \quad f(x), x\in R^n \<br>\text{s.t.} &amp; \quad c_i(x) \geq 0, i \in I = \left( l+1,\cdots,m \right)<br>\end{array}<br>\end{equation}<br>$$<br>首先来看三个引理。</p><h3 id="三个引理"><a href="#三个引理" class="headerlink" title="三个引理"></a>三个引理</h3><blockquote><p><strong>引理1，Fakas引理：</strong>设$a_1,a_2,\cdots,a_r,b$为n维向量。所有满足$a_i^Td&gt;0,i = 1,2,\cdots,r$的向量d，同时满足$b^Td&gt;0$的充要条件是存在非负实数$\lambda_1,\lambda_2,\cdots,\lambda_r$使得$b = \sum_{i=1}^r \lambda_i a_i.$</p></blockquote><p><strong>证明：</strong>略。<br>&emsp;&emsp;可以这样理解这个引理，$d$与所有的向量$a_i$成锐角，所有的$d$生成了一个多面锥，向量b若要与这样的一个d也成锐角，那么b应该在由向量$a_i$生成的凸锥包中。</p><blockquote><p><strong>引理2，Gordan引理：</strong>设$a_1,a_2,\cdots,a_r$为n为向量，则不存在向量$d\in R^n$使得<br>$$a_i^Td&lt;0,i = 1,2,\cdots,r$$<br>的充要条件是，存在不全为0的非负实数组$\lambda_i,i= 1,2,\cdots,r$使得<br>$$\sum_{i=1}^r \lambda_i a_i = 0.$$</p></blockquote><p><strong>证明：</strong> 略，需要用到Fakas引理。<br>&emsp;&emsp;这个定理的几何意义是：假设在一个平面内，如果把$a_i$看成力的话，不存在$d$,使得$a_i^T d&lt;0$表明所有力的方向不可能都在一个180度内，那么总是可以适当对每个力进行放缩，使得合力为0.</p><p>给出一个有效约束的概念。<br><strong>有效约束：</strong>对于所有的不等式约束，$\hat{x}$的有效约束是指那些在$\hat{x}$的某邻域内使得 $c_i(\hat{x}) = 0 $ 的约束，也就是说对于某些约束，$\hat{x}$已经走到了边界上，这些约束对$\hat{x}$起了作用，而那些$c_i(\hat{x})&gt;0$的约束，$\hat{x}$还在内部，暂时还没起约束作用。<br><strong>有效集：</strong>所有在$\hat{x}$处的有效约束的下标组成的集合<br>$$I(\hat{x}) = \lbrace  i | c_i(\hat{x}) = 0\rbrace.$$</p><blockquote><p><strong>引理3：</strong> 对于不等式约束优化问题，$x^{\ast}$为优化问题的局部极小点，$I^{\ast} = \lbrace  i | c_i{x^{\ast}} = 0,i=1,2,\cdots,m \rbrace$,若$f(x)$和$c_i(x_i)(i \in I^{\ast})$在点$x^{\ast}$可微，且 $ c_i(x),(i \in I/ I^{\ast}) $在点$x^{\ast}$连续，则在点$x^{\ast}$的下降方向集S与可行方向集G的交集是空集。$S = \lbrace p\in R^n | \nabla f(x^{\ast})^Tp &lt;0\rbrace,$ $ G = \lbrace p\in R^n | \nabla c_i(x^{\ast})^Tp &gt;0, i \in I^{\ast} \rbrace$</p></blockquote><p><strong>证明：反证法。</strong>假设存在一个向量$p \in S \cap G,$ 即$p$既是下降方向，又是可行方向，那么存在一个$\epsilon$使得$f(x^{\ast}+\epsilon p)&lt;f(x^{\ast})$,与$x^{\ast}$为局部极小点矛盾。</p><h3 id="Fritz-John一阶必要性条件"><a href="#Fritz-John一阶必要性条件" class="headerlink" title="Fritz-John一阶必要性条件"></a>Fritz-John一阶必要性条件</h3><blockquote><p><strong>定理5，Fritz-John一阶必要性条件：</strong>设$x^{\ast}$为不等式约束优化问题的局部极小点，且$f(x),c_i(x)$在$x^{\ast}$点可微，则存在不全为0非零实数$\lambda_0^{\ast},\lambda_1^{\ast},\cdots,\lambda_m^{\ast}$使得<br>\begin{equation}<br>\begin{cases}<br>\lambda_0^{\ast} \nabla f(x^{\ast}) - \sum_{i=1}^m \lambda_i^{\ast} \nabla c_i(x^{\ast}) = 0, \<br>\lambda_i^{\ast} c_i(x^{\ast}) = 0,\quad \lambda_i^{\ast} \geq 0,i = 0,1,\cdots,m<br>\end{cases}<br>\end{equation}</p></blockquote><p><strong>证明：</strong> 设$x^{\ast}$处的有效集为$I^{\ast}$,由引理5知，不存在$d \in R^n,$使得$$ \nabla f(x^{\ast})^Td &lt;0, \quad -\nabla c_i(x^{\ast})^Td &lt;0, i \in I^{\ast},$$再由Gordan引理可得，存在不全为0非零实数$\lambda_0^{\ast},\lambda_i^{\ast},i \in I^{\ast}$使得$\lambda_0^{\ast} \nabla f(x^{\ast}) - \sum_{i \in I^{\ast}} \lambda_i^{\ast} \nabla c_i(x^{\ast}) = 0,$ 另外，规定$i \in I/I^{\ast}$时，$\lambda_i^{\ast}=0, $则得到定理结论。</p><h3 id="KKT一阶必要性条件"><a href="#KKT一阶必要性条件" class="headerlink" title="KKT一阶必要性条件"></a>KKT一阶必要性条件</h3><p>&emsp;&emsp;Fritz-john一阶必要条件有一个缺点，就是当$\lambda_0^{\ast}= 0 $时，目标函数的梯度将从等式中消失，所以需要加一些条件使得目标函数的梯度前面的系数不为0，这样就得到了不等式约束优化问题的KT条件。</p><blockquote><p><strong>定理6，不等式约束的KKT条件：</strong>设$x^{\ast}$为不等式约束优化问题的局部极小点，且$f(x),c_i(x)$在$x^{\ast}$点可微，有效集为$I^{\ast}$, 若$\nabla c_i(x^{\ast})(i \in I^{\ast})$线性无关，则存在不全为0非零实数$\lambda_1^{\ast},\cdots,\lambda_m^{\ast}$使得<br>\begin{equation}<br>\begin{cases}<br>\nabla f(x^{\ast}) - \sum_{i=1}^m \lambda_i^{\ast} \nabla c_i(x^{\ast}) = 0, \<br>\lambda_i^{\ast} c_i(x^{\ast}) = 0,\quad \lambda_i^{\ast} \geq 0,i = 1,\cdots,m<br>\end{cases}<br>\end{equation}</p></blockquote><p><strong>证明：</strong>由Gordan引理，存在不全为0的非负数$\mu_0,\mu_i,i \in I^{\ast}$使得<br>$$\mu_0^{\ast} \nabla f(x^{\ast}) - \sum_{i \in I^{\ast}} \mu_i^{\ast} \nabla c_i(x^{\ast}) = 0,$$<br>若$\mu_0^{\ast}=0,$则$\sum_{i \in I^{\ast}} \mu_i^{\ast} \nabla c_i(x^{\ast}) = 0,$与$\nabla c_i(x^{\ast})(i \in I^{\ast})$线性无关矛盾。故上式两边同时除以$\mu_0^{\ast}$可得结论。</p><h2 id="一般约束问题的最优性条件"><a href="#一般约束问题的最优性条件" class="headerlink" title="一般约束问题的最优性条件"></a>一般约束问题的最优性条件</h2><p>&emsp;&emsp;结合等式约束与不等式约束优化问题的KT条件很容易得到一般约束优化问题的最优性条件。</p><blockquote><p><strong>KKT条件</strong><br>\begin{equation}<br>\begin{cases}<br>\nabla f(x^{\ast}) - \sum_{i \in I} \lambda_i^{\ast} \nabla c_i(x^{\ast}) - \sum_{i \in E}\mu_i^{\ast} \nabla c_i(x^{\ast})= 0, \<br>\lambda_i^{\ast} c_i(x^{\ast}) = 0,c_i(x^{\ast}) \geq 0, \lambda_i^{\ast} \geq 0,\quad i \in I \<br>c_i(x^{\ast})=0,\quad i\in E<br>\end{cases}<br>\end{equation}</p></blockquote><p>$\lambda_i^{\ast} c_i(x^{\ast}) = 0, (i \in I)$又叫做互补松弛条件。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] 倪勤，最优化方法与程序设计</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《推荐系统实践》读书笔记</title>
      <link href="/2018/07/18/%E3%80%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/18/%E3%80%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="《推荐系统实践》读书笔记"><a href="#《推荐系统实践》读书笔记" class="headerlink" title="《推荐系统实践》读书笔记"></a>《推荐系统实践》读书笔记</h1><h2 id="第一章，好的推荐系统"><a href="#第一章，好的推荐系统" class="headerlink" title="第一章，好的推荐系统"></a>第一章，好的推荐系统</h2><h3 id="评价推荐系统好坏的指标"><a href="#评价推荐系统好坏的指标" class="headerlink" title="评价推荐系统好坏的指标"></a>评价推荐系统好坏的指标</h3><ol><li>用户的满意度</li><li>准确率和召回率</li><li>覆盖率。覆盖率描述的是一个模型能够挖掘长尾数据的能力，一般定义为推荐商品的种类比上所有商品的类别，还可以用信息熵和基尼指数来定义。若覆盖率较低，则出现了马太效应，也就是说一个物品越流行，越容易被推荐，越被推荐，它的流行度就越高。</li><li>多样性。多样性描述了推荐列表中物品两两之间的不相似性。推荐给用户u的商品列表R(u)的多样性定义为：<br>$$\text{Diversity} = 1-\frac{\sum_{i,j \in R(u),i\neq j}s(i,j)}{\frac{1}{2}|R(u)|(|R(u) | - 1)},$$推荐系统的整体多样性定义为多有用户推荐列表多样性的平均。</li><li>新颖性和惊喜性</li><li>信任性</li><li>实时性</li><li>鲁棒性。一些商家可能为了推广自己的商品，利用推荐系统的漏洞，使得推荐系统推荐自家商品的概率变大，推荐系统应该能识别出这种行为。</li></ol><h2 id="第二章，利用用户行为数据"><a href="#第二章，利用用户行为数据" class="headerlink" title="第二章，利用用户行为数据"></a>第二章，利用用户行为数据</h2><h3 id="用户行为数据简介"><a href="#用户行为数据简介" class="headerlink" title="用户行为数据简介"></a>用户行为数据简介</h3><p>用户的行为数据有<strong>显性反馈行为</strong>（主动打分）和<strong>隐性反馈行为</strong>（浏览商品留下的痕迹）</p><h3 id="用户行为分析"><a href="#用户行为分析" class="headerlink" title="用户行为分析"></a>用户行为分析</h3><h4 id="用户活跃度和物品流行度的分布"><a href="#用户活跃度和物品流行度的分布" class="headerlink" title="用户活跃度和物品流行度的分布"></a>用户活跃度和物品流行度的分布</h4><p>研究发现，互联网中的数据，很多都呈现<strong>长尾数据分布</strong>，具体来说就是，热门商品的数量在所有商品数量中是少数的，活跃用户在所有用户中是少数的。<br><strong>长尾数据分布:</strong><br>$$f(x) = \alpha x^k,$$<br>两边同时取对数，画在坐标轴上接近线性。</p><h4 id="用户活跃度和物品流行度的关系"><a href="#用户活跃度和物品流行度的关系" class="headerlink" title="用户活跃度和物品流行度的关系"></a>用户活跃度和物品流行度的关系</h4><p>一般新用户倾向于浏览热门的物品，因为他们对网站还不熟悉，只能点击首页的热门物品，而老用户会逐渐开始浏览冷门的物品。</p><h3 id="基于用户的协同过滤算法（UserCF）"><a href="#基于用户的协同过滤算法（UserCF）" class="headerlink" title="基于用户的协同过滤算法（UserCF）"></a>基于用户的协同过滤算法（UserCF）</h3><p>基于用户的协同过滤算法主要包括两个步骤。</p><ol><li>找到和目标用户兴趣相似的用户集合。</li><li>找到这个集合中的用户喜欢的，且目标用户没有用过的物品推荐给目标用户。</li></ol><p>N(u)和N(v)分别表示用户u和v有过正反馈的物品集合，用户兴趣相似度的计算：</p><ol><li><strong>Jaccard公式：</strong>$$w_{uv} = \frac{|N(u) \cap N(v) |}{|N(u) \cup N(v) |}$$</li><li><strong>余弦相似度：</strong>$$w_{uv} = \frac{|N(u) \cap N(v) |}{\sqrt{|N(u)| | N(v) |}}$$</li></ol><p>此算法需要维护一个用户相似度矩阵W，为计算用户之间的相似度，首先需要建立物品—用户的倒排表，然后扫描每个物品中的用户，若两用户u，v同时出现在一个物品中，则两用户相似矩阵$W[u][v]+=1,W[v][u]+=1.$<br><img src="/2018/07/18/《推荐系统实践》读书笔记/物品用户倒排表.png" alt="物品用户倒排表"><br>得到用户之间的兴趣相似度后，UserCF算法会给用户推荐和他兴趣最相似的K个用户喜欢的物品。如下的公式度量了UserCF算法中用户u对物品i的感兴趣程度：<br>$$p(u,i) = \sum_{v\in S(u,K) \cap N(i)} w_{u,v}r_{vi}.$$<br>其中， S(u, K)包含和用户u兴趣最接近的K个用户，N(i)是对物品i有过行为的用户集合， $w_{uv}$是用户u和用户v的兴趣相似度，rvi代表用户v对物品i的兴趣，因为使用的是单一行为的隐反馈数据，所以所有的rvi=1。</p><h4 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h4><ul><li><strong>准确率和召回率：</strong>推荐系统的准确率和召回率并不和K成正比，K是选择多少相似用户</li><li><strong>流行度：</strong> K越大UserCF推荐结果越热门</li><li><strong>覆盖率：</strong> K越大，覆盖率越低</li></ul><h4 id="用户相似度计算的改进"><a href="#用户相似度计算的改进" class="headerlink" title="用户相似度计算的改进"></a>用户相似度计算的改进</h4><p>上面用余弦计算用户相似度，这个公式有点粗糙，因为对于热门商品，很多人都可能购买，但并不能说明他们相似，相反，对于冷门物品如果他们都购买了，这个更能说明他们兴趣的相似性。因此，使用下式来计算用户兴趣相似度：<br>$$w_{uv} = \frac{\sum_{i\in N(u)\cap N(v)} \frac{1}{\log(1+| N(i) |)}}{\sqrt{|N(u)| | N(v) |}},$$ $\frac{1}{\log(1+| N(i) |}$惩罚了用户u和用户v共同兴趣列表中热门物品对他们相似度的影响。</p><h3 id="基于物品的协同过滤算法（ItemCF）"><a href="#基于物品的协同过滤算法（ItemCF）" class="headerlink" title="基于物品的协同过滤算法（ItemCF）"></a>基于物品的协同过滤算法（ItemCF）</h3><p>基于用户的协同过滤算法在一些网站中得到了应用，但该算法有一些缺点。<strong>首先</strong>，随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空间复杂度的增长和用户数的增长近似于平方关系。<strong>其次</strong>，基于用户的协同过滤很难对推荐结果作出解释。</p><p>基于物品的协同过滤算法也主要有两步：</p><ol><li>计算物品之间的相似度。</li><li>根据物品的相似度和用户的历史购买物品给用户生成推荐列表。</li></ol><p>物品相似性度量公式：$$w_{ij} = \frac{|N(i) \cap N(j) |}{\sqrt{|N(i)| | N(j) |}},$$<br>$|N(i)|$是喜欢物品$i$的用户数。这里面蕴涵着一个假设，就是每个用户的兴趣都局限在某几个方面，因此如果两个物品属于一个用户的兴趣列表，那么这两个物品可能就属于有限的几个领域，而如果两个物品属于很多用户的兴趣列表，那么它们就可能属于同一个领域，因而有很大的相似度。</p><p>和UserCF算法类似，ItemCF算法需要维护一个物品相似性矩阵，用ItemCF算法计算物品相似度时也可以<strong>首先</strong>建立用户—物品倒排表（即对每个用户建立一个包含他喜欢的物品的列表），<strong>然后</strong>对于每个用户，将他物品列表中的物品两两在共现矩阵C中加1。<br><img src="/2018/07/18/《推荐系统实践》读书笔记/物品相似性计算.png" alt="物品相似性计算"></p><p>在得到物品之间的相似度后，ItemCF通过如下公式计算用户u对一个物品j的兴趣：<br>$$p_{uj} = \sum_{i\in N(u)\cap S(j,K)} w_{ji}r_{ui},$$<br>N(u)是用户喜欢的物品的集合， S(j,K)是和物品j最相似的K个物品的集合， wji是物品j和i的相似度， rui是用户u对物品i的兴趣。</p><h4 id="物品相似度计算的改进"><a href="#物品相似度计算的改进" class="headerlink" title="物品相似度计算的改进"></a>物品相似度计算的改进</h4><p>$$w_{ij} = \frac{\sum_{u\in N(i)\cap N(j)} \frac{1}{\log(1+| N(u) |)}}{\sqrt{|N(i)| | N(j) |}},$$</p><h4 id="物品相似度归一化"><a href="#物品相似度归一化" class="headerlink" title="物品相似度归一化"></a>物品相似度归一化</h4><p>Karypis在研究中发现如果将ItemCF的相似度矩阵按最大值归一化，可以提高推荐的准确率。假设物品相似度矩阵为$W$，那么可以用如下公式得到归一化之后的相似度矩阵$W’$：$$w_{ij}’ = \frac{w_{ij}}{\max_{j}w_{ij}},.$$<br>一般来说，热门的类其类内物品相似度一般比较大。如果不进行归一化，就会推荐比较热门的类里面的物品，而这些物品也是比较热门的。因此，推荐的覆盖率就比较低。</p><h3 id="UserCF-和-ItemCF-的比较"><a href="#UserCF-和-ItemCF-的比较" class="headerlink" title="UserCF 和 ItemCF 的比较"></a>UserCF 和 ItemCF 的比较</h3><ol><li>UserCF给用户推荐那些和他有共同兴趣爱好的用户喜欢的物品，而ItemCF给用户推荐那些和他之前喜欢的物品类似的物品。从这个算法的原理可以看到，UserCF的推荐结果着重于反映和用户兴趣相似的小群体的热点，而ItemCF的推荐结果着重于维系用户的历史兴趣。换句话说，UserCF的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而ItemCF的推荐更加个性化，反映了用户自己的兴趣。</li><li>UserCF适合用于新闻推荐</li><li>ItemCF适用于图书、电子商务和电影网站</li></ol><h3 id="隐语义模型"><a href="#隐语义模型" class="headerlink" title="隐语义模型"></a>隐语义模型</h3><p>隐语义模型的核心思想是通过隐含特征(latent factor)联系用户兴趣和物品。我们可以从另一个角度考虑如何给用户推荐商品，对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品。这个基于兴趣分类的方法需要解决3个问题：</p><ol><li>如何给<strong>物品进行分类</strong>？</li><li>如何确定<strong>用户对哪些类的物品感兴趣</strong>，以及感兴趣的程度？</li><li>对于一个给定的类，选择哪些属于这个类的物品推荐给用户，以及如何<strong>确定这些物品在一个类中的权重</strong>？</li></ol><p>隐含语义分析技术采取基于用户行为统计的自动聚类，较好地解决了上面提出的几个问题。LFM通过如下公式计算用户u对物品i的兴趣：<br>$$\text{Preference(u,i)} = r_{ui} = p_u^Tq_i = \sum_{k=1}^K p_{uk}q_{ik},$$<br>$p_{uk} $度量了用户u的兴趣和第k个隐类的关系，$q_{ik}$度量了第k个隐类和物品i之间的关系。</p><h4 id="负样本采样"><a href="#负样本采样" class="headerlink" title="负样本采样"></a>负样本采样</h4><p>原则：</p><ol><li>对每个用户，要保证正负样本的平衡（数目相似）。</li><li>对每个用户采样负样本时，要选取那些很热门，而用户却没有行为的物品。一般认为，很热门而用户却没有行为更加代表用户对这个物品不感兴趣。因为对于冷门的物品，用户可能是压根没在网站中发现这个物品，所以谈不上是否感兴趣。</li></ol><h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><p>$$\min_{p_u,q_i} \sum_{(u,i)\in K} \left(r_{ui} - \sum_{k=1}^K p_{uk}q_{ik}\right)^2 + \lambda (|p_u|^2+| q_i |^2),$$<br>其中，$K$为经过采样后得到的用户-物品集，第一项为拟合项，第二项为正则项。</p><h4 id="LFM和基于邻域的方法的比较"><a href="#LFM和基于邻域的方法的比较" class="headerlink" title="LFM和基于邻域的方法的比较"></a>LFM和基于邻域的方法的比较</h4><p>UserCF和ItemCF都是基于邻域的方法，可从以下方面比较与LFM的异同。</p><ol><li><strong>理论基础：</strong> LFM具有较好的理论基础，是一种机器学习方法，而基于邻域的方法是一种统计方法。</li><li><strong>离线计算的空间复杂度：</strong>基于领域的方法需要维护一张用户相关表或者物品相关表，需要较大的存储空间。</li><li><strong>离线计算的时间复杂度：</strong>差不多。</li><li><strong>在线实时推荐：</strong>一旦用户有了新的喜欢物品，ItemCF可以通过查询与此物品相关的其他商品推荐给用户，而LFM则需要计算用户对所有物品的兴趣权重，然后排名，返回权重最大的N个物品，在物品数很多时，这一过程的时间<br>复杂度非常高。</li><li><strong>解释性：</strong> ItemCF有很好的解释性，LFM则没有。</li></ol><h2 id="第三章，推荐系统冷启动问题"><a href="#第三章，推荐系统冷启动问题" class="headerlink" title="第三章，推荐系统冷启动问题"></a>第三章，推荐系统冷启动问题</h2><h3 id="冷启动问题简介"><a href="#冷启动问题简介" class="headerlink" title="冷启动问题简介"></a>冷启动问题简介</h3><p>主要分为3类：</p><ol><li>用户冷启动</li><li>物品冷启动</li><li>系统冷启动</li></ol><p>一般有如下解决方案：</p><ol><li>提供非个性化推荐，比如推荐排行榜</li><li>利用用户注册时提供的年龄、性别等信息</li><li>利用用户的社交网络账号</li><li>要求用户注册时对一些物品进行反馈，收集用户对这些物品的兴趣</li><li><strong>物品冷启动</strong>,对新加入的物品可利用物品的内容信息，可能需要用到文本分析的技术</li><li><strong>系统冷启动，</strong>可引入专家知识</li></ol><h3 id="利用用户注册信息"><a href="#利用用户注册信息" class="headerlink" title="利用用户注册信息"></a>利用用户注册信息</h3><p>基于用户注册信息的推荐算法其核心问题是计算每种特征的用户喜欢的物品。也就是说，对于每种特征$f$，计算具有这种特征的用户对各个物品的喜好程度$p(f, i)$。 $p(f,i)$ 可以简单地定义为物品$i$在具有f的特征的用户中的热门程度：<br>$$p(f,i) = | N(i) \cap U(f)|,$$其中$N(i)$是喜欢物品$i$的用户集合，$U(f)$是具有特征$f$的用户集合。在这种定义下，往往热门的物品会在各种特征的用户中都具有比较高的权重。因此，我们可以将 p(f,i)定义为喜欢物品$i$的用户中具有特征f的比例：<br>$$p(f,i) = \frac{| N(i) \cap U(f)|}{| N(i) | + \alpha},$$<br>参数$\alpha$的目的是解决数据稀疏问题。</p><h3 id="选择合适的物品启动用户的兴趣"><a href="#选择合适的物品启动用户的兴趣" class="headerlink" title="选择合适的物品启动用户的兴趣"></a>选择合适的物品启动用户的兴趣</h3><p>解决用户冷启动问题的另一个方法是在新用户第一次访问推荐系统时，不立即给用户展示推荐结果，而是给用户提供一些物品，让用户反馈他们对这些物品的兴趣，然后根据用户反馈给提供个性化推荐。</p><p>需要选择启动用户兴趣的物品应具有以下特征：</p><ol><li>比较热门的商品</li><li>具有代表性和区分性</li><li>启动物品集合需要有多样性</li></ol><p>一般可以使用决策树算法构建一个这样的选择启动物品集合的系统。给定一群用户，用这群用户对物品评分的方差度量这群用户兴趣的一致程度。如果方差很大，说明这一群用户的兴趣不太一致，反之则说明这群用户的兴趣比较一致。通过如下方式度量一个物品的区分度$D(i):$<br>$$D(i) = \delta_{u \in N^+(i)} + \delta_{u \in N^-(i)}+\delta_{u \in \bar{N}(i)},$$三项分别还是喜欢、不喜欢、不知道商品i的用户对其他物品评分的方差。决策树算法首先会从所有用户中找到具有最高区分度的物品i，然后将用户分成3类。然后在每类用户中再找到最具区分度的物品，然后将每一类用户又各自分为3类，也就是将总用户分成9类，然后这样继续下去，最终可以通过对一系列物品的看法将用户进行分类。而在冷启动时，我们从根节点开始询问用户对该节点物品的看法，然后根据用户的选择将用户放到不同的分枝，直到进入最后的叶子节点，此时我们就已经对用户的兴趣有了比较清楚的了解，从而可以开始对用户进行比较准确地个性化推荐。</p><h3 id="利用物品的内容信息"><a href="#利用物品的内容信息" class="headerlink" title="利用物品的内容信息"></a>利用物品的内容信息</h3><p>对于物品的冷启动呢问题，一般是利用物品的文本信息，计算物品的词向量，然后根据词向量计算物品的相似性，将其加入相似性矩阵。</p><h3 id="发挥专家的作用"><a href="#发挥专家的作用" class="headerlink" title="发挥专家的作用"></a>发挥专家的作用</h3><p>针对系统冷启动问题，一般使用专家进行样本标注。</p><h2 id="第四章，利用用户标签数据"><a href="#第四章，利用用户标签数据" class="headerlink" title="第四章，利用用户标签数据"></a>第四章，利用用户标签数据</h2><p>标签应用一般分为两种：一种是让作者或者专家给物品打标签；另一种是让普通用户给物品打标签，也就是UGC,书中用到的是UGC。当一个用户对一个物品打上一个标签，这个标签一方面描述了用户的兴趣，另一方面则表示了物品的语义，从而将用户和物品联系了起来。</p><h3 id="标签系统中的推荐问题"><a href="#标签系统中的推荐问题" class="headerlink" title="标签系统中的推荐问题"></a>标签系统中的推荐问题</h3><p>两个：</p><ol><li>利用用户的标签为其推荐物品</li><li>用户给物品打标签时，如何给用户推荐标签</li></ol><h4 id="用户为什么打标签"><a href="#用户为什么打标签" class="headerlink" title="用户为什么打标签"></a>用户为什么打标签</h4><p>两个维度：社会维度，便于其他人找到信息；功能维度，方便自己将来查找。</p><h4 id="用户打标签的分布"><a href="#用户打标签的分布" class="headerlink" title="用户打标签的分布"></a>用户打标签的分布</h4><p>标签的流行度：用户在物品上打这个标签的次数。</p><p>标签的流行度分布也呈现非常典型的长尾分布。</p><h4 id="用户打标签的类型"><a href="#用户打标签的类型" class="headerlink" title="用户打标签的类型"></a>用户打标签的类型</h4><ul><li>表明物品是什么</li><li>表明物品的种类</li><li>表明谁拥有物品    </li><li>表达用户的观点</li><li>用户相关的标签</li><li>用户的任务</li></ul><h3 id="基于标签的推荐系统"><a href="#基于标签的推荐系统" class="headerlink" title="基于标签的推荐系统"></a>基于标签的推荐系统</h3><p>$(u,i,b)$表示用户u给物品i打上标签b。</p><p>一个简单的基于标签的推荐算法：</p><ol><li>统计每个用户最常用的标签。</li><li>对于每个标签，统计被打过这个标签次数最多的物品。</li><li>对于一个用户，首先找到他常用的标签，然后找到具有这些标签的最热门物品推荐给这个用户。<br>那么用户u对物品i的兴趣公式为：<br>$$p(u,i) = \sum_b n_{u,b}n_{b,i}$$</li></ol><h4 id="算法的改进"><a href="#算法的改进" class="headerlink" title="算法的改进"></a>算法的改进</h4><p>上述的公式倾向于给热门标签对应的热门物品很大的权重，因此会造成推荐热门的物品给用户，从而降低推荐结果的新颖性。并且，给热门标签过大的权重，从而不能反应用户个性化的兴趣。书中借鉴了TF-IDF的思想，将公式改进为<br>$$p(u,i) = \sum_b \frac{n_{u,b}}{\log(1+n_b^{u})}n_{b,i},$$<br>$n_b^{u}$为标签b被多少不同的用户使用过。同时，也可以对热门物品进行惩罚：<br>$$p(u,i) = \sum_b \frac{n_{u,b}}{\log(1+n_b^{u})}\frac{n_{b,i}}{\log(1+n_i^u)}$$</p><h4 id="数据稀疏性"><a href="#数据稀疏性" class="headerlink" title="数据稀疏性"></a>数据稀疏性</h4><p>对于新用户或者新物品$B(u)\cap B(i)$中的标签会很少，为了提高推荐的准确率，我们可能要对标签集合做扩展，比如若用户曾经用过“推荐系统”这个标签，我们可以将这个标签的相似标签也加入到用户标签集合中，比如“个性化”、“协同过滤”等标签。标签扩展的本质是对每个标签找到和它相似的标签，也就是计算标签之间的相似度。</p><h4 id="标签清理"><a href="#标签清理" class="headerlink" title="标签清理"></a>标签清理</h4><p>不是所有的标签都能反应用户的兴趣，要将这一部分标签清理掉。</p><h3 id="给用户推荐标签"><a href="#给用户推荐标签" class="headerlink" title="给用户推荐标签"></a>给用户推荐标签</h3><ol><li>给用户u推荐物品i上最热门的标签</li><li>给用户u推荐他自己经常使用的标签</li><li>融合前两种方法，该方法通过一个系数将上面的推荐结果线性加权，然后生成最终的推荐结果。</li></ol><h2 id="第五章，利用上下文信息"><a href="#第五章，利用上下文信息" class="headerlink" title="第五章，利用上下文信息"></a>第五章，利用上下文信息</h2><h3 id="时间上下文信息"><a href="#时间上下文信息" class="headerlink" title="时间上下文信息"></a>时间上下文信息</h3><h4 id="时间效应简介"><a href="#时间效应简介" class="headerlink" title="时间效应简介"></a>时间效应简介</h4><ol><li>用户兴趣随时间是变化的</li><li>物品有生命周期</li><li>季节效应</li></ol><h3 id="时间上下文相关的ItemCF算法"><a href="#时间上下文相关的ItemCF算法" class="headerlink" title="时间上下文相关的ItemCF算法"></a>时间上下文相关的ItemCF算法</h3><p>ItemCF由两部分构成：计算物品间的相似性，利用用户历史行为和物品相似性给用户推荐商品，加入时间上下文信息后，可以对这两部分做出改进。<br>加入时间信息后的<strong>物品相似性度量：</strong><br>$$\text{sim}(i,j) = \frac{\sum_{u \in N(j) \cap N(i)}f\left( | t_{ui} - t_{uj}|\right)}{\sqrt{|N(i)| |N(j)|}}$$<br>其中f为衰减函数：<br>$$f\left( | t_{ui} - t_{uj}|\right) = \frac{1}{1+\alpha |t_{ui} - t_{uj}|},$$$\alpha$是时间衰减参数，它的取值在不同系统中不同。相应的，<strong>用户u对物品i的兴趣为</strong><br>$$p(u,i) = \sum_{j \in N(u)\cap S(i,K)} \frac{\text{sim}(i,j)}{1+\beta |t_0 - t_{uj}|}$$</p><h3 id="时间上下文的UserCF算法"><a href="#时间上下文的UserCF算法" class="headerlink" title="时间上下文的UserCF算法"></a>时间上下文的UserCF算法</h3><p>与时间上下文的ITemCF算法类似，UserCF算法需要改进的也有两方面：用户相似性度量的计算改进和用户对物品兴趣计算的改进。<br><strong>用户相似性度量：</strong><br>$$w_{uv}\frac{\sum_{i \in N(u) \cap N(v)}\frac{1}{1+\alpha |t_{ui} - t_{vi}|}}{\sqrt{|N(u)| |N(v)|}},$$<br>上面公式的分子对于用户u和用户v共同喜欢的物品i增加了一个时间衰减因子。用户u和用户v对物品i产生行为的时间越远，那么这两个用户的兴趣相似度就会越小。<br><strong>用户对物品的兴趣：</strong><br>$$p(u,i) = \sum_{v \in S(u,K)} w_{uv}r_{vi}$$<br>或者<br>$$p(u,i) = \sum_{v \in S(u,K)} w_{uv}r_{vi} \frac{1}{1+\alpha (t_0 - t_{vi})}$$</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种常见的无约束优化算法</title>
      <link href="/2018/07/11/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/11/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="几种常见的无约束优化问题算法"><a href="#几种常见的无约束优化问题算法" class="headerlink" title="几种常见的无约束优化问题算法"></a>几种常见的无约束优化问题算法</h1><p>本文介绍几种求解无约束优化问题的基础算法，我们要求解如下形式的问题<br>$$<br>\min f(x),\quad x\in R^n,<br>$$<br>$f(x)$至少一阶可微。本文只介绍每个算法的基本步骤与推导形式，对于一些结论不作证明。我们一般采用基于迭代的方法来求解一个问题的极小值，即，开始确定一个初始点$x_0,$然后基于前一步的结果确定下一步的解：<br>$$x_{k+1} = x_{x} + \alpha_k d_k,$$其中$\alpha_k$叫做步长，一般通过精确或非精确的线搜索得到，$d_k$为搜索方向,$\alpha_k d_k$叫做位移。$d_k$和$\alpha_k$的不同确定方法，就产生了各种各样的迭代算法。在下文中我们约定$g_k = \nabla_{x_k}f,G_k = \nabla_{x_k}^2f.$</p><h2 id="梯度下降法（最速下降法）"><a href="#梯度下降法（最速下降法）" class="headerlink" title="梯度下降法（最速下降法）"></a>梯度下降法（最速下降法）</h2><p>梯度下降法的思想很朴素，以负梯度方向作为搜索方向。假设$f(x)$在$x_k$一阶可微，我们可以得到 $$f(x_k + \alpha d) = f(x_k)+\alpha g_k^Td + o(\alpha),$$<br>那么$$f(x_k + \alpha d) - f(x_k) = \alpha g_k^Td + o(\alpha).$$<br>假设$|d|=1,\cos\theta = \frac{-g_kTd}{|g_k||d|} = \frac{-g_kTd}{|g|},$ 那么$g_kTd = -|g_k| \cos\theta,$ 当$\cos\theta=1,\theta=\frac{\pi}{2}$时，$g_kTd$取最小值，$f$在$x_k$下降的最快，此时$d=-g_k,$所以每一步$d$取负梯度方向，在当前的迭代点，目标函数是下降的最快的，所以梯度下降法也叫做最速下降法。</p><p><strong>梯度下降法</strong><br>:  </p><ol><li>给定初始点$x_0$,误差$\epsilon$</li><li>若$| - g_k|&lt;\epsilon$停止迭代 ，否则，令$d_k = - g_k$</li><li>$\alpha_k = \arg\min f(x_k + \alpha d_k)$</li><li>$x_{k+1} = x_k + \alpha_k d_k$</li></ol><p>虽然梯度下降法每一步都选择下降最快的方向作为搜索方向，但它是一种贪婪算法，从全局来看收敛速度并不快，它是一阶收敛的。</p><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p>牛顿法的基本思想是在当前迭代点二阶近似目标函数，即目标函数在迭代点二阶泰勒展开得到：<br>$$<br>\phi_k(d) = f(x_k+d) \approx f(x_k)+g_k^T d+\frac{1}{2}d^TG_kd<br>$$<br>求解<br>$$<br>\min_{d \in R^n} \phi_k(d)<br>$$<br>假设G正定，得到<br>$$<br>d = -G_k^{-1}g_k<br>$$<br>我们称$-G_k^{-1}g_k$为当前迭代点的牛顿方向，若$G_k$不可逆，$d$由$$G_kd =-g_k $$解出。我们便可得到牛顿法的迭代步骤：</p><p><strong>牛顿法</strong><br>:  </p><ol><li>给定初始点$x_0$,误差$\epsilon$</li><li>若$| - g_k|&lt;\epsilon$停止迭代 ，否则，令$d_k = -G_k^{-1}g_k$</li><li>$x_{k+1} = x_k + d_k$</li></ol><p>牛顿法有比梯度下降法更快的收敛速度，它是局部二阶收敛的，也就是说它的收敛性依赖于初始点的选取，而梯度下降法具有整体收敛性。虽然有更快的收敛速率，但正如我们上面所看到的，牛顿法每一步迭代都需要求解一次线性方程组，因此牛顿法的计算量是相当大的。为了发挥出牛顿法二阶收敛的特性，后来提出了一些修正的牛顿法，比如，阻尼牛顿法、Goldfeld修正法、Cholesky分解法等。</p><h2 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h2><p>共轭梯度法是介于梯度下降法和牛顿法之间的一种方法，梯度下降法只使用了一阶导数信息，收敛速率较慢，牛顿法虽二阶收敛，但计算量大，共轭梯度法也只使用一阶导数信息，因此计算量小于牛顿法，同时它具有<strong>二次终止性。</strong>共轭梯度法最开始是应用在正定二次目标函数的优化中，它的基本思想是利用负梯度方向和已有的搜索方向产生新的搜索方向，迭代过程中产生的这一组搜索方向是两两共轭的。</p><blockquote><p><strong>共轭性：</strong> 设$G$是$n$阶对称正定矩阵，$d_1,d_2,\dots,d_m(m\leq n)$为一组非零向量，如果$$d_i^TGd_j = 0,i \neq j,$$则称$d_1,d_2,\dots,d_m$关于$G$是共轭的。</p></blockquote><p>显然 ，若$d_1,d_2,\dots,d_m$关于$G$共轭，那么它们必是线性无关的。那么我们如何利用当前迭代点的梯度和上一搜索方向构造当前点的搜索方向呢？假设我们需要求解的是目标函数为<br>$$<br>f(x) = \frac{1}{2}x^TGx + b^Tx + c,<br>$$并且，下一搜索方向为<br>$$<br>d_{k+1} = -g_{k+1} + \beta d_{k},<br>$$</p><p>我们希望$d_{k+1}$与$d_k$关于G共轭，也就是$d_{k+1}^TGd_k = 0,$那么$$-g_{k+1}^TGd_k + \beta d_k^TGd_k = 0,$$得到$$\beta = \frac{g_{k+1}^TGd_k}{d_k^TGd_k}.$$<br>因此我们就得到了共轭梯度法的迭代步骤。<br><strong>共轭梯度法</strong><br>:  </p><ol><li>给定初始点$x_0$, 误差$\epsilon$, $d_0 = -g_0$</li><li>若$| - g_k|&lt;\epsilon$停止迭代</li><li>$\beta_{k-1} = \frac{g_{k}^TGd_{k-1}}{d_{k-1}^TGd_{k-1}},d_k = -g_{k} + \beta_{k-1}d_{k-1}$</li><li>$\alpha_k = \arg\min f(x_k + \alpha d_k)$</li><li>$x_{k+1} = x_k + \alpha_k d_k$</li></ol><blockquote><p><strong>定理：</strong>对正定二次目标函数，$d_0 = -g_0,$ $ \beta_k = \frac{g_{k+1}^TGd_k}{d_k^TGd_k}$, $d_{k+1} = -g_{k+1} + \beta_k d_{k},$ 并且采用精确线搜索得到的共轭梯度法，在$m(\leq n)$次迭代后可求得目标函数的极小点。</p></blockquote><p>上面的推导是基于目标函数为正定二次函数的，对于一般的非二次目标函数，$\beta_k$ 的更新需要修改一下，比较常用的有，FR公式：$\beta_k = \frac{g_{k+1}^Tg_{k+1}}{g_k^Tg_k}$ 或 PRP公式：$\beta_k = -\frac{g_{k+1}^T(g_{k+1}-g_k)}{g_k^Tg_k}.$ 虽然对于二次目标函数共轭梯度法有二次终止性，但是对于一般的非二次目标函数就没有那么好的性质，而且实际应用中会采用重启动策略，即重新选择负梯度方向作为搜索方向。</p><h2 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h2><p>拟牛顿法是求解无约束优化问题最有效的方法之一，著名的拟牛顿法有DFP算法和BFGS算法。拟牛顿法的基本思想是模拟牛顿方向的生成途径，它利用两个迭代点的位移和梯度差来构造与二阶导数矩阵相似的正定矩阵。拟牛顿法的计算量要少于牛顿法，而且在一定条件下是超线性收敛的。</p><p>考虑$f$在$x_{k+1}$点的二阶泰勒展开：<br>$$<br>f(x) \approx f(x_{k+1}) + g_{k+1}^T(x-x_{k+1})+\frac{1}{2}(x-x_{x+1})^TG_{k+1}(x-x_{x+1}),<br>$$<br>对上式两边同时求导得到：<br>$$<br>g(x) = g_{k+1} + G_{k+1}(x-x_{x+1}),<br>$$<br>令$x=x_k$得<br>$$<br>G_{k+1}^{-1}y_k \approx s_k,<br>$$<br>其中$y_k = g_{k+1}-g_k$为梯度差，$s_k = x_{k+1}-x_k$为位移。显然，上式还是和牛顿法的迭代步骤一样，回想一下，牛顿法的计算代价主要花费在了二阶导数的计算和求解一个线性方程组上面，那么我们能否避开这两个缺点，同时还保留牛顿法超线性收敛的优点？所以拟牛顿法的基本出发点为用$H_{k+1}$近似$G_{k+1}^{-1},$同时满足<br>$$<br>H_{k+1}y_k \approx s_k,<br>$$<br>这个方程也叫做拟牛顿方程或拟牛顿条件。</p><p>关于构造满足拟牛顿条件的$H_{k+1},$有两个比较重要的算法。</p><h3 id="DFP算法"><a href="#DFP算法" class="headerlink" title="DFP算法"></a>DFP算法</h3><p>DFP(Davidon, Fletcher, Powell)算法的校正公式为<br>$$<br>H_{k+1} = H_k - \frac{H_ky_ky_k^TH_k}{y_k^TH_ky_k} + \frac{s_ks_k^T}{s_k^Ty_k}.<br>$$</p><blockquote><p><strong>定理：</strong> DFP在求解二次正定目标函数时,如果初始矩阵$H_0$是正定的，那么它产生的搜索方向为共轭方向，并且具有二次终止性。</p></blockquote><h3 id="BFGS算法"><a href="#BFGS算法" class="headerlink" title="BFGS算法"></a>BFGS算法</h3><p>BFGS(Broyden, Fletcher, Goldfard, Shanno)算法的校正公式为<br>$$<br>H_{k+1} = H_k - \frac{H_ky_ky_k^TH_k}{y_k^TH_ky_k} + \frac{s_ks_k^T}{s_k^Ty_k} + v_kv_k^T.<br>$$<br>其中$v_k = (y_k^TH_ky_k)^{\frac{1}{2}}\left(\frac{s_k}{s_k^Ty_k} -  \frac{H_ky_k}{y_k^TH_ky_k} \right).$</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] 袁亚湘院士，非线性优化计算方法<br>[2] 倪勤，最优化方法与程序设计</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XGBoost</title>
      <link href="/2018/07/08/XGBoost/"/>
      <url>/2018/07/08/XGBoost/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h1><p>&emsp;&emsp;XGBoost也是一种 Boosting 方法，是陈天奇大佬提出的，广泛应用于各大数据挖掘比赛，它几乎就是在<a href="https://tfeima.github.io/2018/07/06/gbdt/">GBDT</a>的基础之上做了很多细节的优化，这些细节的优化使得XGBoost在很多数据集上拥有比GBDT更强的泛化性能。回归树在做节点分裂的时候需要遍历所有的特征，以确定最佳的特征进行分裂，这一算法在工程实现时，对特征选择进行了并行化处理，使得其在多核计算机上拥有更快的训练速度。</p><h2 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h2><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>&emsp;&emsp;上一篇讲解过<a href="https://tfeima.github.io/2018/07/06/gbdt/">GBDT</a>，与GBDT类似，XGBoost也是基于前向分步加法模型进行迭代地求解每一个基学习器。在建立目标函数方面，XGBoost从两个发面出发，一方面目标函数包含一个用来衡量学习器对数据集拟合情况的损失函数；另一方面目标函数还包括了当前学习器模型复杂程度的度量，也即正则项，这一点是在目标函数方面对GBDT的一个改进。结合损失函数和正则项两方面，在第$m$次迭代的时候，得到如下目标函数：<br>\begin{equation}<br>\begin{array}{r l}<br>obj = &amp; \min_w \sum_{i=1}^n L \left( y_i,f_{m-1}(x_i)+T(x_i;w) \right) + \gamma J +\frac{1}{2} \lambda| w  |_2^2 \<br>    = &amp; \min_w \sum_{i=1}^n L\left( y_i,f_{m-1}(x_i)+\sum_{j=1}^J w_j I \left( x_i \in R_j\right) \right) + \gamma J +\frac{1}{2} \lambda\sum_{j=1}^J w_j^2 \<br> = &amp; \min_w \sum_{j=1}^J \sum_{x_i \in R_j} L\left(y_i,f_{m-1}(x_i) + w_j \right) +\frac{1}{2}\lambda w_j^2 + \gamma,<br>\end{array}<br>\end{equation}<br>上式中的$J$为一棵树的叶子节点个数，$R_j$为第$j$个叶子节点或者叫做划分空间，$w_j$为叶子节点的取值，也就是要求解的参数。目标函数的第二项 $\gamma J +\frac{1}{2} | w  |_2^2$ 就是正则项，它使得在优化目标更倾向于叶子节点相对较少，权重相对较小的参数。那么对于每个节点而言，最优的取值由下式得到：<br>$$w_j^{\ast} = \arg\min_{w_j} \sum_{x_i \in R_j} L\left(y_i,f_{m-1}(x_i) + w_j \right) +\frac{1}{2}\lambda w_j^2 + \gamma,$$<br>对目标函数进行二阶泰勒展开<br>$$<br>w_j^{\ast} = \arg\min_{w_j} \sum_{x_i \in R_j} L\left(y_i,f_{m-1}(x_i)\right) + g_iw_j+\frac{1}{2}h_iw_j^2 + \frac{1}{2}\lambda w_j^2 + \gamma,<br>$$<br>去掉常数项，得到目标函数<br>$$<br>w_j^{\ast} = \arg\min_{w_j} \sum_{x_i \in R_j} \left( g_iw_j+\frac{1}{2}h_iw_j^2\right) + \lambda w_j^2 + \gamma,<br>$$<br>其中$g_i = \frac{\partial L(f(x))}{\partial f(x)} \Big|_ {f(x) = f_ {m-1}(x_i)}, h_i = \frac{\partial^2 L(f(x))}{\partial f^2(x)} \Big|_ {f(x) = f_ {m-1}(x_i)}.$<br>方便起见，令$G_j = \sum_{x_i \in R_j} g_i, H_j = \sum_{x_i \in R_j} h_i,$求解上面的 一元二次非程得到最优解：<br>$$w_j^{\ast} = -\frac{G_j}{H_j+\lambda},$$<br>将最优解代入目标函数得到最优值为<br>$$<br>\text{opt_j} = -\frac{1}{2}\frac{G_j^2}{H_j+\lambda} + \gamma.<br>$$</p><h3 id="节点分裂"><a href="#节点分裂" class="headerlink" title="节点分裂"></a>节点分裂</h3><p>&emsp;&emsp;由上面推导出在每个叶子节点的最优取值，那么节点分裂前后目标函数最优值的下降量为：<br>\begin{equation}<br>\begin{array}{r l}<br>&amp; -\frac{1}{2}\frac{G_j^2}{H_j+\lambda} + \gamma - \left( -\frac{1}{2}\frac{G_{jL}^2}{H_{jL}+\lambda} + \gamma-\frac{1}{2}\frac{G_{jR}^2}{H_{jR}+\lambda} + \gamma\right) \<br>= &amp; \frac{1}{2}\left(\frac{G_{jL}^2}{H_{jL}+\lambda} + \frac{G_{jR}^2}{H_{jR}+\lambda} - \frac{G_j^2}{H_j+\lambda}  \right) - \gamma<br>\end{array}<br>\end{equation}<br>故我们可以遍历所有的特征和特征划分以选择最优的分裂。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>XGBoost 算法</strong><br>:  </p><ol><li>$f_0(x) = \arg\min_w \sum_{i=1}^nL(y_i,w)$</li><li>$m = 1,\cdots,M:$<br>a. $g_i = -\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)}\Big|_  { f(x) = f_ {m-1}(x)}, \<br>h_i = \frac{\partial^2 L(y_i,f(x))}{\partial f^2(x)} \Big|_ {f(x) = f_ {m-1}(x_i)}, i=1,\cdots,n$<br>b. 使用上面描述的节点分裂的方法生成$T(x;w) = \sum_{j}^J w_j I(x\in R_j)$<br>c. $f_m(x) = f_{m-1}(x) + \sum_{j}^J w_j I(x\in R_j)$</li></ol><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>&emsp;&emsp;XGBoost 可以自动的学习出缺失值的分裂方向，具体来说，当一个特征在某些样本缺失时，分裂算法在查找这个特征最佳分裂点时做两次遍历，一次遍历把所有包含缺失值的样本分裂到左边，第二次分裂到右边，从两次遍历中找到该特征的最佳分裂点和缺失值分裂方向。</p><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>&emsp;&emsp;在防止过拟合方面，XGBoost引入了很多的正则化手段，具体来说包括：</p><ol><li>目标函数引入了权重的$L1,L2$正则项，有利于减少每个树模型的复杂度，降低方差</li><li>学习率，每次迭代生成一个树都要乘上学习率</li><li>样本和特征的下采样，借鉴了随机森林</li></ol><h2 id="XGBoost与GBDT的区别和联系"><a href="#XGBoost与GBDT的区别和联系" class="headerlink" title="XGBoost与GBDT的区别和联系"></a>XGBoost与GBDT的区别和联系</h2><ol><li><strong>在目标函数方面：</strong> XGBoost引入了正则项，而GBDT没有，由于XGBoost需要用到目标函数的二阶泰勒展开，所以XGBoost的目标函数必须是二阶可微的。</li><li><strong>正则化方面：</strong> gbdt中引入学习率和样本的下采样，而XGBoost还引入了特征维度的下采样，XGBoost还可以设置提前终止。</li><li><strong>在学习树的结构方面：</strong> GBDT每一步是拟合一个CART，拟合的目标就是负梯度方向，分裂节点时用的是平方误差损失，因为回归树的损失函数就是平方误差损失；XGBoost虽然也是一个回归树，但是它分裂节点时直接对损失函数做优化，叶子节点的权重和分裂都是直接在损失函数的基础上优化的。</li><li><strong>缺失值处理方面：</strong> GBDT所采用的CART可以对有缺失值的数据进行训练，它对缺失值处理的方式是忽略掉特征在那些样本缺失的数据，只用无缺失的数据进行训练，预测的时候，若存在缺失值则使用替代变量进行分割（在sklearn实现的GBDT好像并不能处理缺失值）；而XGBoost通过学习出缺失值的的默认分裂方向来处理缺失值。<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>[1] Tianqi Chen, XGBoost: A Scalable Tree Boosting System<br>[2] Hastie, The Elements of Statistical Learning<br>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650732958&amp;idx=1&amp;sn=234f0aa7992d2435a266bab96c9f4a2a&amp;chksm=871b3de0b06cb4f6dea8b742469df89878a583688ee6c9c138f08a498f756198d17164c0881f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器之心，为什么XGBoost在机器学习竞赛中表现如此卓越？</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GBDT(Gradient Boosting Decision Tree)</title>
      <link href="/2018/07/06/gbdt/"/>
      <url>/2018/07/06/gbdt/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h1><h2 id="GBDT的提出"><a href="#GBDT的提出" class="headerlink" title="GBDT的提出"></a>GBDT的提出</h2><h3 id="什么是GBDT？"><a href="#什么是GBDT？" class="headerlink" title="什么是GBDT？"></a>什么是GBDT？</h3><p>&emsp;&emsp;这里讲GBDT其实是GBM（Gradient Boosting Machine）基学习器使用回归树时的一种具体实现形式,简单来讲，GBDT与上一节讲的<a href="https://tfeima.github.io/2018/07/04/adaboost/">AdaBoost</a>类似，它也是一种前向分步加性模型，假设它要学习M个学习器，那么在第$m$次迭代的时候，第m个学习器的学习要经过前$m-1$个学习器的指导，并且每个学习器有一个对应的权重，最后加权相乘求和就是最后要求解的模型:<br>$$<br>\hat{f}(x) = \sum_{m=1}^M \beta_mG_m(x).<br>$$<br>$\hat{f}(x)\text{是完美函数}f(x)$在数据集上的近似。</p><h3 id="为什么要提出GBDT"><a href="#为什么要提出GBDT" class="headerlink" title="为什么要提出GBDT?"></a>为什么要提出GBDT?</h3><p>&emsp;&emsp;为了求出$\beta_m$和$G_m(x)$，一般情况下我们需要给出一个用来度量$\hat{f}(x)$在数据集上的表现、拟合情况，也就是所谓的损失函数。我们知道AdaBoost在样本集上极小化指数损失函数来求得权重$\beta_m$和$G_m(x)$，在上一节的讨论中，我们发现指数损失函数有时候鲁棒性没有那么好，对于不同的数据集，我们可能有尝试其他损失函数的需求，比如说对率损失，在做回归任务的时候也需要不同的损失函数。回顾<a href="https://tfeima.github.io/2018/07/04/adaboost/">AdaBoost</a>，在每一步迭代的时候，指数损失很自然地把前$m-1$次的结果作为了样本的权重。对于一般的损失函数，我们得到下面优化目标：<br>\begin{equation}<br>\begin{array}{c l}<br>\min &amp; \sum_{i=1}^n L(y_i,f_{m-1}(x_i)+\beta_mG_m(x_i))<br>\end{array}<br>\end{equation}<br>在回归任务中，当损失函数为平方损失时，也是比较容易优化的，因为使用平方损失函数，上式就变为<br>\begin{equation}<br>\begin{array}{c l}<br>\min &amp; \sum_{i=1}^n \left(\left(y_i-f_{m-1}(x_i)\right)-\beta_mG_m(x_i))\right)^2\<br>\end{array}<br>\end{equation}<br>实际上是在拟合前$m-1$次的结果与真实因变量的残差。</p><h2 id="算法流程和推导"><a href="#算法流程和推导" class="headerlink" title="算法流程和推导"></a>算法流程和推导</h2><h3 id="从函数空间的角度去优化-f-x"><a href="#从函数空间的角度去优化-f-x" class="headerlink" title="从函数空间的角度去优化$f(x)$"></a>从函数空间的角度去优化$f(x)$</h3><p>&emsp;&emsp;假设我们要优化如下目标函数<br>$$L(f)$$<br>对于这样一个无约束的优化问题，使用梯度下降法来求最优解，$f_0$为初始点，那么得到如下迭代序列：<br>$$f_m = f_{m-1} - \rho_m g_m，$$<br>其中<br>\begin{equation}<br>g_m = \frac{\partial L(f)}{\partial f}\Big|_ { f = f_ {m-1}}<br>\end{equation}<br>$\rho_m $由线搜索得到：<br>$$\rho_m = \arg \min_{\rho} L(f_{m-1} - \rho g_m)$$<br>最终得到<br>$$<br>\begin{array}{c l}<br>f_m &amp; = f_{m-1} - \rho_m g_m \<br>    &amp; = f_{m-2} - \rho_{m-1}g_{m-1} - \rho_{m}g_m \<br>    &amp; \cdots \<br>    &amp; = f_0 + \sum_{i=1}^m -\rho_i g_i<br>\end{array}<br>$$</p><blockquote><p><strong>分析</strong></p><ol><li>梯度下降法求$L(f)$最优解的迭代步骤与前向分步加性模型形式上一样，都是通过迭代逐渐地逼近最优解$f^{\ast}$</li><li>$f^{\ast}$是产生当前数据集的函数，是客观存在但我们并不知道的，梯度下降和前向分步加法模型的目标都是求得$\hat{f}\approx f^{\ast}$</li><li>当知道$f_{m-1}$时，前向分步需要求得$\beta_m\text{和}G_m(x)$；梯度下降需要计算出$\rho_{m},-g_m$.</li><li><strong>前向分步不知道如何求得$\beta_m\text{和}G_m(x)$；梯度下降计算不出来$\rho_{m},-g_m$（why?在函数空间，$g_m$也是一个函数，也是客观存在，但并不知晓，唯一知道的就是$g_m(x_i)$）</strong>,于是，我们可以用$G_m(x)$去拟合$-g_m(x)$,剩下的$\beta_m\text{或者}\rho_m$就是一个单变量优化问题了。</li></ol></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>Gradient Boosting 算法</strong><br>:  </p><ol><li>$f_0(x) = \arg\min_\gamma \sum_{i=1}^nL(y_i,\gamma)$</li><li>$m = 1,\cdots,M:$<br>a. $g_i^m = -\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)}\Big|_  { f(x) = f_ {m-1}(x)},i=1,\cdots,n$<br>b. $\theta_m = \arg\min_{\theta} \sum_{i=1}^n \left( G(x_i;\theta) - g^m_i\right)^2$<br>c. $\beta_m = \arg\min_{\beta} \sum_{i=1}^n L\left( y_i,f_{m-1}(x_i)+\beta G(x_i;\theta_m) \right)$<br>d. $f_m(x) = f_{m-1}(x) + \beta_mG(x;\theta_m)$</li></ol><p>&emsp;&emsp;当我们令回归树作为基学习器时，上面算法中的求解每一步学习器参数和步长（权重）可变为更具体的形式。回归树的决策函数为:<br>$$T(x;\theta) = \sum_{j}^J b_j I(x\in R_j),$$<br>$R_j$为叶子节点，$b_j = mean\lbrace{x \in R_j \rbrace},$ 在迭代生成第$m$棵树时，此时的目标函数变为<br>\begin{equation}<br>\begin{array}{c l}<br>\min &amp; \sum_{i=1}^n L(y_i,f_{m-1}(x_i)+\beta_m T(x;\theta)) \<br>= \min &amp; \sum_{i=1}^n L(y_i,f_{m-1}(x_i)+ \sum_{j}^J \beta_mb_j I(x\in R_j) \<br>= \min &amp; \sum_{j=1}^J \sum_{x_i \in R_j} L(y_i,f_{m-1}(x_i)+\gamma_j)<br>\end{array}<br>\end{equation}<br>因此<br>$$\gamma_j = \arg\min_{\gamma} \sum_{x_i \in R_j} L(y_i,f_{m-1}(x_i)+\gamma).$$<br>所以可得到如下算法：</p><p><strong>基于 Deciision Tree 的 Gradient Boosting 算法</strong><br>:  </p><ol><li>$f_0(x) = \arg\min_\gamma \sum_{i=1}^nL(y_i,\gamma)$</li><li>$m = 1,\cdots,M:$<br>a. $g_i^m = -\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)}\Big|_ { f(x) = f_ {m-1}(x)},i=1,\cdots,n$<br>b. 基于$\lbrace{x_i,g_i^m \rbrace}_{i=1}^n$拟合一个回归树，得到$R_j,j=1,\cdots,J$<br>c. $\gamma_j = \arg\min_{\gamma} \sum_{x_i \in R_j} L\left(y_i,f_{m-1}(x_i)+\gamma\right),j=1,\cdots,J$<br>d. $f_m(x) = f_{m-1}(x) + \sum_{j}^J \gamma_j I(x\in R_j)$</li></ol><blockquote><p>简单来讲，为了求得第$m$棵树，我们需要做两步：第一，基于负梯度拟合出一个回归树；第二，根据损失函数求出回归树每个节点的最优取值，相当于线搜索。</p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>&emsp;&emsp;不同的应用会有不同的损失函数，不同的损失函数会产生不同的梯度形式，以及每个叶子节点的最优取值，下面分别讨论。</p><h3 id="回归任务"><a href="#回归任务" class="headerlink" title="回归任务"></a>回归任务</h3><h4 id="最小二乘回归"><a href="#最小二乘回归" class="headerlink" title="最小二乘回归"></a>最小二乘回归</h4><p>损失函数为<br>$$L(y,f) = \frac{1}{2}(y-f)^2$$<br>梯度为<br>$$g = y-f$$<br>事实上就是残差，每个叶子节点的取值为所有当前叶子节点样本因变量的<strong>均值</strong>。</p><h4 id="LAD-回归"><a href="#LAD-回归" class="headerlink" title="LAD 回归"></a>LAD 回归</h4><p>损失函数为<br>$$L(y,f) = \left| y-f \right|$$<br>梯度为<br>$$g = sign(y-f),$$<br>是残差的符号，每个叶子节点的取值为所有当前叶子节点样本因变量的<strong>中位数</strong>。</p><p>&emsp;&emsp;<strong>绝对值作为损失函数比最小二乘有更好的鲁棒性，</strong>特别是对于长尾数据，最小二乘很容易受这些数据的影响。</p><h3 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h3><h4 id="对率损失"><a href="#对率损失" class="headerlink" title="对率损失"></a>对率损失</h4><p>损失函数为<br>$$L(y,f) = \log(1+\exp(-yf(x)))$$<br>梯度为<br>$$g = -\frac{y}{1+\exp(yf(x))},$$</p><h4 id="指数损失"><a href="#指数损失" class="headerlink" title="指数损失"></a>指数损失</h4><p>损失函数为<br>$$L(y,f) = \exp(-yf(x)))$$<br>梯度为<br>$$g = -y\exp(-yf(x)),$$<br><!--## 正则化策略--><br><!--1. 学习率<!--2. --></p><h2 id="特征重要性"><a href="#特征重要性" class="headerlink" title="特征重要性"></a>特征重要性</h2><p>&emsp;&emsp;实际应用时，除了关注模型对数据的预测能力外，往往还想知道究竟哪些特征对于模型的预测能力贡献比较大，比如在<code>sklearn</code>训练完模型后，我们能够直接输出特征的重要性排序，那么如何计算特征的重要性呢？</p><p>在单棵回归树中，一个特征的重要性是通过下面这个式子定义的：<br>$$\text{feature_importance}_ i^2(T) = \sum_ {t=1}^{J-1}\text{improve}_t^2I\left( v(t)=i \right)$$<br>具体来讲就是，在回归树T中，第$i$个特征的重要性等于那些以特征$i$作为划分节点时，划分前后损失函数的下降量的平方和。推广到GBDT时，假设有$M$次迭代，那么特征的重要性为<br>$$\text{feature_importance}_ i^2 = \frac{1}{M}\sum_ {m=1}^M\text{feature_importance}_i^2(T_m),$$<br>一般情况下，计算完所有的特征重要性后，把所有的值可以放缩到$[0,1]$</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Hastie, The Elements of Statistical Learning<br>[2] Friedman, Greedy Function Approximation: A Gradient Boosting Machine</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解AdaBoost</title>
      <link href="/2018/07/04/adaboost/"/>
      <url>/2018/07/04/adaboost/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>&emsp;&emsp;AdaBoost的算法思想是迭代地训练多个弱分类器$G_m(x)$，并将这多个弱分类器的结果加权组合起来作为最终的结果:<br>$$f(x)=\sum_{m=1}^M \beta_mG_m(x),$$<br>其中当迭代到第$m$次训练$G_m(x)$时，$G_m(x)$需要参考前$m-1$次的训练结果，参考的方式是根据$f_{m-1}(x)=\sum_{i=1}^{m-1}\beta_{i}G_i(x)$对每个样本预测的结果调整样本的权重，若$f_{m-1}(x)$对样本分类错误，训练$G_m(x)$时需要增大此样本的权重，使得$G_m(x)$能够对已经训练好的分类器在分错的样本上关注更多。</p><p>AdaBoost算法<br>:    </p><ol><li>初始化每个样本的权重$w_i=\frac{1}{n},i=1,\cdots,n$</li><li>$m=1,\cdots,M$<br>a. 使用带权重$w^m_i$的样本训练$G_m(x)$<br>b. $\epsilon = \frac{\sum_{i=1}^nw_i^mI\left(y_i \neq G_m(x_i)\right)}{\sum_{i=1}^nw_i^m}$<br>c. $\beta_m = \frac{1}{2}\ln\frac{1-\epsilon}{\epsilon}$<br>d. $w^{m+1}_i = w_i^m\exp(2\beta_m I\left(y_i \neq G_m(x_i)\right))$</li><li>$f(x)=\sum_{m=1}^M \beta_mG_m(x)$</li></ol><blockquote><p><strong>分析</strong><br>上述算法，开始训练之前每个样本的权重都是均等的，每次迭代分类器都依据当前样本的权重训练模型，然后计算出当前模型带权重的误差率$\epsilon$，$\epsilon \in [0,\frac{1}{2}),$故，$\beta_m \in (0,+\infty)$,若当前分类器将样本错分，相应地这个样本在下一轮训练的时候权重增大$\exp(2\beta_m)$倍。</p></blockquote><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>&emsp;&emsp;本小节给出上一小节算法步骤中$\beta_m \text{以及权重}w_i^m$更新的依据。</p><p>&emsp;&emsp;一般AdaBoost的推导步骤都理解为基于指数损失函数的前向分步加法模型(Foward Stagewise Additive Modeling)，虽然据说AdaBoost最开始并不是这样提出的，直到提出5年之后才发现AdaBoost可以从前向加法模型推导解释。</p><blockquote><p><strong>指数损失函数</strong><br>$$L(y,f(x))=\exp(-yf(x))$$</p></blockquote><blockquote><p><strong>前向分步加法模型</strong><br>&emsp;&emsp;定义 $f_m = \sum_{i=1}^m\beta_iG_i(x),$ 我们需要求解$\beta_i\text{和}G_{i}(x),i=1,\cdots,m$,一般我们并不是同时解出$\beta_i,G_{i}(x),i=1,\cdots,m$,而是分步地、在求得$f_{m-1}$的基础之上，再求解$\beta_m,G_{m}(x)$.</p></blockquote><p>&emsp;&emsp;接下来，我们基于指数损失函数和前向加法模型来推导AdaBoost. 假设我们要求解的$f(x)$满足：$$f^{\ast} = \arg\min_f \sum_{i=1}^n\exp(-y_if(x_i)),$$ 而$f(x)=\sum_{m=1}^M \beta_mG_m(x)$, 利用前向分步加法模型，假设已经求得$f_{m-1},$ 下一步需要优化的目标变为：<br>\begin{equation}<br>\begin{array}{c l}<br>(\beta_m,G_m) &amp; = \arg\min_{\beta,G(x)} \sum_{i=1}^n \exp\left(-y_i(f_{m-1}(x_i) + \beta G(x_i))\right) \<br>            &amp; = \arg\min_{\beta,G(x)} \sum_{i=1}^n \exp(-y_if_{m-1}(x_i))\exp(-y_i\beta G(x_i))) \<br>            &amp; = \arg\min_{\beta,G(x)} \sum_{i=1}^n w_i^m \exp(-y_i\beta G(x_i))),<br>\end{array}<br>\end{equation}<br>其中$w_i^m = \exp(-y_if_{m-1}(x_i)).$</p><p><strong>上式可以分两步求解：</strong><br><strong>首先</strong>对任意的$\beta$求出$G(x)$,<br>$$G_m(x) = \arg\min_{G(x)} \sum_{i=1}^n w_i^m I\left( y_i \neq G(x_i) \right).$$<br><strong>接下来</strong>在$G_m(x)$ 的基础上，求出$\beta_m$：<br>\begin{equation}<br>\begin{array}{c l}<br>\beta_m &amp; = \arg\min \sum_{i=1}^n w_i^m \exp (-y_i \beta G_m(x_i)) \<br>&amp; = \arg\min \sum_{i \in I\left( y_i = G(x_i) \right)} w_i^m e^{-\beta} + \sum_{i \in I\left( y_i \neq G(x_i) \right)} w_i^m e^{\beta},<br>\end{array}<br>\end{equation}<br>对上式关于$\beta$求导并等于0，得到$$\beta_m = \frac{1}{2}\ln\frac{1-\epsilon}{\epsilon}, $$<br>其中$\epsilon = \frac{\sum_{i=1}^nw_i^mI\left(y_i \neq G_m(x_i)\right)}{\sum_{i=1}^nw_i^m}.$<br>下一步<strong>样本权重的更新</strong>则变为<br>\begin{equation}<br>\begin{array}{c l}<br>w_i^{m+1} &amp; = \exp(-y_if_m(x_i)) \<br>&amp; = w_i^{m}\exp(-\beta_my_iG_m(x_i)) \<br>&amp; = w_i^{m}\exp(2\beta_mI(y_i \neq G_m(x_i)))\exp(-\beta_m)\<br>\end{array}<br>\end{equation}<br>由于$\exp(-\beta_m)$与样本无关，对每个样本均有相同作用，所以忽略这一项得到$w_i^{m+1}= w_i^{m}\exp(2\beta_mI(y_i \neq G_m(x_i)))$.</p><h2 id="损失函数分析"><a href="#损失函数分析" class="headerlink" title="损失函数分析"></a>损失函数分析</h2><h3 id="指数损失与对率损失函数的等价性"><a href="#指数损失与对率损失函数的等价性" class="headerlink" title="指数损失与对率损失函数的等价性"></a>指数损失与对率损失函数的等价性</h3><p>&emsp;&emsp;前文提到AdaBoost用到的损失函数为指数损失，在函数空间，我们想要得到的最优函数为：<br>$$f^{\ast} = \arg\min_f E_{y|x}(\exp(-yf(x))),$$<br>其中，<br>$$E_{y|x}(\exp(-yf(x))) = p(y=1|x)e^{-f(x)}+p(y=-1|x)e^{f(x)},$$<br>对上式关于$f$求导并令其等于0得到：<br>$$f(x) = \frac{1}{2}\ln\frac{p(y=1|x)}{1-p(y=1|x)},$$<br>或者<br>$$p(y=1|x)=\frac{1}{1+\exp(-2f(x))},$$<br>回顾一下逻辑回归，这个式子是不是和逻辑回归有几分相似？逻辑回归利用最大似然估计最后得到了以对率损失为目标函数的优化目标，这里同样可以得出相同的损失函数。统一一下后验概率得到：<br>$$p(y|x)=\frac{1}{1+\exp(-2yf(x))},$$<br>那么最大对数似然得到：<br>\begin{equation}<br>\begin{array}{c l}<br>\max &amp; \sum_{i=1}^n \ln \frac{1}{1+\exp(-2y_if(x_i))}<br>\end{array}<br>\end{equation}<br>等价于<br>\begin{equation}<br>\begin{array}{c l}<br>\min &amp; \sum_{i=1}^n \ln \left(1+\exp(-2y_if(x_i))\right) \<br>\end{array}<br>\end{equation}<br>上式中的损失函数即为对率损失函数。从上面的推导，我们得出，<strong>最小化指数损失函数与最小化对率损失函数是等价的！</strong></p><h3 id="鲁棒性分析"><a href="#鲁棒性分析" class="headerlink" title="鲁棒性分析"></a>鲁棒性分析</h3><p>&emsp;&emsp;由上一小节，我们推导出了指数损失函数和对率损失函数的等价性，等价性成立的条件是如果我们分别从两个不同的目标函数出发，那么求出来这个完美的$f^{\ast}$是相同的,$f^{\ast}$是客观存在的完美函数，<strong>但是现实中我们拥有的样本是有限的，机器学习的目标是通过这么多有限的样本去还原、猜测$f^{\ast}$，这时候两个不同的损失函数求得的结果可能就会存在一些差异</strong>。</p><p>&emsp;&emsp;想一下我们是怎么利用$f(x)$做分类的？通过$\text{sign}(f(x))$来对样本分类的，若$y_if(x_i)&gt;0,$意味着$f(x)$将$x_i$分类正确了，否则分类错误，当分类错误时，$\exp(-y_if(x_i))$具有较大的值，会给损失函数带来较大的损失，因此优化过程中求得的$f(x)$应避免这种情况发生，类似于$0-1$损失。如下图<br><img src="https://tfeima.github.io/2018/06/28/svm-vs-lr/loss.png" alt="loss"><br>两个损失函数都是$0-1$损失的替代函数，但是它们之间存在不小的差异。</p><p>&emsp;&emsp;它们随$-yf(x)$变化增长的阶数不同，具体来说，一个呈指数级增长，一个为线性的。正是因为这种差异，使得对于同样的数据集，指数损失函数更倾向于优化那些使得$-yf(x)$较大的样本点，若数据中存在一些这样的点或者存在<code>outlier</code>将会对求得的$f(x)$具有较大影响。虽然那些$-yf(x)$较大的样本点或者<code>outlier</code>也会对对率损失函数产生不利影响，但是这种影响要比对指数损失函数的影响小得多。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Hastie, The Elements of Statistical Learning<br>[2] 周志华，机器学习<br>[3] 李航，统计学习方法</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机 vs 逻辑回归</title>
      <link href="/2018/06/28/svm-vs-lr/"/>
      <url>/2018/06/28/svm-vs-lr/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="支持向量机-vs-逻辑回归"><a href="#支持向量机-vs-逻辑回归" class="headerlink" title="支持向量机 vs 逻辑回归"></a>支持向量机 vs 逻辑回归</h1><p>作为面试中经常问到的一个问题，今天就从理论上作一个总结。</p><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>&emsp;&emsp;一般比较SVM和LR的时候，SVM是指线性软间隔SVM，LR是加了$L_2$正则化的逻辑回归。之前详细推导过<a href="https://tfeima.github.io/2018/03/14/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">SVM</a>和<a href="https://tfeima.github.io/2018/03/12/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/">LR</a>，两者的目标函数分别为：</p><p><strong>SVM</strong><br>\begin{equation}<br>\min \frac{| w |^2}{2} + C\sum_{i=1}^m \max\lbrace{ 0,1-y_i(w^Tx_i + b)\rbrace}<br>\end{equation}<br><strong>LR</strong><br>\begin{equation}<br>\min \sum_{i=1}^m \log \left(1+\exp\left(-y_i(w^Tx_i + b)\right) \right) + \lambda | w |^2<br>\end{equation}</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>&emsp;&emsp;loss function 分别叫做<strong>Hinge loss</strong>和<strong>Log loss</strong>,两则都是<strong>0-1 loss</strong>的替代损失函数，从下图可以看出<code>图片来源于《机器学习》，周志华</code>,<img src="/2018/06/28/svm-vs-lr/loss.png" alt="loss">两者作为替代损失，其效果其实是差不多的，当$y_i(w^Tx + b)\to 0$时，两者都趋向于0，而当 $y_i(w^Tx + b)\to - \infty$时，两者都趋向于 $-y_i(w^Tx + b)$。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>SVM的目标函数不可微，故无法使用基于梯度的优化算法进行求解；LR的目标函数是二阶可微的，可以使用一些基于梯度的算法直接进行求解</li><li>同样视为正则项$| w |^2$,SVM本身有着极好的<strong>几何解释（最大间隔）</strong>，直接在建模的时候给出了；而LR中的正则项一般将其视为<strong>参数的先验信息</strong>，如取$L_2$范数，则视为参数服从高斯分布的先验分布，目标函数是由最大后验概率(MAP)导出.</li><li>两者的建模过程SVM是从几何的角度出发，而LR则是从统计的角度出发</li></ul><h2 id="概率输出"><a href="#概率输出" class="headerlink" title="概率输出"></a>概率输出</h2><p>&emsp;&emsp;我们知道逻辑回归的输出结果，本身有着极好的概率意义，而SVM的输出却没有。一般来说，如果想让SVM的输出有概率意义，需要将SVM作一个特殊的处理，具体来说，就是需要进行三步。</p><blockquote><p><strong>SVM输出概率的步骤</strong><br><strong>step 1：找到SVM的法向量</strong><br>正常的步骤求出$w_{svm},b_{svm}$<br><strong>step 2：对法向量作一个伸缩变换</strong><br>利用上一步得到的$w_{svm},b_{svm}$，计算数据集中的每一个样本，得到$w_{svm}^Tx_i+b_{svm}$,作为逻辑回归的输入，求解下面参数：<br>\begin{equation}<br>\sum_{i=1}^m \log\left(1+\exp\left(-y_iA(w_{svm}^Tx_i+b_{svm})+B\right) \right)<br>\end{equation}<br><strong>step 3：转换为概率</strong><br>对于每一个样本$x_i$，SVM的概率输出为：<br>\begin{equation}<br>\frac{1}{1+\exp\left(-y_iA(w_{svm}^Tx_i+b_{svm})+B\right)}<br>\end{equation}</p></blockquote><h2 id="核方法"><a href="#核方法" class="headerlink" title="核方法"></a>核方法</h2><p>&emsp;&emsp;SVM很容易通过其对偶问题引入核技巧，而LR就没有那么显然了。</p><h3 id="SVM能够使用核方法的原因"><a href="#SVM能够使用核方法的原因" class="headerlink" title="SVM能够使用核方法的原因"></a>SVM能够使用核方法的原因</h3><p>&emsp;&emsp;首先我们分析一下SVM能够成功引入核技巧的原因：</p><ol><li>对偶问题中出现了$\phi(x)^T\phi(x)$，在训练模型中可引入核技巧</li><li>$w$能够表示成对偶形式：$$w = \sum_{i=1}^m \lambda_iy_i\phi(x_i)$$</li><li>预测时，只需计算$$\sum_{i=1}^m \lambda_iy_i\phi(x_i)^T\phi(x_i) + b$$</li></ol><h3 id="如何将核方法应用到LR（KLR）"><a href="#如何将核方法应用到LR（KLR）" class="headerlink" title="如何将核方法应用到LR（KLR）"></a>如何将核方法应用到LR（KLR）</h3><p>&emsp;&emsp;LR的目标函数中没有类似的第一点，并且由于是无约束的优化问题，也不能转化为对偶问题观察。但是，我们发现如果在LR中的w也能够表示成类似SVM的对偶形式，是不是就可以用核方法了？w能不能表示成$$w = \sum_{i=1}^m \lambda_iy_ix_i$$的形式呢？<br>&emsp;&emsp;假如我们用梯度下降法来求解LR的目标函数，回顾一下梯度下降法的更新公式：$$\theta_{k+1}=\theta_{k}-\alpha g_k,$$ <code>这里假设用固定的步长，$g_k$为目标函数的梯度</code>，更直观点：<br>$$\theta_{k+1}=\theta_{0}-\alpha \left(\sum_{i=0}^k g_i\right)$$<br>回到LR问题中，LR的梯度为：<br>$$g=\sum_{i=1}^m \frac{\sigma(y_i(w^Tx_i+b))}{1+\sigma(y_i(w^Tx_i+b))}(-y_ix_i)+w,$$<br>其中$\sigma(z)=\frac{1}{1+\exp(-z)}$,利用梯度下降的更新公式，求解LR的迭代过程，实际上是对每一步的梯度方向求和，将整个过程每一项$-y_ix_i$合并，我们能够得到$$w = \sum_{i=1}^m \lambda_iy_ix_i$$这个结果，正是我们想要的。这样推导，貌似有点玄乎，实际上是有理论保证的：</p><blockquote><p><strong>定理1</strong> 对于任意一个$L_2$正则化模型<br>$$<br>\sum_{i=1}^m \text{loss} \left(-y_i(w^Tx_i + b)\right) + \lambda | w |^2<br>$$<br>最优解$w^\ast=\sum_{i=1}^m\lambda_ix_i$<br><strong>证明：</strong> 从形式上看，我们就是要证明$w$落在$x_i,i=1,\cdots,m$生成的子空间中，所以可从样本生成的空间，将w分解，然后利用反证法证明w只可能在样本生成的空间中。</p></blockquote><p>&emsp;&emsp;有了这样一个定理，我们就可以将核技巧引入到逻辑回归当中了，将w表示成上述形式，直接求解：<br>\begin{equation}<br>\min_{\beta} \sum_{i=1}^m \log \left(1+\exp\left(-y_i\sum_{j=1}^m\beta_jK(x_i,x_j)\right) \right) + \lambda \sum_{i=1}^m\sum_{j=1}^m\beta_i\beta_jK(x_i,x_j)<br>\end{equation}</p><blockquote><p><strong>注意</strong>上面的有些地方，我们只着重讨论$w$，而没有关注$b$，实际上这并没有什么影响，因为可以对$x$增加一个维度，将$b$合并到$w$中.</p></blockquote><h2 id="对噪声的敏感程度"><a href="#对噪声的敏感程度" class="headerlink" title="对噪声的敏感程度"></a>对噪声的敏感程度</h2><p>先说结论：<strong>相比于LR，SVM对噪声更敏感</strong></p><p>&emsp;&emsp;注意到：SVM和LR中的法向量都可以表示为 $$w=\sum_{i=1}^m\lambda_iy_ix_i,$$但是，在<a href="https://tfeima.github.io/2018/03/14/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">SVM</a>中的推导中我们提到，SVM中的<strong>大部分$\lambda_i$都为0</strong>，只有少数$\lambda_i$不为0，与此对应的样本我们叫做支持向量，也就是说SVM中的解：$w_{svm}=\sum_{i\in S}\lambda_iy_ix_i,$,$w_{svm},$ 只与少部分支持向量有关，若SVM引入噪声，改变了支持向量，对最终的解的影响是非常巨大的，而LR的解就不具备稀疏的性质，引入少部分噪声，并不会对最终的解影响太大。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] 周志华，机器学习<br>[2] 林轩田，机器学习技法</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分式二次规划问题的线性时间算法</title>
      <link href="/2018/06/26/ldrq/"/>
      <url>/2018/06/26/ldrq/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="A-linear-time-algorithm-for-minimizing-the-ratio-of-quadratic-functions-over-an-ellipsoid"><a href="#A-linear-time-algorithm-for-minimizing-the-ratio-of-quadratic-functions-over-an-ellipsoid" class="headerlink" title="A linear-time algorithm for minimizing the ratio of quadratic functions over an ellipsoid"></a>A linear-time algorithm for minimizing the ratio of quadratic functions over an ellipsoid</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>We present a linear-time approximate algorithm for the problem(RQ)of minimizing the ratio of quadratic functions over an ellipsoid. The algorithmfrstly utilizes the bisection search to fnd a solution of Lagrange dual problemof (RQ), and then the global mimimum of (RQ) can be attained. Moreover,we prove the strong duality between primary problem and dual problem as well as give the interval of optimal Lagrange multiplier.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>we study the problem of minimizing the ratio of two quadratic functions subject to a single quadratic constraint:<br>$$<br>\begin{equation}<br>(\text{RQ}): \quad<br>\begin{array}{c l}<br>\min &amp;f(x) = \displaystyle \frac{ f_1(x)}{1+ | x|^2}, \<br>\text{s.t.} &amp; c(x) \leq 0,\<br>\end{array}<br>\end{equation}<br>$$<br>where $f_1(x) = x^TA_1x + 2b_1^Tx+ c_1, c(x)=x^TA_2x - c_2$ ,$A_1$ is symmetric and $A_2$ is positive semidefinite, $ b_1 \in R^n, c_1 \in R~ \text{and}~ c_2 &gt;0 .$ In particular, the problem (RQ) includes the regularized total least squares problem (RTLS)<br>\begin{equation}<br>(\text{RTLS}): \quad<br>\begin{array}{c l}<br>    \min &amp; \displaystyle \frac{| Ax - b |^2}{1+ | x|^2}, \<br>    \text{s.t.} &amp; | Lx | ^2  \leq \rho.\<br>\end{array}<br>\end{equation}</p><p>Here $\rho &gt; 0$ is a regularization parameter and $L \in R^{r\times n}$. The (RTLS) approach was extensively used in a variety of scientiflc disciplines such as signal processing, statistics, etc. Therefore, it is of great practical significance to study this (RQ) problem.</p><h2 id="Lagrange-dual-frame-for-RQ"><a href="#Lagrange-dual-frame-for-RQ" class="headerlink" title="Lagrange dual frame for RQ"></a>Lagrange dual frame for RQ</h2><p>we first show that problem (RQ) is equivalent to solving a Lagrange dual formulation by applying strong duality.</p><p>It’s clear to see that problem (RQ) is equivalent to<br>\begin{equation}<br>(\text{RQ}): \quad<br>\begin{array}{c l}<br>\min &amp;f(x) = \displaystyle\frac{ f_1(x)}{1+ | x|^2}, \<br>\text{s.t.} &amp; \displaystyle\frac{c(x)}{1+ | x|^2}  \leq 0.\<br>\end{array}<br>\end{equation}<br>For convenience, (RQ) problem in the following refers to above foumulation<br>The Lagrange function of (RQ) is writed that<br>\begin{equation}<br>    L(x,\lambda) = \frac{f_1(x)}{1+ | x|^2} + \lambda \frac{c(x)}{1+ | x|^2},<br>\end{equation}<br>then the dual function is given by<br>\begin{equation}<br>    g(\lambda) = \inf_x L(x,\lambda),\quad \lambda \geq 0.<br>\end{equation}<br>The Lagrange dual problem is thus<br>\begin{equation}<br>(\text{LD-RQ}): \quad<br>    \begin{array}{c l}<br>    \max &amp; g(\lambda) \<br>    \text{s.t.} &amp; \lambda \geq 0.<br>    \end{array}<br>\end{equation}</p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>we utilize the bisection search to solve the Lagrange dual problem. Then, it allows us to compute a (RQ) optimal solution from a dual optimal solution.<br><img src="/2018/06/26/ldrq/alg1.png" alt="alg1"></p><h2 id="Numerical-Results"><a href="#Numerical-Results" class="headerlink" title="Numerical Results"></a>Numerical Results</h2><p>Generally speaking, we can find the optimal function value of the nonconvex problem (RQ) by firstly solving the following convex SDP problem:<br>\begin{equation}<br>    (\text{SDP}): \quad<br>    \begin{array}{c l}<br>    \max\limits_{\lambda \geq 0} &amp; t \<br>    \text{s.t.} &amp; \begin{bmatrix}<br>    A_1  &amp; b_1 \<br>    b_1^T &amp; c_1  \<br>    \end{bmatrix} + \lambda \begin{bmatrix}<br>    A_2 &amp; 0 \<br>    0 &amp; -c_2<br>    \end{bmatrix} \succeq tI.      \<br>    \end{array}<br>\end{equation}<br>Therefore, we solve the optimal multiplier to compare the running time by some software packages and our method. These packages mainly include SeDuMi , SDPT3 within CVX as well as SCS , CVXOPT within CVXPY . Some of the experimental results are as follows.</p><h3 id="Compare-with-CVX"><a href="#Compare-with-CVX" class="headerlink" title="Compare with CVX"></a>Compare with CVX</h3><p><img src="/2018/06/26/ldrq/cvx.png" alt="cvx"></p><h3 id="Compare-with-CVXPY"><a href="#Compare-with-CVXPY" class="headerlink" title="Compare with CVXPY"></a>Compare with CVXPY</h3><p><img src="/2018/06/26/ldrq/cvxpy.png" alt="cvxpy"></p>]]></content>
      
      
      <categories>
          
          <category> 我的研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化算法 </tag>
            
            <tag> 分式规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-数组</title>
      <link href="/2018/06/20/LeetCode-%E6%95%B0%E7%BB%84/"/>
      <url>/2018/06/20/LeetCode-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode56-合并区间"><a href="#LeetCode56-合并区间" class="headerlink" title="LeetCode56. 合并区间"></a>LeetCode56. 合并区间</h1><blockquote><p>给出一个区间的集合，请合并所有重叠的区间。<br><code>奇技淫巧</code></p></blockquote><hr><ul><li>首先取出每个区间的左边和右边，并对其排序</li><li>如果l[i+1]&gt;r[i],说明第l_(i+1)个区间一定在前面i个区间的右边，并且中间有gap，不连续，就将前一次不连续的位置开始到i记录到结果中</li><li>j记录当前不连续区间的开始位置</li></ul><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = [],[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            l.append(i.start)</span><br><span class="line">            r.append(i.end)</span><br><span class="line">        l,r = sorted(l),sorted(r)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(intervals)):</span><br><span class="line">            <span class="keyword">if</span> i == len(intervals)<span class="number">-1</span> <span class="keyword">or</span> l[i+<span class="number">1</span>] &gt; r[i]:</span><br><span class="line">                res.append([l[j],r[i]])</span><br><span class="line">                j = i+<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode57-插入区间"><a href="#LeetCode57-插入区间" class="headerlink" title="LeetCode57. 插入区间"></a>LeetCode57. 插入区间</h1><blockquote><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。<br><code>细节实现</code></p></blockquote><hr><p>比较list中每个区间的头，先找到第一个比newInterval.start大的位置，所以需要在这个前面插入，然后判断在这个位置插入的时候是否有区间可以与其合并，若可以合并，就合并成为新的newInterval，并且在list中删去与其合并的区间，直到不能合并位置，然后插入。</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :type newInterval: Interval</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(intervals)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> [newInterval]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            <span class="keyword">if</span> intervals[i].start&gt;=newInterval.start:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        l = i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> intervals <span class="keyword">and</span> ((l&gt;=<span class="number">0</span> <span class="keyword">and</span> intervals[l].end&gt;=newInterval.start) <span class="keyword">or</span> (l&lt;n<span class="number">-1</span> <span class="keyword">and</span> intervals[l+<span class="number">1</span>].start&lt;=newInterval.end)):</span><br><span class="line">            <span class="keyword">if</span> l&gt;=<span class="number">0</span> <span class="keyword">and</span> intervals[l].end&gt;=newInterval.start:</span><br><span class="line">                newInterval.start = min(intervals[l].start,newInterval.start)</span><br><span class="line">                newInterval.end = max(intervals[l].end,newInterval.end)</span><br><span class="line">                intervals.pop(l)</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> l&lt;n<span class="number">-1</span> <span class="keyword">and</span> intervals[l+<span class="number">1</span>].start&lt;=newInterval.end:</span><br><span class="line">                newInterval.end = max(intervals[l+<span class="number">1</span>].end,newInterval.end)</span><br><span class="line">                newInterval.start = min(intervals[l+<span class="number">1</span>].start,newInterval.start)</span><br><span class="line">                intervals.pop(l+<span class="number">1</span>)</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        intervals.insert(l+<span class="number">1</span>,newInterval)</span><br><span class="line">        <span class="keyword">return</span> intervals</span><br></pre></td></tr></table></figure><h1 id="LeetCode-128-最长连续序列"><a href="#LeetCode-128-最长连续序列" class="headerlink" title="LeetCode 128 最长连续序列"></a>LeetCode 128 最长连续序列</h1><blockquote><p>给定一个未排序的整数数组，找出最长连续序列的长度。<br>要求算法的时间复杂度为 O(n)。</p></blockquote><p><code>哈希表</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_table = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            hash_table.add(i)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            j = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j <span class="keyword">in</span> hash_table:</span><br><span class="line">                hash_table.remove(j)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            j = i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> j <span class="keyword">in</span> hash_table:</span><br><span class="line">                hash_table.remove(j)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">            max_len = length <span class="keyword">if</span> length &gt; max_len <span class="keyword">else</span> max_len</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure></p><h1 id="LeetCode560-和为K的子数组"><a href="#LeetCode560-和为K的子数组" class="headerlink" title="LeetCode560. 和为K的子数组"></a>LeetCode560. 和为K的子数组</h1><blockquote><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。<br><code>哈希表</code></p></blockquote><hr><p>用一个哈希表记录从0开始到当前位置数组的累加和sum(nums[0:i])的值出现的次数，若在第i个位置的和为sum_，那么sum_-k曾经出现过的话，出现的位置j到i的连续子数组的和肯定为k</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        d = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        sum_,count_ = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum_ += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sum_ - k <span class="keyword">in</span> d:</span><br><span class="line">                count_ += d[sum_ - k]</span><br><span class="line">            <span class="keyword">if</span> sum_ <span class="keyword">in</span> d:</span><br><span class="line">                d[sum_] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[sum_] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count_</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-BFS</title>
      <link href="/2018/06/20/LeetCode-BFS/"/>
      <url>/2018/06/20/LeetCode-BFS/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode130-被围绕的区域"><a href="#LeetCode130-被围绕的区域" class="headerlink" title="LeetCode130. 被围绕的区域"></a>LeetCode130. 被围绕的区域</h1><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。<br>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。<br><strong>解释:</strong><br>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br><strong>示例:</strong><br>X X X X<br>X O O X<br>X X O X<br>X O X X<br>运行你的函数后，矩阵变为：<br>X X X X<br>X X X X<br>X X X X<br>X O X X</p><hr><p>只需找到边沿的O以及与它相邻的那些O，并标记好，其它的最终都填充为X</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(board)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        mat = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>,n<span class="number">-1</span>]:</span><br><span class="line">                self.bfs(board,mat,i,j,m,n)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,m<span class="number">-1</span>]:</span><br><span class="line">                self.bfs(board,mat,i,j,m,n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> mat[i][j]==<span class="number">0</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self,board,mat,i,j,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> board[i][j] == <span class="string">'O'</span> <span class="keyword">and</span> mat[i][j]==<span class="number">0</span>:</span><br><span class="line">            queue = []</span><br><span class="line">            queue.append((i,j))</span><br><span class="line">            mat[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                u,v = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=u&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=v+<span class="number">1</span>&lt;n <span class="keyword">and</span> board[u][v+<span class="number">1</span>] == <span class="string">'O'</span> <span class="keyword">and</span> mat[u][v+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                    queue.append((u,v+<span class="number">1</span>))</span><br><span class="line">                    mat[u][v+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=u&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=v<span class="number">-1</span>&lt;n <span class="keyword">and</span> board[u][v<span class="number">-1</span>] == <span class="string">'O'</span> <span class="keyword">and</span> mat[u][v<span class="number">-1</span>]==<span class="number">0</span>:</span><br><span class="line">                    queue.append((u,v<span class="number">-1</span>))</span><br><span class="line">                    mat[u][v<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=u+<span class="number">1</span>&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=v&lt;n <span class="keyword">and</span> board[u+<span class="number">1</span>][v] == <span class="string">'O'</span> <span class="keyword">and</span> mat[u+<span class="number">1</span>][v]==<span class="number">0</span>:</span><br><span class="line">                    queue.append((u+<span class="number">1</span>,v))</span><br><span class="line">                    mat[u+<span class="number">1</span>][v] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=u<span class="number">-1</span>&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=v&lt;n <span class="keyword">and</span> board[u<span class="number">-1</span>][v] == <span class="string">'O'</span> <span class="keyword">and</span> mat[u<span class="number">-1</span>][v]==<span class="number">0</span>:</span><br><span class="line">                    queue.append((u<span class="number">-1</span>,v))</span><br><span class="line">                    mat[u<span class="number">-1</span>][v] = <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-动态规划</title>
      <link href="/2018/06/20/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2018/06/20/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode91-解码方法"><a href="#LeetCode91-解码方法" class="headerlink" title="LeetCode91. 解码方法"></a>LeetCode91. 解码方法</h1><blockquote><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(s)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre,cur = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'0'</span>:</span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">2</span> <span class="keyword">or</span> <span class="keyword">not</span>(s[i<span class="number">-2</span>] == <span class="string">'1'</span> <span class="keyword">or</span> (s[i<span class="number">-2</span>]==<span class="string">'2'</span> <span class="keyword">and</span> int(s[i<span class="number">-1</span>])&lt;=<span class="number">6</span>)):</span><br><span class="line">                pre = <span class="number">0</span></span><br><span class="line">            pre,cur = cur,pre+cur</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode152-乘积最大子序列"><a href="#LeetCode152-乘积最大子序列" class="headerlink" title="LeetCode152 乘积最大子序列"></a>LeetCode152 乘积最大子序列</h1><blockquote><p>给定一个整数数组 nums， 找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res =nums[<span class="number">0</span>]</span><br><span class="line">        max_res,min_res = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                max_res = max(max_res*nums[i],nums[i])</span><br><span class="line">                min_res = min(min_res*nums[i],nums[i])</span><br><span class="line">            <span class="keyword">elif</span> nums[i]&lt;<span class="number">0</span>:</span><br><span class="line">                max_res,min_res = max(min_res*nums[i],nums[i]),min(max_res*nums[i],nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_res,min_res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            res = max(max_res,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode121-买卖股票的最佳时机"><a href="#LeetCode121-买卖股票的最佳时机" class="headerlink" title="LeetCode121. 买卖股票的最佳时机"></a>LeetCode121. 买卖股票的最佳时机</h1><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你<strong>最多只允许完成一笔交易</strong>（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n== <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        min_p= prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = max(res,prices[i]-min_p)</span><br><span class="line">            <span class="keyword">if</span> min_p&gt;prices[i]:</span><br><span class="line">                min_p = prices[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode122-买卖股票的最佳时机-II"><a href="#LeetCode122-买卖股票的最佳时机-II" class="headerlink" title="LeetCode122. 买卖股票的最佳时机 II"></a>LeetCode122. 买卖股票的最佳时机 II</h1><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以<strong>尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            diff = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                res += diff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode123-买卖股票的最佳时机-III"><a href="#LeetCode123-买卖股票的最佳时机-III" class="headerlink" title="LeetCode123. 买卖股票的最佳时机 III"></a>LeetCode123. 买卖股票的最佳时机 III</h1><blockquote><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你<strong>最多可以完成两笔交易</strong>。</p></blockquote><hr><p>f[i]表示[0:i]天交易的最大利润<br>g[i]表示[i:n-1]天交易的最大利润</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        f,g = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        valley = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            valley = min(valley,prices[i])</span><br><span class="line">            f[i] = max(f[i<span class="number">-1</span>],prices[i]-valley)</span><br><span class="line">        peak = prices[n<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            peak = max(peak,prices[i])</span><br><span class="line">            g[i] = max(g[i+<span class="number">1</span>],peak-prices[i])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = max(res,f[i]+g[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode714-买卖股票的最佳时机含手续费"><a href="#LeetCode714-买卖股票的最佳时机含手续费" class="headerlink" title="LeetCode714. 买卖股票的最佳时机含手续费"></a>LeetCode714. 买卖股票的最佳时机含手续费</h1><blockquote><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。</p></blockquote><hr><p>sold[i]:表示第i天卖出股票所能获得的最大利润，那么，它的值应该等于前一天手里有股票时所拥有的最大利润加上今天卖出时获得的利润，和前一天手里没有保留股票，而是卖出股票时有的最大利润的较大者<br>hold[i]:表示第i天保留股票时所能获得的最大利润，它的值为前一天卖出了股票所拥有的最大利润减去今天买进股票的价格，和前一天保留了股票的较大者。</p><p>sold[i] = max(sold[i-1],hold[i-1]+prices[i]-fee)<br>hold[i] = max(sold[i-1]-prices[i],hold[i-1])</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices, fee)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        sold,hold = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        hold[<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            sold[i] = max(hold[i<span class="number">-1</span>]+prices[i]-fee,sold[i<span class="number">-1</span>])</span><br><span class="line">            hold[i] = max(sold[i<span class="number">-1</span>]-prices[i],hold[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> sold[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="LeetCode132-分割回文串-II"><a href="#LeetCode132-分割回文串-II" class="headerlink" title="LeetCode132. 分割回文串 II"></a>LeetCode132. 分割回文串 II</h1><blockquote><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回符合要求的最少分割次数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lass Solution(object):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [n-i<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        p = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># p[n-1][n]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span>(j-i&lt;=<span class="number">1</span> <span class="keyword">or</span> p[i+<span class="number">1</span>][j<span class="number">-1</span>] ==<span class="number">1</span>):</span><br><span class="line">                    p[i][j] = <span class="number">1</span></span><br><span class="line">                    f[i] = min(f[i],<span class="number">1</span>+f[j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="LeetCode139-单词拆分"><a href="#LeetCode139-单词拆分" class="headerlink" title="LeetCode139. 单词拆分"></a>LeetCode139. 单词拆分</h1><blockquote><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br><strong>说明：</strong></p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [<span class="keyword">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                f[i] = f[i] <span class="keyword">or</span> (f[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict)</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><h1 id="LeetCode338-比特位计数"><a href="#LeetCode338-比特位计数" class="headerlink" title="LeetCode338. 比特位计数"></a>LeetCode338. 比特位计数</h1><blockquote><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><hr><p>dp[i] = dp[i-cycle]+1,其中cycle=0,2,4,8,16…，<br>比如，3的二进制：11，此时cycle为2，dp[3] = dp[3-2]+1</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(num+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> num==<span class="number">0</span>:<span class="keyword">return</span> dp</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,num+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span>**dp[i<span class="number">-1</span>]:</span><br><span class="line">                cycle = i</span><br><span class="line">            dp[i] = dp[i-cycle]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure><p>#LeetCode368. 最大整除子集</p><blockquote><p>给出一个由无重复的正整数组成的集合, 找出其中最大的整除子集, 子集中任意一对 (Si, Sj) 都要满足: Si % Sj = 0 或 Sj % Si = 0。<br>如果有多个目标子集，返回其中任何一个均可。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        parent = [<span class="number">0</span>]*n</span><br><span class="line">        mx,mx_idx = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">                <span class="keyword">if</span> nums[j]%nums[i]==<span class="number">0</span> <span class="keyword">and</span> dp[i]&lt;dp[j]+<span class="number">1</span>:</span><br><span class="line">                    dp[i] = dp[j]+<span class="number">1</span></span><br><span class="line">                    parent[i] = j</span><br><span class="line">                    <span class="keyword">if</span> mx&lt;dp[i]:</span><br><span class="line">                        mx = dp[i]</span><br><span class="line">                        mx_idx = i</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mx):</span><br><span class="line">            res.append(nums[mx_idx])</span><br><span class="line">            mx_idx = parent[mx_idx]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode72-编辑距离"><a href="#LeetCode72-编辑距离" class="headerlink" title="LeetCode72. 编辑距离"></a>LeetCode72. 编辑距离</h1><blockquote><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(word1),len(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h1 id="LeetCode97-交错字符串"><a href="#LeetCode97-交错字符串" class="headerlink" title="LeetCode97. 交错字符串"></a>LeetCode97. 交错字符串</h1><blockquote><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :type s3: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(s1),len(s2)</span><br><span class="line">        <span class="keyword">if</span> m+n != len(s3): <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        l = [[<span class="keyword">False</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        l[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> s1[i]==s3[i] <span class="keyword">and</span> l[i][<span class="number">0</span>]:</span><br><span class="line">                l[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> s2[i]==s3[i] <span class="keyword">and</span> l[<span class="number">0</span>][i]:</span><br><span class="line">                l[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                l[i+<span class="number">1</span>][j+<span class="number">1</span>] = (s1[i]==s3[i+j+<span class="number">1</span>] <span class="keyword">and</span> l[i][j+<span class="number">1</span>]) <span class="keyword">or</span> (s2[j] == s3[i+j+<span class="number">1</span>] <span class="keyword">and</span> l[i+<span class="number">1</span>][j])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> l[m][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-排列组合题</title>
      <link href="/2018/06/20/LeetCode-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%A2%98/"/>
      <url>/2018/06/20/LeetCode-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode31-下一个排列"><a href="#LeetCode31-下一个排列" class="headerlink" title="LeetCode31 下一个排列"></a>LeetCode31 下一个排列</h1><blockquote><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>必须原地修改，只允许使用额外常数空间。</p></blockquote><hr><p><strong>思路：</strong></p><ol><li>从右向左找到第一个开始降序的数字a</li><li>从右向左找到第一个比a大的数字b</li><li>交换a和b</li><li>反转a后面的数组</li></ol><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pivot = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j]&lt;nums[j+<span class="number">1</span>]:</span><br><span class="line">                pivot = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> pivot != <span class="number">-1</span>:</span><br><span class="line">            j = n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;pivot:</span><br><span class="line">                <span class="keyword">if</span> nums[j]&gt;nums[pivot]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[pivot],nums[j] = nums[j],nums[pivot]</span><br><span class="line">        </span><br><span class="line">        r = n<span class="number">-1</span></span><br><span class="line">        j = pivot+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r&gt;j:</span><br><span class="line">            nums[r],nums[j] = nums[j],nums[r]</span><br><span class="line">            r -=<span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode39-组合总和"><a href="#LeetCode39-组合总和" class="headerlink" title="LeetCode39. 组合总和"></a>LeetCode39. 组合总和</h1><blockquote><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        self.dfs(candidates,<span class="number">0</span>,res,[],target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,candidates,start,res,cur,target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target&lt;<span class="number">0</span>:<span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="number">0</span>==target:</span><br><span class="line">            res.append(cur)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                self.dfs(candidates,i,res,cur+[candidates[i]],target-candidates[i])</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode40-组合总和-II-不能重复使用同一个数"><a href="#LeetCode40-组合总和-II-不能重复使用同一个数" class="headerlink" title="LeetCode40. 组合总和 II(不能重复使用同一个数)"></a>LeetCode40. 组合总和 II(不能重复使用同一个数)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        self.dfs(candidates,<span class="number">-1</span>,res,[],target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,candidates,start,res,cur,target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target&lt;<span class="number">0</span>:<span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> target==<span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start+<span class="number">1</span>,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;start+<span class="number">1</span> <span class="keyword">and</span> candidates[i]==candidates[i<span class="number">-1</span>]:<span class="keyword">continue</span></span><br><span class="line">                self.dfs(candidates,i,res,cur+[candidates[i]],target-candidates[i])</span><br></pre></td></tr></table></figure><h1 id="LeetCode46-全排列"><a href="#LeetCode46-全排列" class="headerlink" title="LeetCode46. 全排列"></a>LeetCode46. 全排列</h1><blockquote><p>给定一个<strong>没有重复数字</strong>的序列，返回其所有可能的全排列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        self.dfs(nums,res,cur,n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,nums,res,cur,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">        <span class="keyword">elif</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                self.dfs(nums[:i]+nums[i+<span class="number">1</span>:],res,cur+[nums[i]],n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h1 id="LeetCode47-全排列-II-有重复数字"><a href="#LeetCode47-全排列-II-有重复数字" class="headerlink" title="LeetCode47. 全排列 II(有重复数字)"></a>LeetCode47. 全排列 II(有重复数字)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        self.dfs(nums,res,cur,n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,nums,res,cur,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">        <span class="keyword">elif</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&lt;len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[i]==nums[i+<span class="number">1</span>]:<span class="keyword">continue</span></span><br><span class="line">                self.dfs(nums[:i]+nums[i+<span class="number">1</span>:],res,cur+[nums[i]],n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h1 id="LeetCode77-组合"><a href="#LeetCode77-组合" class="headerlink" title="LeetCode77. 组合"></a>LeetCode77. 组合</h1><blockquote><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        self.dfs(n,k,cur,<span class="number">0</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,n,k,cur,start,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start+<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                self.dfs(n,k<span class="number">-1</span>,cur+[i],i,res)</span><br></pre></td></tr></table></figure><h1 id="LeetCode78-子集"><a href="#LeetCode78-子集" class="headerlink" title="LeetCode78. 子集"></a>LeetCode78. 子集</h1><blockquote><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        self.dfs(nums,cur,<span class="number">0</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,nums,cur,start,res)</span>:</span></span><br><span class="line">        res.append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(nums)):</span><br><span class="line">            self.dfs(nums,cur+[nums[i]],i+<span class="number">1</span>,res)</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode90-子集-II"><a href="#LeetCode90-子集-II" class="headerlink" title="LeetCode90. 子集 II"></a>LeetCode90. 子集 II</h1><blockquote><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        self.dfs(nums,res,cur)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,nums,res,cur)</span>:</span></span><br><span class="line">        res.append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(nums[i+<span class="number">1</span>:],res,cur+[nums[i]])</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-贪心算法</title>
      <link href="/2018/06/20/LeetCode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2018/06/20/LeetCode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode55-跳跃游戏"><a href="#LeetCode55-跳跃游戏" class="headerlink" title="LeetCode55. 跳跃游戏"></a>LeetCode55. 跳跃游戏</h1><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">0</span>]*len(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> dp[i<span class="number">-1</span>]&gt;=i:</span><br><span class="line">                dp[i] = max(dp[i<span class="number">-1</span>],nums[i]+i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(nums)<span class="number">-1</span>] &gt;= len(nums)<span class="number">-1</span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode-45-跳跃游戏-II"><a href="#LeetCode-45-跳跃游戏-II" class="headerlink" title="LeetCode 45. 跳跃游戏 II"></a>LeetCode 45. 跳跃游戏 II</h1><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        last,cur = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            cur = max(cur,i+nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == last:</span><br><span class="line">                last = cur</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur &gt; n<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode134-加油站"><a href="#LeetCode134-加油站" class="headerlink" title="LeetCode134. 加油站"></a>LeetCode134. 加油站</h1><blockquote><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<br><strong>说明:</strong> </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sum_,total = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            total += gas[i] - cost[i]</span><br><span class="line">            sum_ += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> sum_&lt;<span class="number">0</span>:</span><br><span class="line">                start = i+<span class="number">1</span></span><br><span class="line">                sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> total&lt;<span class="number">0</span> <span class="keyword">else</span> start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-栈和队列</title>
      <link href="/2018/06/20/LeetCode-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2018/06/20/LeetCode-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode84-柱状图中最大的矩形"><a href="#LeetCode84-柱状图中最大的矩形" class="headerlink" title="LeetCode84. 柱状图中最大的矩形"></a>LeetCode84. 柱状图中最大的矩形</h1><blockquote><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><code>递增栈</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type heights: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(heights):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> heights[stack[<span class="number">-1</span>]]&lt;=heights[i]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line"><span class="comment"># 此时的栈顶元素的位置是从cur开始向左数，第一个小于heights[cur]的位置，</span></span><br><span class="line"><span class="comment"># i是从cur开始向右数，第一个小于heights[cur]的位置</span></span><br><span class="line">                width = i <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> i-stack[<span class="number">-1</span>]<span class="number">-1</span></span><br><span class="line">                res = max(res,heights[cur]*width)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode85-最大矩形"><a href="#LeetCode85-最大矩形" class="headerlink" title="LeetCode85. 最大矩形"></a>LeetCode85. 最大矩形</h1><blockquote><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br><code>递增栈</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res  = <span class="number">0</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        height = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            stack = []</span><br><span class="line">            com = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; n+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> com:</span><br><span class="line">                    height[j] = <span class="number">1</span>+height[j] <span class="keyword">if</span> j&lt;n <span class="keyword">and</span> matrix[i][j]==<span class="string">'1'</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    com = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> height[stack[<span class="number">-1</span>]]&lt;=height[j]:</span><br><span class="line">                    stack.append(j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur = stack.pop()</span><br><span class="line">                    width = j <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> j - stack[<span class="number">-1</span>]<span class="number">-1</span></span><br><span class="line">                    res = max(res,height[cur]*width)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                com = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="leetcode150-逆波兰数"><a href="#leetcode150-逆波兰数" class="headerlink" title="leetcode150 逆波兰数"></a>leetcode150 逆波兰数</h1><blockquote><p>代码在leetcode.com过了，leetcode-cn.com没过。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type tokens: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        oper = [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>]</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> oper:</span><br><span class="line">                stack.append(token)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 = int(stack.pop())</span><br><span class="line">                p1 = int(stack.pop())</span><br><span class="line">                <span class="keyword">if</span> token == <span class="string">'+'</span>:</span><br><span class="line">                    res = p1+p2</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">'-'</span>:</span><br><span class="line">                    res = p1-p2</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">'*'</span>:</span><br><span class="line">                    res = p1*p2</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = int(p1/p2)</span><br><span class="line">                stack.append(str(res))</span><br><span class="line">        res = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode224-基本计算器"><a href="#LeetCode224-基本计算器" class="headerlink" title="LeetCode224. 基本计算器"></a>LeetCode224. 基本计算器</h1><blockquote><p>实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格  。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p = self.infix_2_postfix(s)</span><br><span class="line">        <span class="keyword">return</span> self.evalRPN(p)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">infix_2_postfix</span><span class="params">(self,s)</span>:</span></span><br><span class="line">    <span class="comment"># 前缀表达式转后缀表达式</span></span><br><span class="line">        s = s+<span class="string">'#'</span></span><br><span class="line">        <span class="comment"># 定义运算符栈内和栈外的优先级</span></span><br><span class="line">        isp = &#123;<span class="string">'('</span>:<span class="number">1</span>,<span class="string">"*"</span>:<span class="number">5</span>,<span class="string">"/"</span>:<span class="number">5</span>,<span class="string">'%'</span>:<span class="number">5</span>,<span class="string">'+'</span>:<span class="number">3</span>,<span class="string">'-'</span>:<span class="number">3</span>,<span class="string">')'</span>:<span class="number">6</span>,<span class="string">'#'</span>:<span class="number">0</span>&#125;</span><br><span class="line">        icp = &#123;<span class="string">'('</span>:<span class="number">6</span>,<span class="string">"*"</span>:<span class="number">4</span>,<span class="string">"/"</span>:<span class="number">4</span>,<span class="string">'%'</span>:<span class="number">4</span>,<span class="string">'+'</span>:<span class="number">2</span>,<span class="string">'-'</span>:<span class="number">2</span>,<span class="string">')'</span>:<span class="number">1</span>,<span class="string">'#'</span>:<span class="number">0</span>&#125;</span><br><span class="line">        stack, res =  [<span class="string">'#'</span>],[]</span><br><span class="line">        i,num,is_num = <span class="number">0</span>,<span class="number">0</span>,<span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">                num = num*<span class="number">10</span> + int(s[i])</span><br><span class="line">                is_num = <span class="keyword">True</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> is_num:</span><br><span class="line">                    res.append(str(num))</span><br><span class="line">                    num = <span class="number">0</span></span><br><span class="line">                    is_num = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> icp[s[i]]&gt;isp[stack[<span class="number">-1</span>]]:</span><br><span class="line">                    stack.append(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> icp[s[i]]&lt;isp[stack[<span class="number">-1</span>]]:</span><br><span class="line">                    res.append(stack.pop())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack.pop() == <span class="string">'('</span>:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">    <span class="comment"># 后缀表达（逆波兰数）计算结果</span></span><br><span class="line">        stack = []</span><br><span class="line">        oper = [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>]</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> oper:</span><br><span class="line">                stack.append(token)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 = int(stack.pop())</span><br><span class="line">                p1 = int(stack.pop())</span><br><span class="line">                <span class="keyword">if</span> token == <span class="string">'+'</span>:</span><br><span class="line">                    res = p1+p2</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">'-'</span>:</span><br><span class="line">                    res = p1-p2</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">'*'</span>:</span><br><span class="line">                    res = p1*p2</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = int(p1/p2)</span><br><span class="line">                stack.append(str(res))</span><br><span class="line">        res = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode32-最长有效括号"><a href="#LeetCode32-最长有效括号" class="headerlink" title="LeetCode32 最长有效括号"></a>LeetCode32 最长有效括号</h1><blockquote><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    res = max(res,i-start+<span class="number">1</span>) <span class="keyword">if</span> len(stack) == <span class="number">0</span> <span class="keyword">else</span> max(res,i - stack[<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-TopK问题</title>
      <link href="/2018/06/20/LeetCode-Topk%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/20/LeetCode-Topk%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode4-两个排序数组的中位数"><a href="#Leetcode4-两个排序数组的中位数" class="headerlink" title="Leetcode4 两个排序数组的中位数"></a>Leetcode4 两个排序数组的中位数</h1><blockquote><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。 请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。<br><code>二分搜索</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(nums1),len(nums2)</span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.find_kth(nums1,<span class="number">0</span>,m<span class="number">-1</span>,nums2,<span class="number">0</span>,n<span class="number">-1</span>,(m+n)&gt;&gt;<span class="number">1</span>) + self.find_kth(nums1,<span class="number">0</span>,m<span class="number">-1</span>,nums2,<span class="number">0</span>,n<span class="number">-1</span>,((m+n)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>))/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth(nums1,<span class="number">0</span>,m<span class="number">-1</span>,nums2,<span class="number">0</span>,n<span class="number">-1</span>,((m+n)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_kth</span><span class="params">(self,nums1,b1,e1,nums2,b2,e2,k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        nums1,nums2:两个数组</span></span><br><span class="line"><span class="string">        b1,e1,b2,e2:数组1、2开始和结束的位置</span></span><br><span class="line"><span class="string">        k:第k大</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = e1-b1+<span class="number">1</span>, e2-b2+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> m&gt;n:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth(nums2,b2,e2,nums1,b1,e1,k)</span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums2[b2+k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[b1],nums2[b2])</span><br><span class="line">        ia = min(k&gt;&gt;<span class="number">1</span>,m)</span><br><span class="line">        ib = k - ia</span><br><span class="line">        <span class="keyword">if</span> nums1[b1+ia<span class="number">-1</span>] &lt; nums2[b2+ib<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth(nums1,b1+ia,e1,nums2,b2,e2,k-ia)</span><br><span class="line">        <span class="keyword">elif</span> nums1[b1+ia<span class="number">-1</span>]&gt;nums2[b2+ib<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth(nums1,b1,e1,nums2,b2+ib,e2,k-ib)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[b1+ia<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="Leetcode378-在行和列都是单调递增的数组中找出第k小的元素。"><a href="#Leetcode378-在行和列都是单调递增的数组中找出第k小的元素。" class="headerlink" title="Leetcode378 在行和列都是单调递增的数组中找出第k小的元素。"></a>Leetcode378 在行和列都是单调递增的数组中找出第k小的元素。</h1><p><code>二分搜索</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        left,right = matrix[<span class="number">0</span>][<span class="number">0</span>],matrix[n<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            counts = self.search_less_count(matrix,mid)</span><br><span class="line">            <span class="keyword">if</span> counts &lt;k:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_less_count</span><span class="params">(self,matrix,target)</span>:</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        i,j = n<span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">        counts = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j]&lt;=target:</span><br><span class="line">                counts += i+<span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-链表</title>
      <link href="/2018/06/20/LeetCode-%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/06/20/LeetCode-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h1><p>节点类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line"><span class="comment">#         使用一个辅助节点指向头结点</span></span><br><span class="line">        pstart = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pstart.next = head</span><br><span class="line">        pend = head</span><br><span class="line">        p = head.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            temp = pstart.next</span><br><span class="line">            pre = pstart</span><br><span class="line"><span class="comment">#             找到待插入的位置，需要保留两个节点地址</span></span><br><span class="line">            <span class="keyword">while</span> temp != p <span class="keyword">and</span> temp.val&lt;p.val:</span><br><span class="line">                pre = temp</span><br><span class="line">                temp = temp.next</span><br><span class="line">            <span class="keyword">if</span> temp == p:pend = p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pend.next = p.next</span><br><span class="line">                p.next = temp</span><br><span class="line">                pre.next = p</span><br><span class="line">            p = pend.next</span><br><span class="line">        head = pstart.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line"><span class="comment">#         使用一个辅助节点指向头结点</span></span><br><span class="line">        pstart = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pstart.next = head</span><br><span class="line">        pend = pstart</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> pend.next:</span><br><span class="line">            p,min_p = pend.next,pend.next</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                <span class="keyword">if</span> p.val&lt;min_p.val:</span><br><span class="line">                    min_p = p</span><br><span class="line">                p = p.next</span><br><span class="line">            pend.next.val,min_p.val = min_p.val,pend.next.val</span><br><span class="line">            pend = pend.next</span><br><span class="line">        head = pstart.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bubbleSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        p = <span class="keyword">None</span></span><br><span class="line">        is_change = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> p != head.next <span class="keyword">and</span> is_change:</span><br><span class="line">            q = head</span><br><span class="line">            is_change = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> q.next <span class="keyword">and</span> q.next != p:</span><br><span class="line">                <span class="keyword">if</span> q.val &gt; q.next.val:</span><br><span class="line">                    q.val,q.next.val = q.next.val,q.val</span><br><span class="line">                    is_change = <span class="keyword">True</span></span><br><span class="line">                q = q.next</span><br><span class="line">            p = q</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:<span class="keyword">return</span> head</span><br><span class="line">        self.quick_sort_list(head,<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort_list</span><span class="params">(self,head,tail)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head != tail <span class="keyword">and</span> head.next != tail:</span><br><span class="line">            m = self.partition(head,tail)</span><br><span class="line">            self.quick_sort_list(head,m)</span><br><span class="line">            self.quick_sort_list(m.next,tail)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self,p,r)</span>:</span></span><br><span class="line">        pivot = p</span><br><span class="line">        q = p</span><br><span class="line">        p = p.next</span><br><span class="line">        <span class="keyword">while</span> p != r:</span><br><span class="line">            <span class="keyword">if</span> p.val&lt;pivot.val:</span><br><span class="line">                q = q.next</span><br><span class="line">                q.val,p.val = p.val,q.val</span><br><span class="line">                </span><br><span class="line">            p = p.next</span><br><span class="line">        pivot.val,q.val = q.val,pivot.val</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure><h1 id="LeetCode23-合并K个有序链表"><a href="#LeetCode23-合并K个有序链表" class="headerlink" title="LeetCode23 合并K个有序链表"></a>LeetCode23 合并K个有序链表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        K = len(lists)</span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> K&gt;<span class="number">1</span>:</span><br><span class="line">            n = (K+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(K&gt;&gt;<span class="number">1</span>):</span><br><span class="line">                lists[i] = self.merge_two_list(lists[i],lists[i+n])</span><br><span class="line">            K = n</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_two_list</span><span class="params">(self,l1,l2)</span>:</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.next = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            cur.next = l2</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h1 id="LeetCode82-删除排序链表中的重复元素"><a href="#LeetCode82-删除排序链表中的重复元素" class="headerlink" title="LeetCode82 删除排序链表中的重复元素"></a>LeetCode82 删除排序链表中的重复元素</h1><blockquote><p>类似与集合操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = head</span><br><span class="line">        cur = head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> pre.val == cur.val:</span><br><span class="line">                </span><br><span class="line">                cur = cur.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            pre.next = cur</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        pre.next = cur</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h1 id="LeetCode83-删除排序链表中的重复元素II"><a href="#LeetCode83-删除排序链表中的重复元素II" class="headerlink" title="LeetCode83 删除排序链表中的重复元素II"></a>LeetCode83 删除排序链表中的重复元素II</h1><blockquote><p>只要有重复的，重复的都要删除，不保留</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        h = ListNode(<span class="number">-1</span>)</span><br><span class="line">        h.next = head</span><br><span class="line">        pre = h</span><br><span class="line">        cur = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            du = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.next.val == cur.val:</span><br><span class="line">                du = <span class="keyword">True</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> du:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            pre.next = cur</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        pre.next = cur</span><br><span class="line">        <span class="keyword">return</span> h.next</span><br></pre></td></tr></table></figure><h1 id="LeetCode138-复制带随机指针的链表"><a href="#LeetCode138-复制带随机指针的链表" class="headerlink" title="LeetCode138. 复制带随机指针的链表"></a>LeetCode138. 复制带随机指针的链表</h1><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。<br>要求返回这个链表的深度拷贝。</p></blockquote><hr><p>分三步进行：</p><ol><li>生成每个节点的复制，并将其插入后面</li><li>再次遍历新的链表，若当前节点有随机指针，那么复制节点的随机指针为当前节点随机指针指向节点的下一个节点</li><li>断开</li></ol><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class RandomListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#         self.random = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: RandomListNode</span></span><br><span class="line"><span class="string">        :rtype: RandomListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            temp = RandomListNode(p.label)</span><br><span class="line">            temp.next = p.next</span><br><span class="line">            p.next = temp</span><br><span class="line">            p = temp.next</span><br><span class="line">        p1,p2 = head,head.next</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            <span class="keyword">if</span> p1.random:</span><br><span class="line">                p2.random = p1.random.next</span><br><span class="line">            </span><br><span class="line">            p1 = p2.next</span><br><span class="line">            <span class="keyword">if</span> p1:</span><br><span class="line">                p2 = p1.next</span><br><span class="line">            </span><br><span class="line">        p1,p2 = head,head.next</span><br><span class="line">        res = head.next</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            p1.next = p2.next</span><br><span class="line">            <span class="keyword">if</span> p1:</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> p1:</span><br><span class="line">                p2.next = p1.next</span><br><span class="line">                p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode141-环形链表"><a href="#LeetCode141-环形链表" class="headerlink" title="LeetCode141. 环形链表"></a>LeetCode141. 环形链表</h1><blockquote><p>给定一个链表，判断链表中是否有环。<br><code>快慢指针</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        p1,p2 = head,head</span><br><span class="line">        <span class="keyword">while</span> p2 <span class="keyword">and</span> p1:</span><br><span class="line">            <span class="keyword">if</span> p2.next <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode142-环形链表-II"><a href="#LeetCode142-环形链表-II" class="headerlink" title="LeetCode142. 环形链表 II"></a>LeetCode142. 环形链表 II</h1><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        p1,p2 = head,head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p2.next <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> p2.next.next <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            </span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        p2 = p2.next</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p2 = p2.next</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        p1,p2 = head,head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            p2 = p2.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-字符串</title>
      <link href="/2018/06/20/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/06/20/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode3-无重复字符的最长子串"><a href="#LeetCode3-无重复字符的最长子串" class="headerlink" title="LeetCode3 无重复字符的最长子串"></a>LeetCode3 无重复字符的最长子串</h1><p><code>哈希表</code>，<code>双指针</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> : <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        l, max_l, hash_table[s[<span class="number">0</span>]] = <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> hash_table <span class="keyword">or</span> i - l &gt; hash_table[s[i]]:</span><br><span class="line">                l = l + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = i - hash_table[s[i]]</span><br><span class="line">            max_l = l <span class="keyword">if</span> l&gt;max_l <span class="keyword">else</span> max_l</span><br><span class="line">            hash_table[s[i]] = i</span><br><span class="line">        <span class="keyword">return</span> max_l</span><br></pre></td></tr></table></figure></p><h1 id="LeetCode5-最长回文字符串"><a href="#LeetCode5-最长回文字符串" class="headerlink" title="LeetCode5 最长回文字符串"></a>LeetCode5 最长回文字符串</h1><p><code>回文</code>，<code>马拉车算法</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ss = <span class="string">'#'</span>.join(s)</span><br><span class="line">        ss = <span class="string">'$#'</span> + ss + <span class="string">'#@'</span></span><br><span class="line">        n = len(ss)</span><br><span class="line">        p = [<span class="number">1</span>]*n</span><br><span class="line">        lc,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        max_center,max_r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line">            p[i] = min(p[<span class="number">2</span>*lc-i],right-i) <span class="keyword">if</span> right-i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(ss[i+p[i]] == ss[i-p[i]]):</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i+p[i] &gt; right:</span><br><span class="line">                lc = i</span><br><span class="line">                right = i+p[i] <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> max_r &lt; p[i]:</span><br><span class="line">                max_center = i</span><br><span class="line">                max_r = p[i]</span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ss[max_center-max_r+<span class="number">1</span>:max_center+max_r<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="string">'#'</span>:</span><br><span class="line">                s = s + i</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></p><h1 id="LeetCode10-正则表达式匹配"><a href="#LeetCode10-正则表达式匹配" class="headerlink" title="LeetCode10. 正则表达式匹配"></a>LeetCode10. 正则表达式匹配</h1><blockquote><p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘* ‘ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符。</li><li>‘* ‘ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。<br>说明:</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># m,n = len(s),len(p)</span></span><br><span class="line">        s = s+<span class="string">'$'</span></span><br><span class="line">        p = p+<span class="string">'$'</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.is_match_core(s,p,i,j)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_match_core</span><span class="params">(self,s,p,i,j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p[j] == <span class="string">'$'</span>:</span><br><span class="line">            <span class="keyword">return</span> s[i] == <span class="string">'$'</span></span><br><span class="line">        <span class="keyword">if</span> p[j+<span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">if</span> s[i] == p[j] <span class="keyword">or</span> (p[j]==<span class="string">'.'</span> <span class="keyword">and</span> s[i]!=<span class="string">'$'</span>):</span><br><span class="line">                <span class="keyword">return</span> self.is_match_core(s,p,i+<span class="number">1</span>,j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> p[j] == s[i] <span class="keyword">or</span> (p[j]==<span class="string">'.'</span> <span class="keyword">and</span> s[i]!=<span class="string">'$'</span>):</span><br><span class="line">                <span class="keyword">if</span> self.is_match_core(s,p,i,j+<span class="number">2</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.is_match_core(s,p,i,j+<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="LeetCode43-字符串相乘"><a href="#LeetCode43-字符串相乘" class="headerlink" title="LeetCode43. 字符串相乘"></a>LeetCode43. 字符串相乘</h1><blockquote><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num1: str</span></span><br><span class="line"><span class="string">        :type num2: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(num1),len(num2)</span><br><span class="line">        arr = [<span class="number">0</span>]*(m+n)</span><br><span class="line">        <span class="comment"># carray = 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            carray = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                product = int(num1[i])*int(num2[j]) + carray + arr[i+j+<span class="number">1</span>]</span><br><span class="line">                arr[i+j+<span class="number">1</span>] = product%<span class="number">10</span></span><br><span class="line">                carray = int(product/<span class="number">10</span>)</span><br><span class="line">            arr[i+j] = carray</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m+n<span class="number">-1</span> <span class="keyword">and</span> arr[i] == <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        arr = list(map(str,arr))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(arr[i:])</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode44-通配符匹配"><a href="#LeetCode44-通配符匹配" class="headerlink" title="LeetCode44 通配符匹配"></a>LeetCode44 通配符匹配</h1><blockquote><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><ul><li>‘?’ 可以匹配任何单个字符。</li><li>‘ *’ 可以匹配任意字符串（包括空字符串）。<br>说明:</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li></ul></blockquote><hr><ol><li>若当前比较的两个字符相同，或者p[j]=’?’,两者都往下走</li><li>若p[j]==’<em>‘,这时候先保留当前i和j的位置，即为sstar,pstar,同时j往下走一步（先尝试让 </em> 匹配空格），若接下来的步骤都能够匹配就继续下去，否则，让i=sstar+1(匹配一个字符，还不行，匹配两个字符，继续下去，直到s扫描完或者第一个字符匹配成功),同时记录下sstar,以防后面即使出现s[i]==p[j]匹配成功，但其实这样有可能后面的字符不满足，多以还需尝试将这个字符也略过的情况。</li></ol><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(s),len(p)</span><br><span class="line">        <span class="comment"># ‘#’作为字符串结束的标识</span></span><br><span class="line">        s,p = s+<span class="string">'#'</span>,p+<span class="string">'#'</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        pstar,sstar = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m:</span><br><span class="line">            <span class="keyword">if</span> s[i]==p[j] <span class="keyword">or</span> p[j] == <span class="string">"?"</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="comment"># 略过多个*连续的情况</span></span><br><span class="line">                <span class="keyword">while</span> p[j]==<span class="string">'*'</span>:</span><br><span class="line">                    pstar,j = j,j+<span class="number">1</span></span><br><span class="line">                sstar = i</span><br><span class="line">            <span class="keyword">elif</span> pstar&gt;<span class="number">-1</span>:</span><br><span class="line">                j = pstar+<span class="number">1</span></span><br><span class="line">                sstar,i = sstar+<span class="number">1</span>,sstar</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> p[j]==<span class="string">'*'</span>: j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若能够匹配，两个字符串都应该走到尾了。</span></span><br><span class="line">        <span class="keyword">return</span> s[i] == p[j]</span><br></pre></td></tr></table></figure><h1 id="LeetCode93-复原IP地址"><a href="#LeetCode93-复原IP地址" class="headerlink" title="LeetCode93. 复原IP地址"></a>LeetCode93. 复原IP地址</h1><blockquote><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br><strong>示例：</strong><br>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ip,res = <span class="string">''</span>,[]</span><br><span class="line">        self.dfs(s,<span class="number">0</span>,<span class="number">0</span>,ip,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,s,start,step,ip,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(s) <span class="keyword">and</span> step == <span class="number">4</span>:</span><br><span class="line">            res.append(ip[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> len(s) - start  &gt; (<span class="number">4</span>-step)*<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> len(s) - start  &lt; <span class="number">4</span>-step:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> i&lt;start+<span class="number">3</span>:</span><br><span class="line">            num = num*<span class="number">10</span> + int(s[i])</span><br><span class="line">            <span class="keyword">if</span> num &lt;= <span class="number">255</span>:</span><br><span class="line">                ip += s[i]</span><br><span class="line">                self.dfs(s,i+<span class="number">1</span>,step+<span class="number">1</span>,ip+<span class="string">'.'</span>,res)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-奇技淫巧题</title>
      <link href="/2018/06/20/LeetCode-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E9%A2%98/"/>
      <url>/2018/06/20/LeetCode-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode42-接雨水"><a href="#LeetCode42-接雨水" class="headerlink" title="LeetCode42 接雨水"></a>LeetCode42 接雨水</h1><blockquote><p><strong>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</strong><br>对于每个柱子，找到它左右两边最高的柱子，它所能容纳的雨水为min(max_left, max_- right) - height,时间空间复杂度都为O(n),</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(height)</span><br><span class="line">        max_left,max_right = [<span class="number">0</span>]*m,[<span class="number">0</span>]*m</span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> l&lt;height[i]:</span><br><span class="line">                l = height[i]</span><br><span class="line">            max_left[i] = l</span><br><span class="line">            <span class="keyword">if</span> r&lt;height[m<span class="number">-1</span>-i]:</span><br><span class="line">                r = height[m<span class="number">-1</span>-i]</span><br><span class="line">            max_right[m<span class="number">-1</span>-i] = r</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            res += min(max_left[i],max_right[i])-height[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode41-缺失的第一个正数"><a href="#LeetCode41-缺失的第一个正数" class="headerlink" title="LeetCode41 缺失的第一个正数"></a>LeetCode41 缺失的第一个正数</h1><blockquote><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p></blockquote><hr><blockquote><p><strong>思路</strong><br>举个例子:最小的正数有可能是1,2,3,…..,最大是n+1,遍历数组，假设1出现了，就将1放到nums[0],2出现就放在nums[1]，依次类推，等遍历完这次数组，“正确的数字都放到了正确的位置”，所以，再次遍历数组，找出第一个数字与位置不对应的”位置”。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i]&lt;=<span class="number">0</span> <span class="keyword">or</span> nums[i]&gt;len(nums) <span class="keyword">or</span> nums[i] == nums[nums[i]<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j = nums[i]</span><br><span class="line">                nums[i],nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>],nums[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode442-数组中重复的数据"><a href="#LeetCode442-数组中重复的数据" class="headerlink" title="LeetCode442. 数组中重复的数据"></a>LeetCode442. 数组中重复的数据</h1><blockquote><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。找到所有出现两次的元素。<br>你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</p></blockquote><hr><p>把“正确”的数放到“正确”的位置，有重复的数字将在“错误的位置”，最后找到这样“错误的”数。</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            idx = nums[i]<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[idx] != nums[i]:</span><br><span class="line">                nums[idx],nums[i] = nums[i],nums[idx]</span><br><span class="line">            <span class="keyword">else</span>: i += <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode448-找到所有数组中消失的数字"><a href="#LeetCode448-找到所有数组中消失的数字" class="headerlink" title="LeetCode448. 找到所有数组中消失的数字"></a>LeetCode448. 找到所有数组中消失的数字</h1><blockquote><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。<br>找到所有在 [1, n] 范围之间没有出现在数组中的数字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i,res = <span class="number">0</span>,[]</span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            idx = nums[i]<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]!=nums[idx]:</span><br><span class="line">                nums[i],nums[idx] = nums[idx],nums[i]</span><br><span class="line">            <span class="keyword">else</span>: i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                res.append(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-双指针</title>
      <link href="/2018/06/20/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2018/06/20/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode11-盛最多水的容器"><a href="#LeetCode11-盛最多水的容器" class="headerlink" title="LeetCode11 盛最多水的容器"></a>LeetCode11 盛最多水的容器</h1><blockquote><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(height)<span class="number">-1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            area = min(height[l],height[r])*(r-l)</span><br><span class="line">            res = max(res,area)</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt; height[r]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="LeetCode26-删除排序数组中的重复项"><a href="#LeetCode26-删除排序数组中的重复项" class="headerlink" title="LeetCode26. 删除排序数组中的重复项"></a>LeetCode26. 删除排序数组中的重复项</h1><blockquote><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[index] != nums[i]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode80-删除排序数组中的重复项-II"><a href="#LeetCode80-删除排序数组中的重复项-II" class="headerlink" title="LeetCode80. 删除排序数组中的重复项 II"></a>LeetCode80. 删除排序数组中的重复项 II</h1><blockquote><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现<strong>两次</strong>，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(nums)</span><br><span class="line">        <span class="keyword">if</span> m &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,m):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[index<span class="number">-1</span>]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode75-颜色分类"><a href="#LeetCode75-颜色分类" class="headerlink" title="LeetCode75. 颜色分类"></a>LeetCode75. 颜色分类</h1><blockquote><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(nums)</span><br><span class="line">        r,b = <span class="number">0</span>,m<span class="number">-1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;b+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i],nums[r] = nums[r],nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[i],nums[b] = nums[b],nums[i]</span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode713-乘积小于K的子数组"><a href="#LeetCode713-乘积小于K的子数组" class="headerlink" title="LeetCode713. 乘积小于K的子数组"></a>LeetCode713. 乘积小于K的子数组</h1><blockquote><p>给定一个正整数数组 nums。<br>找出该数组内乘积小于 k 的连续的子数组的个数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count,prod,left = <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            prod *= nums[i]</span><br><span class="line">            <span class="keyword">while</span> prod&gt;=k:</span><br><span class="line">                prod /= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            count += i-left+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-二叉树</title>
      <link href="/2018/06/20/LeetCode-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/06/20/LeetCode-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode109-有序链表转换二叉搜索树"><a href="#LeetCode109-有序链表转换二叉搜索树" class="headerlink" title="LeetCode109. 有序链表转换二叉搜索树"></a>LeetCode109. 有序链表转换二叉搜索树</h1><blockquote><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。<br>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p = head</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            p = p.next</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        head = [head]</span><br><span class="line">        root = self.sorted_list2bst(head,<span class="number">0</span>,length<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sorted_list2bst</span><span class="params">(self,head,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        m = (start+end)&gt;&gt;<span class="number">1</span></span><br><span class="line">        left = self.sorted_list2bst(head,start,m<span class="number">-1</span>)</span><br><span class="line">        root = TreeNode(head[<span class="number">0</span>].val)</span><br><span class="line">        root.left = left</span><br><span class="line">        head[<span class="number">0</span>] = head[<span class="number">0</span>].next</span><br><span class="line">        root.right = self.sorted_list2bst(head,m+<span class="number">1</span>,end)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="LeetCode114-二叉树展开为链表"><a href="#LeetCode114-二叉树展开为链表" class="headerlink" title="LeetCode114. 二叉树展开为链表"></a>LeetCode114. 二叉树展开为链表</h1><blockquote><p>给定一个二叉树，原地将它展开为链表。<br><code>前序遍历</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">        stack.append(root)</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            p = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> pre:</span><br><span class="line">                pre.left = <span class="keyword">None</span></span><br><span class="line">                pre.right = p</span><br><span class="line">            <span class="keyword">if</span> p.right: stack.append(p.right)</span><br><span class="line">            <span class="keyword">if</span> p.left: stack.append(p.left)</span><br><span class="line">            <span class="comment"># p.right = None</span></span><br><span class="line">            pre = p</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode116-填充同一层的兄弟节点"><a href="#LeetCode116-填充同一层的兄弟节点" class="headerlink" title="LeetCode116. 填充同一层的兄弟节点"></a>LeetCode116. 填充同一层的兄弟节点</h1><blockquote><p>给定一个二叉树填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>初始状态下，所有 next 指针都被设置为 NULL。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param root, a tree link node</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">        start = root</span><br><span class="line">        <span class="keyword">while</span> start.left:</span><br><span class="line">            cur = start</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                cur.left.next = cur.right</span><br><span class="line">                <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.right.next = cur.next.left</span><br><span class="line">                cur = cur.next</span><br><span class="line">            start = start.left</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><h1 id="LeetCode124-二叉树中的最大路径和"><a href="#LeetCode124-二叉树中的最大路径和" class="headerlink" title="LeetCode124. 二叉树中的最大路径和"></a>LeetCode124. 二叉树中的最大路径和</h1><blockquote><p>给定一个非空二叉树，返回其最大路径和。<br>本题中，<strong>路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="number">-10</span>**<span class="number">6</span>]</span><br><span class="line">        self.pathsum_core(root,res)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathsum_core</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = max(self.pathsum_core(root.left,res),<span class="number">0</span>)</span><br><span class="line">        right = max(self.pathsum_core(root.right,res),<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 计算当前节点作为根节点时得到的最大和</span></span><br><span class="line">        res[<span class="number">0</span>] = max(res[<span class="number">0</span>],left + right + root.val)</span><br><span class="line">        <span class="comment"># 当前节点作为一个左（右）子节点返回的时候，智能包含左子树或者右子树的返回值中的一个。</span></span><br><span class="line">        <span class="keyword">return</span> max(left,right)+root.val</span><br></pre></td></tr></table></figure><h1 id="LeetCode236-二叉树的最近公共祖先"><a href="#LeetCode236-二叉树的最近公共祖先" class="headerlink" title="LeetCode236. 二叉树的最近公共祖先"></a>LeetCode236. 二叉树的最近公共祖先</h1><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> root) <span class="keyword">or</span> root==p <span class="keyword">or</span> root==q: <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-二分搜索</title>
      <link href="/2018/06/20/LeetCode-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
      <url>/2018/06/20/LeetCode-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode33-搜索旋转排序数组-无重复数字"><a href="#LeetCode33-搜索旋转排序数组-无重复数字" class="headerlink" title="LeetCode33 搜索旋转排序数组(无重复数字)"></a>LeetCode33 搜索旋转排序数组(无重复数字)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        l,r = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;=r:</span><br><span class="line">            m = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">if</span> nums[l] &lt;= nums[m]:</span><br><span class="line">                <span class="keyword">if</span> nums[l]&lt;=target&lt;nums[m]:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[m]&lt;target&lt;=nums[r]:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode81-搜索旋转排序数组-II（有重复数字）"><a href="#LeetCode81-搜索旋转排序数组-II（有重复数字）" class="headerlink" title="LeetCode81. 搜索旋转排序数组 II（有重复数字）"></a>LeetCode81. 搜索旋转排序数组 II（有重复数字）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;=r:</span><br><span class="line">            m = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt;nums[m]:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]:</span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt; target &lt;=nums[r]:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = l+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode162-寻找峰值"><a href="#LeetCode162-寻找峰值" class="headerlink" title="LeetCode162. 寻找峰值"></a>LeetCode162. 寻找峰值</h1><blockquote><p>峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p></blockquote><hr><p><strong>分析：</strong><br>如果nums[mid] &gt; nums[mid+1]，则在mid之前一定存在峰值元素<br>如果nums[mid] &lt; nums[mid+1]，则在mid+1之后一定存在峰值元素</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;nums[mid+<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><h1 id="LeetCode852-山脉数组的峰顶索引"><a href="#LeetCode852-山脉数组的峰顶索引" class="headerlink" title="LeetCode852. 山脉数组的峰顶索引"></a>LeetCode852. 山脉数组的峰顶索引</h1><blockquote><p>我们把符合下列属性的数组 A 称作山脉：</p><ul><li>A.length &gt;= 3</li><li>存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br> 给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(A)</span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[mid]&gt;A[mid+<span class="number">1</span>]:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-DFS</title>
      <link href="/2018/06/20/LeetCode-DFS/"/>
      <url>/2018/06/20/LeetCode-DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode22-括号生成"><a href="#LeetCode22-括号生成" class="headerlink" title="LeetCode22. 括号生成"></a>LeetCode22. 括号生成</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = <span class="string">""</span></span><br><span class="line">        self.dfs(res,cur,n,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,res,cur,n,l,r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l==n:</span><br><span class="line">            res.append(cur+<span class="string">')'</span>*(n-r))</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.dfs(res,cur+<span class="string">'('</span>,n,l+<span class="number">1</span>,r)</span><br><span class="line">        <span class="keyword">if</span> r&lt;l:</span><br><span class="line">            self.dfs(res,cur+<span class="string">')'</span>,n,l,r+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="LeetCode37-解数独"><a href="#LeetCode37-解数独" class="headerlink" title="LeetCode37 解数独"></a>LeetCode37 解数独</h1><blockquote><p>编写一个程序，通过已填充的空格来解决数独问题。<br>一个数独的解法需遵循如下规则：</p><ol><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>Note:</li></ol><ul><li>给定的数独序列只包含数字 1-9 和字符 ‘.’ 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 9x9 形式的。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.sudoku_core(board)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sudoku_core</span><span class="params">(self,board)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                        <span class="keyword">if</span> self.is_value_sudoku(board,i,j,k):</span><br><span class="line">                            board[i][j] = str(k)</span><br><span class="line">                            <span class="keyword">if</span> self.sudoku_core(board):</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                            board[i][j] = <span class="string">'.'</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_value_sudoku</span><span class="params">(self,board,i,j,k)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> board[i]:</span><br><span class="line">            <span class="keyword">if</span> l == str(k):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[l][j] == str(k):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(int(i/<span class="number">3</span>)*<span class="number">3</span>,int(i/<span class="number">3</span>)*<span class="number">3</span>+<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(int(j/<span class="number">3</span>)*<span class="number">3</span>,int(j/<span class="number">3</span>)*<span class="number">3</span>+<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> board[m][n] == str(k):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode51-N皇后"><a href="#LeetCode51-N皇后" class="headerlink" title="LeetCode51. N皇后"></a>LeetCode51. N皇后</h1><blockquote><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pos = [<span class="number">-1</span>]*n</span><br><span class="line">        res = []</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        self.n_queens_core(res,pos,row,n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n_queens_core</span><span class="params">(self,res,pos,row,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            st = [[<span class="string">'.'</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                st[i][pos[i]] = <span class="string">'Q'</span></span><br><span class="line">            st = [<span class="string">''</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> st]</span><br><span class="line">            res.append(st)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> self.is_value(pos,row,col):</span><br><span class="line">                    pos[row] = col</span><br><span class="line">                    self.n_queens_core(res,pos,row+<span class="number">1</span>,n)</span><br><span class="line">                    pos[row] = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_value</span><span class="params">(self,pos,row,col)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">if</span> col==pos[i] <span class="keyword">or</span> abs(row-i) == abs(pos[i]-col):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode51-N皇后2"><a href="#LeetCode51-N皇后2" class="headerlink" title="LeetCode51. N皇后2"></a>LeetCode51. N皇后2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pos = [<span class="number">-1</span>]*n</span><br><span class="line">        res,row = [<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">        self.n_queens_core(res,pos,row,n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n_queens_core</span><span class="params">(self,res,pos,row,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row==n:</span><br><span class="line">            res[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> self.is_value(pos,row,col):</span><br><span class="line">                    pos[row] = col</span><br><span class="line">                    self.n_queens_core(res,pos,row+<span class="number">1</span>,n)</span><br><span class="line">                    pos[row] = <span class="number">-1</span></span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_value</span><span class="params">(self,pos,row,col)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">if</span> col == pos[i] <span class="keyword">or</span> abs(i-row) == abs(col-pos[i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h1 id="LeetCode79-单词搜索"><a href="#LeetCode79-单词搜索" class="headerlink" title="LeetCode79. 单词搜索"></a>LeetCode79. 单词搜索</h1><blockquote><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(board)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> word:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        has_visit = [[<span class="keyword">False</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> self.search(board,word,i,j,has_visit,<span class="number">0</span>,m,n):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,board,word,i,j,has_visit,k,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        is_word = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> <span class="keyword">not</span> has_visit[i][j] <span class="keyword">and</span> board[i][j] == word[k]:</span><br><span class="line">            has_visit[i][j] = <span class="keyword">True</span></span><br><span class="line">            is_word = self.search(board,word,i+<span class="number">1</span>,j,has_visit,k+<span class="number">1</span>,m,n) <span class="keyword">or</span> self.search(board,word,i<span class="number">-1</span>,j,has_visit,k+<span class="number">1</span>,m,n) \</span><br><span class="line">            <span class="keyword">or</span> self.search(board,word,i,j+<span class="number">1</span>,has_visit,k+<span class="number">1</span>,m,n) <span class="keyword">or</span> self.search(board,word,i,j<span class="number">-1</span>,has_visit,k+<span class="number">1</span>,m,n)</span><br><span class="line">            has_visit[i][j] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> is_word</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="LeetCode131-分割回文串"><a href="#LeetCode131-分割回文串" class="headerlink" title="LeetCode131. 分割回文串"></a>LeetCode131. 分割回文串</h1><blockquote><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(s,[],<span class="number">0</span>,res,n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(self,s,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            <span class="keyword">if</span> s[start] != s[end]: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            start +=<span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,s,cur,start,res,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == n:</span><br><span class="line">            res.append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n):</span><br><span class="line">            <span class="keyword">if</span> self.is_palindrome(s,start,i):</span><br><span class="line">                self.dfs(s,cur+[s[start:i+<span class="number">1</span>]],i+<span class="number">1</span>,res,n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机</title>
      <link href="/2018/03/14/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <url>/2018/03/14/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><h2 id="硬间隔支持向量机-hard-margin"><a href="#硬间隔支持向量机-hard-margin" class="headerlink" title="硬间隔支持向量机(hard margin)"></a>硬间隔支持向量机(hard margin)</h2><h3 id="问题的假设和动机"><a href="#问题的假设和动机" class="headerlink" title="问题的假设和动机"></a>问题的假设和动机</h3><p>针对二分类问题，并且假设样本是线性可分的，也就是我能找到一个超平面，一刀下去，正例反例各占一边，不考虑样本不均衡等等一些问题。这个超平面应该怎么找，并且什么样的才是比较好的。假设超平面为 $ w^Tx + b = 0$, 实际上要找的就是 $w$ 和 $b$， 首先，这个超平面最起码要能把样本划分开，也就是说，$x$为正样本，$ w^Tx + b &gt; 0$ , 反之， $ w^Tx + b &lt; 0$。</p><h3 id="空间中一个点到超平面的距离"><a href="#空间中一个点到超平面的距离" class="headerlink" title="空间中一个点到超平面的距离"></a>空间中一个点到超平面的距离</h3><p>假设空间中的点x到平面的投影为$x_0$ ,则<br>$x = x_0 + \frac{rw}{| w|}$, $r$就是x到超平面的距离，来计算一下这个 $r$ <code>需要注意的是：这里的r是有正负号的</code>。同时用 $w^T$ 乘以两边，并且加上 b， 得到<br>$$<br>w^Tx + b = w^Tx_0 + b + \frac{rw^Tw}{| w |}<br>$$<br>由于 $ w^Tx_0 + b = 0$,化简一下得到：<br>$$<br>r = \frac{w^Tx + b}{| w |}<br>$$<br>方便描述一点，令$ f(x) = w^Tx + b $.<br><em>假设</em>,在正样本中，距离超平面最近的点的距离是c，负样本是d<code>d是小于0的</code>，那么所有正样本中 $\frac{f(x_i)}{| w |} \geq c $,而负样本$\frac{f(x_i)}{| w |} \leq d $, <em>再假设</em>，正负样本的标签分别为 $ y_i \in \lbrace 1,-1 \rbrace$, 接下来得到，正样本：$y_i\frac{f(x_i)}{| w |} \geq c $,负样本:$y_i\frac{f(x_i)}{| w |} \geq -d $,对所有的样本$y_i\frac{f(x_i)}{| w |} \geq e = \min\lbrace c,-d \rbrace &gt; 0$. 再改进一下，实际上e为多少不好确定，但这没关系，因为对于一个超平面而言，同时对w和b放大或缩小一个倍数，这个超平面还是这个超平面，所以干脆让 $y_if(x_i) \geq 1 $. 也就是上面假设了距离超平面最近的满足正样本 $ w^Tx_i + b =1 $ ,负样本 $ w^Tx_i + b =-1 $ ,</p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>到目前为止，我们已经知道了我们要找的这个超平面至少要满足的条件，满足这样的超平面有无数个，我们要找一个我们认为比较好的超平面。那究竟咋样才比较好呢？ 到超平面的距离最近的正负样本的距离分别为$\frac{1}{| w |}$和$\frac{-1}{| w |} $, 两者的间隔为 $\frac{2}{| w |}$（注意并不是它俩的距离，而是$ w^Tx_i + b =1 $ 和$ w^Tx_i + b =-1 $的距离）。直观上来看，两者的间隔越大，模型的泛化性能就越好，可以把最大化间隔当做一个先验假设（有没有更合理的科学解释）。于是就得到了如下优化目标：<br>$$<br>\begin{equation}<br>\begin{array}{c l}<br>\max &amp; \frac{2}{| w |} \<br>\text{subject to} &amp; y_i(w^Tx_i+b) \geq 1, \quad i = 1,2,\cdots m<br>\end{array}<br>\end{equation}<br>$$<br>为了便于求解，转化成<br>$$<br>\begin{equation}<br>\begin{array}{c l}<br>\min &amp; \frac{| w |^2}{2} \<br>\text{subject to} &amp; y_i(w^Tx_i+b) \geq 1, \quad i = 1,2,\cdots m<br>\end{array}<br>\end{equation}<br>$$</p><h3 id="它的对偶问题"><a href="#它的对偶问题" class="headerlink" title="它的对偶问题"></a>它的对偶问题</h3><p>其实从优化的角度来看，非常简单，还是写一下吧，就是用Lagrange 乘子法来求解上面的凸二次规划问题。因为根据它的对偶形式，后面再加上核函数，使得SVM可以很容易的求解非线性问题，让它变得非常强大。</p><p>写出来它的Lagrange函数：<br>$$<br>L(w,b,\lambda) = \frac{| w |^2}{2} - \sum_i^m \lambda_i(y_i(w^Tx_i + b) - 1)<br>$$<br>定义原问题的对偶函数为：<br>$$<br>g(\lambda) = \inf_{w,b}L(w,b,\lambda) \quad subject\quad to \quad\lambda \geq 0<br>$$<br>求Lagrange 函数在（w,b）的最小值,关于w和b求导得到<br>$$<br>\frac{\partial L}{\partial w} = w - \sum_i^m \lambda_i y_i x_i = 0 \<br>\frac{\partial L}{\partial b} = \sum_i^m \lambda_iy_i = 0<br>$$<br>于是我们得到，下列结果，并代入对偶函数：<br>$$<br>g(\lambda) = -\frac{1}{2} \sum_i^m \sum_j^m \lambda_i \lambda_j y_i y_j x_i^T x_j + \sum_i^m \lambda_i<br>\<br>subject \quad to \quad \lambda_i \geq 0<br>\<br>\sum_i^m \lambda_iy_i = 0\quad i = 1,2,\cdots,m<br>$$<br>依旧是一个凸的二次规划问题，可以使用SMO方法高效求解。</p><blockquote><p><strong>KKT条件</strong><br>$$<br>\frac{\partial L}{\partial w} = w - \sum_i^m \lambda_i y_i x_i = 0<br>\<br>(\text{目标函数的梯度在约束函数梯度的锥包})<br>\<br>\frac{\partial L}{\partial b} = \sum_i^m \lambda_iy_i = 0<br>\<br> y_i(w^Tx_i+b) \geq 1, \quad i = 1,2,\cdots m(\text{解应该在原来的可行域})<br> \<br> \lambda_i \geq 0<br> \<br> \lambda_i(y_i(w^Tx_i + b) - 1) = 0, \quad i = 1,2,\cdots m(\text{互补松弛条件})<br>$$<br>由互补松弛性质，lagrange乘子只在边界约束的点上不为0，那些边界约束的点正是支持向量，而其他点对应的lagrange乘子都为0.</p></blockquote><h2 id="为什么要把原问题转换为对偶问题求解？以及核方法的引入"><a href="#为什么要把原问题转换为对偶问题求解？以及核方法的引入" class="headerlink" title="为什么要把原问题转换为对偶问题求解？以及核方法的引入"></a>为什么要把原问题转换为对偶问题求解？以及核方法的引入</h2><p>&emsp;&emsp;上面对SVM的建模基于一个假设就是样本集本身就是线性可分的，当样本集非线性可分的时候，一个超平面就不能完成分类的任务。一般情况下，低维不可分的问题，在高维情况下往往是线性可分的，所以我们可以对原来的特征空间作升维操作。</p><blockquote><p><strong>举个例子</strong>，假设原来是一个二维特征空间，样本$x=(x_1,x_2)$,而真实的分类平面是一个二次的曲面，也就是$ax_1^2 + b x_2^2 + c x_1x_2 + dx_1 + e x_2 + f = 0 $,我们依旧可以将其转化为线性问题，如，令 $ y_1 = x_1^2, y_2 = x_2^2, y_3 = x_1x_2,y_4 = x_1, y_5=x_2 $, 即对原来的特征空间做了一个映射：$\phi(x) \rightarrow y $,我们来寻求这个超平面就行了 $w^Ty + f = 0。$</p></blockquote><p>&emsp;&emsp;但是注意这时候y是4维的，问题由原来的二维问题变成了4维问题，如果样本的分布比较复杂，可能需要将特征空间转化为非常高的维度才可以实现线性可分，这时候很容易出现维数灾难，而且也不太容易确定映射具体长什么样比较好。注意到即使我们将原特征空间映射到高维特征空间，在将其转化为对偶问题的时候，也只是需要求内积 $ \phi(x_i)^T\phi(x_j) $, 如果我们不显示的确定 $ \phi $, 只要能够确定最后的内积，这样就成功避开了维数灾难的发生，也达到了升维的作用。</p><blockquote><p>只要$\phi$满足$[\phi(x_i)^T\phi(x_j)]_{i=1,j=1}^m$为半正定矩阵，$\phi$就能作为核函数使用。</p></blockquote><p>&emsp;&emsp;最后，由法向量和样本之间的对偶表示的关系，最后的分类函数长这个样子：<br>$$<br>f(x) = \sum_i^m \lambda_i y_i \phi(x_i)^T \phi(x_i)<br>$$<br>$ \lambda_i $ 由对偶问题解出来，而内积由事先的核函数给出。由于Lagrange乘子的稀疏性质，对于训练好的支持向量机预测样本的时候应该是很迅速的？</p><h3 id="常用的核函数"><a href="#常用的核函数" class="headerlink" title="常用的核函数"></a>常用的核函数</h3><ol><li><strong>线性核：</strong>$x_i^Tx_j$</li><li><strong>多项式核：</strong>$(x_i^Tx_j)^d$</li><li><strong>高斯核（RBF）:</strong> $\exp(-\frac{|x_i-x_j|^2}{2\sigma^2})$</li></ol><h3 id="核支持向量机-VS-线性支持向量机（这里一般指soft-margin-下节讨论）"><a href="#核支持向量机-VS-线性支持向量机（这里一般指soft-margin-下节讨论）" class="headerlink" title="核支持向量机 VS 线性支持向量机（这里一般指soft margin,下节讨论）"></a>核支持向量机 VS 线性支持向量机（这里一般指soft margin,下节讨论）</h3><p>核支持向量机可以处理非线性可分的问题，模型的容量要大于线性支持向量机，正所谓<code>No Free Lunch</code>，核支持向量机更容易过拟合，而且核支持向量机的计算复杂度要大于线性支持向量机，在数据量比较大的时候表现的尤为明显。</p><p>核SVM计算量大主要表现两方面，一是在模型训练的时候，二是模型预测的时候。主要原因都是核SVM经常需要转换为对偶问题来求解，需要计算出核矩阵，也就是嵌入空间中样本之间的内积。而在预测的时候，$w$又需要表示成其对偶形式：</p><blockquote><p><strong>预测样本x：</strong><br>$$w^Tx+b \quad VS \quad \sum_{i=1}^m \lambda_iy_iK(x_i,x)$$<br>若内积运算需要 $O(n)$，那么线性与核SVM的时间花费分别为$$O(n)\text{和}O(mn)$$</p></blockquote><!-- >**选择函数数的方法:**                         假设样本的特征为n,数据量为m，n相对于m较大时，可先尝试线性核；n--><h2 id="软间隔支持向量机-soft-margin"><a href="#软间隔支持向量机-soft-margin" class="headerlink" title="软间隔支持向量机(soft margin)"></a>软间隔支持向量机(soft margin)</h2><p>硬间隔支持向量机很容易造成过拟合，原因就是，我们在推导的时候，约束条件不能容忍一个样本出错，很容易受outlier的影响。于是，引入软间隔，意思是说，我可以容忍部分样本分类出错，但是也不能出错太多。在这种假设下优化目标变为：<br>$$<br>\min \frac{| w |^2}{2} + C\sum_{i=1}^m \max\lbrace 0,1-y_i(w^Tx_i + b)\rbrace<br>$$<br>令 $ \xi_i = max\lbrace 0,1-y_i(w^Tx_i + b)\rbrace$,则 $ \xi_i \geq 1-y_i(w^Tx_i + b), \xi_i \geq 0$,上式可转化成等价形式<br>$$<br>\min \frac{| w |^2}{2} + C\sum_{i=1}^m \xi_i<br>\<br>subject\quad to \quad<br>\xi_i \geq 1-y_i(w^Tx_i + b),<br>\<br>\xi_i \geq 0.\quad i=1,2,\cdots,m<br>$$<br>$ \xi$可以看作一个松弛变量。软间隔支持向量机的对偶问题和核方法与硬间隔基本一致，但由于出现了松弛变量，使得软间隔的对偶问题变为：<br>$$<br>\begin{array}{c,l}<br>\max \quad &amp; g(\lambda) = -\frac{1}{2} \sum_i^m \sum_j^m \lambda_i \lambda_j y_i y_j x_i^T x_j + \sum_i^m \lambda_i<br>\<br>subject \quad to &amp; \quad 0 \leq \lambda_i \leq C<br>\<br>&amp; \sum_i^m \lambda_iy_i = 0\quad i = 1,2,\cdots,m<br>\end{array}<br>$$<br>与硬间隔支持向量机相比，软间隔的对偶问题只是对Lagrange乘子加个了个约束，有一个上界。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1]  周志华，机器学习<br>[2] <a href="http://www.csie.ntu.edu.tw/~cjlin/talks/msri.pdf" target="_blank" rel="noopener">Large-scale Linear and Kernel Classification</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑回归</title>
      <link href="/2018/03/12/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/2018/03/12/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="从贝叶斯分类准则谈起"><a href="#从贝叶斯分类准则谈起" class="headerlink" title="从贝叶斯分类准则谈起"></a>从贝叶斯分类准则谈起</h2><p>二分类问题，假设正负样本类条件概率密度为 $$ p(x|y=1) = \frac{1}{(2\pi)^{d/2}|\Sigma|^{1/2}}exp(-\frac{1}{2}(x-\mu_1)^T \Sigma^{-1}(x-u_1)), $$<br>$$ p(x|y=0) = \frac{1}{(2\pi)^{d/2}|\Sigma|^{1/2}}exp(-\frac{1}{2}(x-\mu_0)^T \Sigma^{-1}(x-u_0)), $$即方差相同，均值不同高斯分布，根据贝叶斯判定准则，若 $ p(y=1|x) \geq p(y=0|x) $,我们就把样本分类为正样本，反之亦然。即</p><p>$$<br>\frac{p(y=1|x)}{p(y=0|x)} \geq 1<br>$$</p><p>分类为正样本。由贝叶斯公式得到<br>$$p(y=i|x) = \frac{p(x|y=i)p(y=i)}{p(x)}.$$<br>假设类先验概率相等（不相等也没关系,只是为了方便讨论）代入 $ \frac{p(y=1|x)}{p(y=0|x)} $，得到<br>$$<br>\frac{p(y=1|x)}{p(y=0|x)} =  exp(\frac{1}{2}(2\Sigma^{-1}(\mu_1 - \mu_0)x + \mu_0^T\Sigma^{-1}\mu_0 - \mu_1^T\Sigma^{-1}\mu_1)<br>$$<br>$\text{sigmoid}$ 函数马上就要登场了，咱们令 $ w = \Sigma^{-1}(\mu_1 - \mu_0)$,$b = \frac{1}{2}\mu_0^T\Sigma^{-1}\mu_0 - \mu_1^T\Sigma^{-1}\mu_1 $, 于是得到<br>$$<br>\frac{p(y=1|x)}{1- p(y=1|x)} = \exp(w^Tx+b)<br>$$<br>解出来 $ p(y=1|x) = \frac{1}{1+\exp(-(w^Tx + b))}$, 这就是熟悉的<strong>sigmoid</strong>函数。</p><h2 id="极大似然估计-MLE-求解参数"><a href="#极大似然估计-MLE-求解参数" class="headerlink" title="极大似然估计(MLE)求解参数"></a>极大似然估计(MLE)求解参数</h2><p>事实上，上面的推导过程是从生成式模型的角度来考虑，为了进行分类，若使用生成式的方法，我们需要求解的参数包括协方差矩阵，两个类概率均值，假设样本特征n维的话，需要估计的参数约等于$n^2$。但是正如我们最后推导出来的<strong>Sigmoid</strong>函数一样，实际分类的时候我们只需要估计出$w,b$，就可以求出后验概率，这时候需要估计的参数为$n$,所以逻辑回归是一种判别式模型，直接求出后验概率$ p(y=1|x)$,下面我们看如何求解逻辑回归的参数。</p><p>方便起见，统一一下概率的形式，<br>$$<br>p(y_i|x) = (\frac{1}{1+\exp(-(w^Tx_i + b))})^{y_i}(\frac{\exp(-(w^Tx_i + b))}{1+\exp(-(w^Tx_i + b))})^{1-y_i}<br>$$<br>极大对数似然估计可以得到：<br>$$<br>\max_{w,b} \sum_{i=1}^m y_i\log\frac{1}{1+\exp(-(w^Tx_i + b))} + (1-y_i)\log \frac{\exp(-(w^Tx_i + b))}{1+\exp(-(w^Tx_i + b))}<br>$$<br>化简一下得到:<br>$$<br>\max_{w,b} \sum_{i=1}^m y_i (w^Tx_i + b) - \log (1+\exp(w^Tx_i + b))<br>$$<br>等价于<br>$$<br>\min_{w,b} \sum_{i=1}^m -y_i (w^Tx_i + b) + \log (1+\exp(w^Tx_i + b))<br>$$<br>此问题是一个无约束的凸优化问题，可使用一些基于梯度的优化方法进行求解。</p><h2 id="逻辑回归的-loss-function"><a href="#逻辑回归的-loss-function" class="headerlink" title="逻辑回归的 loss function"></a>逻辑回归的 loss function</h2><p>从上面通过极大似然求解参数$w,b$的推导过程，我们得到了最终的目标函数，所以逻辑回归的 loss function 为：<br>$$-\ y\log\frac{1}{1+\exp(-(w^Tx + b))} - (1-y)\log \frac{\exp(-(w^Tx + b))}{1+\exp(-(w^Tx + b))}, $$<br>或者<br>$$-y (w^Tx + b) + \log (1+\exp(w^Tx + b)。$$<br>结果很显然，没太多需要解释的，但是在有些地方我们却看到逻辑回归的 loss function 为：<br>$$\log \big(1+\exp(-y(w^Tx + b)\big),$$</p><blockquote><p>比如说，在周志华《机器学习》支持向量机那一章，对比<code>hinge loss</code>和<code>log loss</code>以及<code>0-1 loss</code>。</p></blockquote><p>通过对比，发现这一写法与上面的两个怎么都不等价，比如直接让$y=0$就会发现不同。那为什么在李航的《统计学习方法》和周志华《机器学习》讲解逻辑回归的时候，推导出的是上面两个loss function, 而有些地方却出现下面的loss function，后来才发现，在推导逻辑回归的时候我们一般习惯于将样本的正负标签$y$表示为$1,0$,而下面那个loss function 将正负标签表示为了 $1,-1$，分别用$1,0$代入上面两式，$1,-1$代入下面两式，发现他们是相同的。（尴尬）</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] 周志华，机器学习<br>[2] PRML</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过拟合与欠拟合</title>
      <link href="/2018/03/06/overfit/"/>
      <url>/2018/03/06/overfit/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="过拟合与欠拟合，偏差与方差"><a href="#过拟合与欠拟合，偏差与方差" class="headerlink" title="过拟合与欠拟合，偏差与方差"></a>过拟合与欠拟合，偏差与方差</h1><h2 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h2><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a><strong>过拟合</strong></h3><p>直观理解就是模型在训练集上表现很好，但是对于没见过的样本，或者在测试集上的表现很差，过拟合产生的原因很有可能是模型不止学习到了数据分布的一般特征，还学习到了训练集特殊特征，通常这种模型对应着高方差的模型。</p><h3 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a><strong>欠拟合</strong></h3><p>与过拟合相反，欠拟合在训练集上的表现就很差，一般这种模型相对于数据而言表示能力不够强，或者复杂度比较低。对应着高偏差的模型。</p><h2 id="方差与偏差"><a href="#方差与偏差" class="headerlink" title="方差与偏差"></a><strong>方差与偏差</strong></h2><p>以回归为例来解释，给定了一个数据集D，并且假设D是存在一个完美的函数F(x)产生了数据的子集，我们希望通过D来拟合推测F(x),一个模型在数据D上拟合出来的函数$ g(x;D)$,我们肯定是希望，对于不同的D在平均情况下，$ g(x;D)$能够足够的接近于完美函数F(x),于是就通过均方误差来衡量这种误差的话，得到<br>\begin{equation}<br>\begin{array}{c l}<br>&amp; E_D[(g(x;D) - F(x))^2]  \<br>&amp; = E_D[(g(x;D)  - E_D[g(x;D)] +  E_D[g(x;D)] - F(x))^2]<br>\<br>&amp; =E_D[(g(x;D) - E_D[g(x;D)])^2] + (E_D[g(x;D)] - F(x))^2<br>\end{array}<br>\end{equation}<br>左边一项是说随着训练集的改变，数据集学习出来的函数受数据集波动的影响，也就是方差。右边一项是不同的数据集训练出来的函数的平均值与完美函数的误差的平方，也就是偏差（的平方）。由此可见，数据学习出来的模型的均方误差同时受偏差和方差的影响，对于给定我们的一个数据集，我们训练出来的模型即使偏差很小，但是也有可能方差变大造成整体泛化误差的增大。一般来说，简单的模型，受数据集波动的影响较小，方差小，但是偏差大；参数多的模型，对数据集的拟合能力很强，但是很容易受数据集波动的影响，造成偏差小，方差大。</p><h2 id="防止过拟合的方法"><a href="#防止过拟合的方法" class="headerlink" title="防止过拟合的方法"></a><strong>防止过拟合的方法</strong></h2><ol><li>正则化</li><li>降低模型的复杂度，正则化也是降低了模型的复杂度</li><li>获取更多的数据</li><li>获取更多的先验知识，正则化也是</li><li>奥卡姆的小剃刀</li><li>提前终止迭代，不要让训练集误差持续下降</li><li>使用多个弱学习器集成</li></ol><h3 id="正则化的方法，正则化的解释"><a href="#正则化的方法，正则化的解释" class="headerlink" title="正则化的方法，正则化的解释"></a>正则化的方法，正则化的解释</h3><ol><li>正则化可以被视为对参数的一种先验知识，如L2正则化对应高斯先验，L1正则化对应拉普拉斯先验</li><li>可视为对模型容量的一种约束，如线性回归加了正则项，相当于求解带约束的优化问题</li><li>深度学习中还有很多正则化方法，其实也就是防止过拟合的方法</li></ol><h3 id="L1正则化导致稀疏解的原因"><a href="#L1正则化导致稀疏解的原因" class="headerlink" title="L1正则化导致稀疏解的原因"></a>L1正则化导致稀疏解的原因</h3><p><strong>几何上解释:</strong> 直观上，L1，是一个正多面体的结构，如二维平面是一个菱形，并且顶点都位于坐标轴上，我们说L1正则化从优化的角度相当于对原来的问题添加了一项约束，这个约束是<br>$$<br>| w |_1 \leq \alpha<br>$$<br>也就是你目标函数想要求的解必须落在上面那个可行域中，我们又知道，最优解经常在边界上取到，由于菱形这一特殊的结构，使得目标函数的等值线更有可能先和顶点相交，而顶点又位于坐标轴上，所以常造成稀疏解，对于$ L_p,0 \leq p &lt;1 $ 范数，这时候的可行域直接都凹进去了，使得顶点更尖，所以也更容易稀疏。</p><p><strong>数学上的解释:</strong> 可以参考《深度学习》145页</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树</title>
      <link href="/2018/03/02/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2018/03/02/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>##<strong>分类树</strong><br>&emsp;&emsp;<strong>分类树的生成过程：</strong>当前节点，特征集A，数据集D，先判断能不能分裂节点，<em>数据集中只有一种类别</em>，或者<em>特征集中的特征在数据集上的类别表现一样，没办法分</em>再或者<em>数据集的样本比较少了，达到了预先设定的最小分裂数目</em>，前面一种情况就停止分裂，直接当做叶子节点，类别直接是数据集样本类别，后两种情况类别取决于哪种类别多。在能节点能够分裂的前提下，要先判断选择哪种特征进行节点分裂，这一步是决策树最重要的一步，不同的分裂手段产生了不同的决策树，分裂后继续递归。</p><h3 id="节点分裂标准"><a href="#节点分裂标准" class="headerlink" title="节点分裂标准"></a><strong>节点分裂标准</strong></h3><p>&emsp;&emsp;首先熵的概念：$Ent(D) = -\sum_{i=1}^C p_i \log p_i$,熵的值越小，纯度越高。我们希望属性分裂后的节点纯度越高越好。</p><p><strong>信息增益：</strong> 对属性取值数目多的有偏好，对应于<strong>ID3决策树</strong><br>$$<br>Gain(D,a) = Ent(D) - \sum_{i=1}^m\frac{|D^i|}{|D|}Ent(D^i)<br>$$<br><strong>信息增益率：</strong> 对属性取值数目少的有偏好，对应于<strong>C4.5决策树</strong><br>$$<br>Gain_ratio(D,a) = \frac{Gain(D,a)}{IV(a)}<br>\<br>IV(a) = -\sum_{v=1}^V \frac{|D^v|}{|D|} \log \frac{|D^v|}{|D|}<br>$$<br><strong>基尼指数：</strong>基尼指数越小，纯度越高。所以我们选择划分后Gini指数小的属性。对应于<strong>CART</strong><br>$$<br>\text{基尼值}\quad Gini(D) = 1-\sum_{i=1}^Cp_i^2<br>\<br>\text{基尼指数}\quad Gini_index(D,a) = \sum_{v=1}^V\frac{|D^v|}{|D|} Gini(D^v)<br>$$</p><h2 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a><strong>回归树</strong></h2><p>&emsp;&emsp;回归树的产生过程和分类树类似，是一棵二叉树，也是不断的在分裂节点，分割特征空间，把训练集按照特征的取值放到划分好的特征空间，其训练好的叶子节点的取值是取训练标签的平均值（损失函数为平方损失）。在分裂节点的时候，首先依次选择每个特征，然后每个特征选择一个分裂值，计算分裂后的节点平方误差损失，最终确定分裂的特征为使得平方误差损失最小的那个特征以及对应的分裂点。</p><h2 id="决策树优缺点"><a href="#决策树优缺点" class="headerlink" title="决策树优缺点"></a>决策树优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>解释性较好</li><li>可处理缺失值</li><li>对数据的归一化和标准化不敏感</li><li>对异常值比较鲁棒</li><li>非线性模型，可以组合特征</li><li>自动地进行特征选择</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>容易过拟合</li><li>方差较大，由于树是自上到下生成的节点，顶层的error会传播到下一层</li><li>生成的是一个分段函数，不够平滑，对于回归任务来说，往往只能预测出特定的几个值</li></ol><h3 id="以下为Sklearn决策树总结的优缺点，当个搬运工了"><a href="#以下为Sklearn决策树总结的优缺点，当个搬运工了" class="headerlink" title="以下为Sklearn决策树总结的优缺点，当个搬运工了"></a>以下为Sklearn决策树总结的优缺点，当个搬运工了</h3><p><strong>Some advantages of decision trees are:</strong></p><ol><li><strong>Simple to understand and to interpret.</strong> Trees can be visualised.</li><li><strong>Requires little data preparation.</strong> Other techniques often require data normalisation, dummy variables need to be created and blank values to be removed. Note however that this module does not support missing values.</li><li>The cost of using the tree (i.e., predicting data) is logarithmic in the number of data points used to train the tree.</li><li><strong>Able to handle both numerical and categorical data.</strong> Other techniques are usually specialised in analysing datasets that have only one type of variable. See algorithms for more information.</li><li>Able to <strong>handle multi-output problems.</strong></li><li>Uses a <strong>white box model</strong>. If a given situation is observable in a model, the explanation for the condition is easily explained by boolean logic. By contrast, in a black box model (e.g., in an artificial neural network), results may be more difficult to interpret.</li><li><strong>Possible to validate a model using statistical tests.</strong> That makes it possible to account for the reliability of the model.</li><li>Performs well even if its assumptions are somewhat violated by the true model from which the data were generated.</li></ol><p><strong>The disadvantages of decision trees include:</strong></p><ol><li>Decision-tree learners can create over-complex trees that do not generalise the data well. This is called <strong>overfitting.</strong> Mechanisms such as pruning (not currently supported), setting the minimum number of samples required at a leaf node or setting the maximum depth of the tree are necessary to avoid this problem.</li><li>Decision trees can be <strong>unstable</strong> because small variations in the data might result in a completely different tree being generated. This problem is mitigated by using decision trees within an ensemble.</li><li>The problem of learning an optimal decision tree is known to be NP-complete under several aspects of optimality and even for simple concepts. Consequently, practical decision-tree learning algorithms are based on heuristic algorithms such as the greedy algorithm where <strong>locally optimal decisions</strong> are made at each node. Such algorithms cannot guarantee to return the globally optimal decision tree. This can be mitigated by training multiple trees in an ensemble learner, where the features and samples are randomly sampled with replacement.</li><li>There are concepts that are hard to learn because decision trees do not express them easily, such as XOR, parity or multiplexer problems.</li><li>Decision tree learners <strong>create biased trees if some classes dominate.</strong> It is therefore recommended to balance the dataset prior to fitting with the decision tree.<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>[1] 周志华，机器学习<br>[2] Hastie，The Elements of Statistical Learning<br>[3] scikit-learn,Decision Tree</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习模型评价指标</title>
      <link href="/2018/03/01/evalution/"/>
      <url>/2018/03/01/evalution/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习模型评价指标"><a href="#机器学习模型评价指标" class="headerlink" title="机器学习模型评价指标"></a>机器学习模型评价指标</h1><h2 id="分类模型的评价指标，准确率P、召回率R、F1、PR曲线、ROC、AUC"><a href="#分类模型的评价指标，准确率P、召回率R、F1、PR曲线、ROC、AUC" class="headerlink" title="分类模型的评价指标，准确率P、召回率R、F1、PR曲线、ROC、AUC"></a>分类模型的评价指标，准确率P、召回率R、F1、PR曲线、ROC、AUC</h2><p><strong>混淆矩阵</strong> 假设问题为二分类问题，样本中有一部分正例和一部分反例，用一个模型F对这组样本预测，预测的结果中有正例（P）有反例（N），有的预测对了，有的预测错了，若一个正（反）样本预测成了正（反）值，这时候就叫做真正例、真反例（TP，TN），但是有的正样本预测成了反样本，反样本预测成了正样本，这是就分别叫做假反例和假正例（FN，FP），我们就基于这些值来评估一个模型的好坏。</p><p><strong>查准率与查全率</strong> 评估模型的好坏，首先要知道我们主要关注的是什么，先说P和R的定义。$ P = \frac{TP}{TP+FP} $,意思是说，你模型预测的正例中有多少是预测对的，比例多大，也就是准确率。$ R = \frac{TP}{TP+FN} $ ，模型预测对的正例和真实样本中正例的比例，也就是，真实样本中的正例有多少把他们找出来了，比例多大，这就是查全率，或者叫做召回率。如果你实际业务中关注预测的精度，那P高的模型就是好的，如果关注预测的全不全，完不完整，那R高的就是好的。但是我们也不能一味的追求P和R的大小，比如，把样本全部预测为正例，R=1，或者只关注那些非常有把握的样本才预测为正例，这样P可能接近于1，但是意义不大，更多时候需要综合考虑P和R来评估模型的好坏。</p><p><strong>PR曲线&amp;F1</strong><br>P、R分别就是指的上述查准率和查全率，分别作为坐标轴的横纵坐标轴。假设这时候模型的输出是分类的概率，比如逻辑回归。我们对这组概率从大到小排一个序，然后依次按照概率作为阈值对样本进行预测，每次滑动取不同的阈值，那么就会得到不同的P和R，比方说得到了一组$(R_1,P_1),(R_2,P_2),\cdots $，将这组值依次画在P_R坐标系上，并用线段连接起来，最终就会得到一个弯弯曲曲的折线，这就是P_R曲线。通常来说P_R曲线下面的面积越大，我们就说模型越好（关键还是看你关注的点在哪里）。F1度量是查准率和查全率的调和平均值$F_1 = \frac{1}{2}(\frac{1}{P}+\frac{1}{R}) $</p><p><strong>ROC与AUC</strong><br>介绍ROC之前先给出两个与P和R类似的定义。真正例率$TPR = \frac{TP}{TP+FN} $,假正例率 $FPR = \frac{FP}{FP+TN} $,直观上理解TPR就是实际正例模型预测正例的比例，等于R，而FPR就是实际上是反例而正预测为反例的比例，画ROC的方法与画PR曲线的方法类似，都是先把模型对样本的输出概率作一个排序，然后从大到小依次将每个样本预测为正样本，每次调整，TPR和FPR都会随着变化，将$(FPR_1,TPR_1),(FPR_2,TPR_2),\cdots $画在FPR_TPR为横纵坐标轴的坐标系中，就画出了ROC，实际步骤可以是这样：假设当前点的坐标为$(x,y) $, 调整下一个样本为正样本，若这个样本本身就是正样本，那么下一点的坐标就是$(x,y+\frac{1}{m^+}) $, 反之，下一点的坐标就是$(x+\frac{1}{m^-},y) $，$m^+,m^- $分别是真实数据正样本和反样本的个数，相应的最终ROC下面包含的面积就叫做AUC. 从TPR和FPR的定义上来看，假设FPR=0，TPR=1，也就是说反例没有预测成正例，正例全部预测成了正例，这个模型简直完美，这个坐标为（0，1）。如果我们的模型表现的比较好，也就是正例预测的概率大多数都排在前面，当我们从头开始调整分类的阈值时，TPR（y轴）一直在增加，FPR（x轴）一直维持在一个较小的值，这时候得到的AUC就会比较大。所以AUC越大，模型就越好，从另一个角度来看AUC的话，AUC其实是衡量了模型预测概率排序的一个好坏，甭管预测的概率多大，只要正样本预测为正样本的概率一般都比负样本预测为正样本的概率大，那只要我们恰当的调整分类阈值，模型的分类能力就会很强。</p><p><strong>ROC与PR曲线的关联可以参考</strong><a href="http://pages.cs.wisc.edu/~jdavis/davisgoadrichcamera2.pdf" target="_blank" rel="noopener">The Relationship Between Precision-Recall and ROC Curves</a>, 暂时没看，据说是存在一一对应的关系。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Hands on sklearn &amp; TensorFlow》读书笔记--end to end machine learning project</title>
      <link href="/2018/01/23/hands-sklearn1/"/>
      <url>/2018/01/23/hands-sklearn1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="end-to-end-machine-learning-project"><a href="#end-to-end-machine-learning-project" class="headerlink" title="end to end machine learning project"></a>end to end machine learning project</h1><p>这一章主要介绍了整个机器学习的过程，从获取数据处理数据开始，然后到应用到模型，调整模型。本章数据为加州某个时期房价的数据，所以主要的任务是一个回归任务，下面具体总结一下作者在这一章主要传授的观点和自己的一些收获。</p><h2 id="Look-at-the-big-picture"><a href="#Look-at-the-big-picture" class="headerlink" title="Look at the big picture"></a><strong>Look at the big picture</strong></h2><p>也就是说，在可是意向任务之前，需要思考一下，你需要解决一个什么样的问题？期望得到的结果是什么？为了得到这样的结果需要做哪些工作？手头有哪些数据？需不需要获取额外的data？可以把这个问题抽象成一个什么样的问题？supervised or unsupervised or semi-supervised, 是回归还是分类，有没有现成的解决方案？这些解决方案够不够解决我需要的问题，不够，我需要如何改进这些方案？综合各种成本，我需要投入多少时间和精力？</p><h2 id="Take-quick-look-at-the-data-structure"><a href="#Take-quick-look-at-the-data-structure" class="headerlink" title="Take quick look at the data structure"></a><strong>Take quick look at the data structure</strong></h2><ol><li>常用函数<ul><li>data.head()</li><li>data.info() <em>可以快速看到数据框每列的大小、类型、以及是否有缺失值</em></li><li>data[‘’].value_counts()</li><li>data.describe()</li></ul></li><li>画出所有数值类型的条形图，可以直观的看书数值类型的分布情况。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data.hist(bins=<span class="number">50</span>,figsize=(<span class="number">20</span>,<span class="number">15</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ol><h2 id="划分训练集和测试集"><a href="#划分训练集和测试集" class="headerlink" title="划分训练集和测试集"></a>划分训练集和测试集</h2><p>书中的观点是提起把测试集划分出来，并不参与训练集的数据预处理部分，只是在后面重新把数据预处理重新应用在测试集上面，<strong>我的观点是是否可以放在一起作数据预处理，后面训练模型的时候再划分开数据集</strong></p><h2 id="数据集可视化"><a href="#数据集可视化" class="headerlink" title="数据集可视化"></a>数据集可视化</h2><p>学到一条厉害的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">housing.plot(kind=&apos;scatter&apos;,x=&apos;longitude&apos;,y=&apos;latitude&apos;)</span><br><span class="line"># 这条命令也是直接在数据框上面操作的，用之前也需要导入上面提到的包等，这个图最终画出的是一条散点图。</span><br><span class="line"># 由于样本点还是挺多的，所以画散点图的时候，有些店会有重叠，故可以添加一个alpha参数，透明</span><br><span class="line">housing.plot(kind=&apos;scatter&apos;,x=&apos;longitude&apos;,y=&apos;latitude&apos;,alpha = 0.3)</span><br><span class="line"># 为了完善图像，还需要添加一些图例等东西</span><br><span class="line">housing.plot(kind=&apos;scatter&apos;,x=&apos;longitude&apos;,y=&apos;latitude&apos;,alpha = 0.3,s = housing[&apos;population&apos;]/100,label=&apos;population&apos;,c=&apos;media_house_value&apos;, cmap=plt.get_cmap(&apos;jet&apos;),colorbar=True,)</span><br><span class="line">plt.legend()</span><br><span class="line"># 上面的参数，s: 散点的大小， c: 颜色， cmap暂时还没搞清楚</span><br><span class="line"># 这个图的最终的结果可以看出4个维度的东西，1,2：点的位置，3： 根据点的大小能看出population的大小，4： 根据点的颜色可以看出media_house_value的大小，厉害！！</span><br></pre></td></tr></table></figure></p><h3 id="探索特征之间的相关性"><a href="#探索特征之间的相关性" class="headerlink" title="探索特征之间的相关性"></a>探索特征之间的相关性</h3><p>housing.corr(): <em>返回特征与特征之间的相关系数，取值为【-1,1】，但是要注意的是，这个数值描述的只是变量之间的线性相关性，不能体现出他们之间的非线性关系，如corr(a,b)=0, 不能说a与b是完全独立的，有可能它们之间存在非线性的关系</em></p><p>可视化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tools.plotting <span class="keyword">import</span> scatter_matrix</span><br><span class="line">attributes = [<span class="string">'v1'</span>,<span class="string">'v2'</span>,...,<span class="string">'v_m'</span>]</span><br><span class="line">scatter_matrix(housing[attributes],figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line"><span class="comment"># 这个函数会画出m*m个散点图，对角线上是频率直方图</span></span><br></pre></td></tr></table></figure></p><h4 id="属性之间的连接关系"><a href="#属性之间的连接关系" class="headerlink" title="属性之间的连接关系"></a>属性之间的连接关系</h4><p>也就是说属性与属性之间可以作乘除等一些变换，具体需要根据实际的业务场景，单个特征也可以做一些非线性的变换，比如log</p><h2 id="为算法模型准备标准化的数据"><a href="#为算法模型准备标准化的数据" class="headerlink" title="为算法模型准备标准化的数据"></a>为算法模型准备标准化的数据</h2><p>这一个步骤主要集中在对数据的预处理方面，比如说，数据清洗、缺失值处理，离散数据或者非数值型数据的编码、数据的缩放、标准化等</p><h3 id="data-cleaning"><a href="#data-cleaning" class="headerlink" title="data cleaning"></a>data cleaning</h3><p>sklearn 提供了一个处理缺失值的类<strong>Imputer</strong>，其实在实际应用中，这一个步骤还是需要灵活应用，具体根据实际情况来处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line">imputer = Imputer(strategy = <span class="string">'median'</span>) <span class="comment"># 根据中位数填充</span></span><br><span class="line"><span class="comment"># 让数框只包含数值类型</span></span><br><span class="line">housing_num = housing.drop(<span class="string">'ocean_proximity'</span>,axis=<span class="number">1</span>)</span><br><span class="line">imputer.fit_transform(housing_num)</span><br><span class="line"><span class="comment"># 后续处理的时候，只需要</span></span><br><span class="line"><span class="comment"># imputer.transform(housing_new)</span></span><br></pre></td></tr></table></figure></p><h3 id="文本、字符型、category特征的处理"><a href="#文本、字符型、category特征的处理" class="headerlink" title="文本、字符型、category特征的处理"></a>文本、字符型、category特征的处理</h3><p>对待这类特征，首先大部分的模型只能处理数值型的向量，所以需要量化这些特征，但量化后就会存在一个问题，有了数字，那么在计算机的眼里，这些category就有了大小，同时就会产生不同的度量，比如颜色红、黄、蓝，不能说谁比谁大，但是数值编码红黄蓝分别为1,2，3，那你就默认了黄与红之间差1，红与蓝差2，这样在实际中是不存在这种关系的，一种好的解决办法就是hotonecode—热编码。</p><p>sklearn提供的编码机制<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通的数值化编码</span></span><br><span class="line">form sklearn.preprocesing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">encoder = LabelEncoder()</span><br><span class="line">housing_cat_encoded = encoder.fit_transform(housing_cat)</span><br><span class="line"><span class="comment"># 热编码</span></span><br><span class="line">form sklearn.preprocesing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">encoder = OneHotEncoder()</span><br><span class="line"><span class="comment"># 这地方将上面数值化编码后的变量再次使用热编码，但是需要注意的地方是，此处传入的参数需要是一个二维数组，返回的是一个稀疏矩阵</span></span><br><span class="line">housing_cat_1hot = encoder.fit_transform(housing_cat_encoded.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 直接热编码</span></span><br><span class="line">form sklearn.preprocesing <span class="keyword">import</span> LabelBinarizer</span><br><span class="line">encoder = LabelBinarizer()</span><br><span class="line">housing_cat_1hot = encoder.fit_transform(housing_cat)</span><br></pre></td></tr></table></figure></p><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>这里是将数值型（到了这一步，应该都已经是数字型）的变量统一映射到一个范围，这样做对基于度量的一些模型是很有必要的。主要有两种方法</p><ul><li>MinMaxScaler <em>统一映射到一个范围，但是对outlier比较敏感</em></li><li>StandardScaler <em>每个特征都标准化成均值为0，方差为1的数值，但是特征之间的映射范围可能不会一致，对outlier不敏感</em><h3 id="Pipline"><a href="#Pipline" class="headerlink" title="Pipline"></a>Pipline</h3>学会使用pipline，序列化地数据处理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandarScaler</span><br><span class="line"></span><br><span class="line">num_attribes = list[<span class="string">'数值型特征'</span>]</span><br><span class="line">num_pipeline = Pipeline([</span><br><span class="line">            (<span class="string">'selector'</span>,DataFrameSelectot(num_attribes)),</span><br><span class="line">            (<span class="string">'Imputer'</span>,Imputer(strategy=<span class="string">'median'</span>)),</span><br><span class="line">            (<span class="string">'std_scaler'</span>,StandarScaler()),</span><br><span class="line">])</span><br><span class="line"><span class="comment"># 传入数据之后，按照顺序依次处理，上一个执行的输出是下一个执行的输入</span></span><br><span class="line">housing_num_tr = num_pipeline.fit_transform(housing_num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以并行执行</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> FeatureUnion</span><br><span class="line"></span><br><span class="line">cat_attribes = list[<span class="string">'ocean_proximity'</span>]</span><br><span class="line">cat_pipeline = Pipeline([</span><br><span class="line">        (<span class="string">'selector'</span>,DataFrameSelectot(cat_attribs)),</span><br><span class="line">        (<span class="string">'label_binarizer'</span>,cat_pipeline),</span><br><span class="line">])</span><br><span class="line">full_pipeline = FeatureUnion(transform_list = [</span><br><span class="line">            (<span class="string">'num_pipeline'</span>,num_pipeline),</span><br><span class="line">            (<span class="string">'cat_pipeline'</span>,cat_pipeline),</span><br><span class="line">])</span><br><span class="line">housing_prepared = full_pipeline.fit_transform(housing)</span><br></pre></td></tr></table></figure></li></ul><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>这一步，开始可以多尝试几个模型，选择一两个效果较好的重点调整。调整模型的参数以及观察模型的效果主要靠交叉验证。</p><ol><li><p><strong>方式一</strong>直接做交叉验证，得出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line">cross_val_score(clf,housing_prepared,housing_labels,</span><br><span class="line">                scoring=<span class="string">'neg_mean_squared_error'</span>,cv=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># clf : 分类器、学习器</span></span><br><span class="line"><span class="comment"># 直接输出10次交叉验证的结果</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方式二</strong> 方便调整模型的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="comment"># 设置调整的参数</span></span><br><span class="line">param_grid = [&#123;<span class="string">'opt1'</span>:value1,<span class="string">'opt2'</span>:value2&#125;&#123;<span class="string">'opt3'</span>:value3,<span class="string">'opt4'</span>:value4&#125;]</span><br><span class="line">grid_search = GridSearchCV(clf,param_grid,cv=<span class="number">5</span>,scoring=<span class="string">''</span>)</span><br><span class="line">grid_search.fit(housing_prepared,housing_labels)</span><br></pre></td></tr></table></figure></li><li><p><strong>方式三</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"></span><br><span class="line">cv = StratifiedKFold(n_splits=k)</span><br><span class="line"><span class="keyword">for</span> train_index,test_index <span class="keyword">in</span> cv :</span><br><span class="line">        clf.fit()</span><br><span class="line">        proba = clf.predict_proba()</span><br></pre></td></tr></table></figure></li></ol><h2 id="保存最终的模型"><a href="#保存最终的模型" class="headerlink" title="保存最终的模型"></a>保存最终的模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"><span class="comment"># saving</span></span><br><span class="line">joblib.dump(my_model,<span class="string">'my_model.pkl'</span>)</span><br><span class="line"><span class="comment"># loading</span></span><br><span class="line">my_model = joblib.load(<span class="string">'my_model.pkl'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络（CNN）</title>
      <link href="/2017/12/27/cnn/"/>
      <url>/2017/12/27/cnn/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="卷积神经网络（CNN）"><a href="#卷积神经网络（CNN）" class="headerlink" title="卷积神经网络（CNN）"></a>卷积神经网络（CNN）</h1><h2 id="卷积的定义"><a href="#卷积的定义" class="headerlink" title="卷积的定义"></a>卷积的定义</h2><h3 id="卷积的数学定义"><a href="#卷积的数学定义" class="headerlink" title="卷积的数学定义"></a>卷积的数学定义</h3><ol><li><strong>连续形式</strong> $ s(t)= \int x(a)w(t-a)da$, 记作$s(t)=(x\ast w)(t) $</li><li><strong>离散形式</strong> $ s(t)=\sum_a x(a)w(t-a)$</li></ol><p>x通常叫做输入，w称为核函数，输出一般叫做特征映射。卷积有对称性质，即$ (x\ast w)(t) = (w\ast x)(t)$, 这个根据定义，然后对积分变量换元一下很容易证明。</p><ol start="3"><li><strong>神经网络中的卷积</strong> 这里的卷积其实就是一个矩阵，放到每一层的神经网络中就是网络中的部分权重。<img src="http://img.chuansong.me/mmbiz_gif/KmXPKA19gW9zxnWHp2icg4gictHp8hicpkV63DudKRviaBExrRwZppOQiaP1S63q3V1MYDdoZiaLm7RQvCrgYt7FiaUsw/0?wx_fmt=gif" alt="如图"></li></ol><h2 id="Why-CNN？"><a href="#Why-CNN？" class="headerlink" title="Why CNN？"></a>Why CNN？</h2><p>cnn与图像之间有几点相似性：</p><ol><li>图像中的一些特征要比整个图像小很多，比如人的眼睛，鸟的嘴巴…,而卷积恰好能描述这种特点</li><li>一些特征在图像中我只关心它有没有出现，并不关心它出现在图像中的具体位置，比如人脸识别时人脸可能出现在左上角，也可能照片不太规范出现在了图像的中间，CNN中卷积矩阵作用在图像上时也有这种特点</li><li>下采样，也就是说，一张图像，你把它的分辨率适当的调低，并不影响人大致地分辨出图像的内容，而这一点在CNN中max-pooling很像。</li></ol><h3 id="CNN的一些特点"><a href="#CNN的一些特点" class="headerlink" title="CNN的一些特点"></a>CNN的一些特点</h3><ol><li><strong>稀疏交互:</strong> 相比于全连接神经网络，CNN每一层的权重要稀疏很多 </li><li><strong>参数共享:</strong> 每一层的参数都只有卷积矩阵</li><li><strong>等变表示:</strong> 如果函数$f(x)$和$g(x)$满足$f(g(x))=g(f(x)),$ 我们就说$f$ 对 $g$ 具有等变性。</li></ol><h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p>池化函数使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出，当输入做出少量平移时，池化函数后的输出大多数并不会改变太多。</p><p>常用的池化函数：</p><ul><li>max-pooling</li><li>相邻矩形区域内的平均值</li><li>$L_2$ 范数</li><li>基于距中心像素的加权平均</li></ul><p>卷积和池化可以被视为一种无限强的先验</p><h2 id="基本卷积函数的变体"><a href="#基本卷积函数的变体" class="headerlink" title="基本卷积函数的变体"></a>基本卷积函数的变体</h2><p>使用卷积网络时的一些细节上的不同</p><h3 id="步幅（stride）"><a href="#步幅（stride）" class="headerlink" title="步幅（stride）"></a>步幅（stride）</h3><p>使用卷积矩阵对图像操作时的，每一步移动的大小，也被视为下采样。</p><h3 id="零填充"><a href="#零填充" class="headerlink" title="零填充"></a>零填充</h3><p>从前面的分析，可以看出，每一层对图像使用卷积操作的时候，图像的大小都会减少，卷积矩阵越大，减少的就越多，这样的话如果网络太深，最后输出的图像的大小就会变得非常小，这样就限制了网络的深度或者不能使用规模太大的卷积矩阵。所以一般都会在图像的边缘填充零。</p><ol><li><strong>有效卷积</strong> 不作零填充</li><li><strong>相同卷积</strong> 边缘填充零，使得映射后的图像大小不改变。<img src="http://img.chuansong.me/mmbiz_gif/KmXPKA19gW9zxnWHp2icg4gictHp8hicpkVdWwwMdmFXkGrLx5VTXhMQTxNcbln3weXeDfsFKH575ic97gHqpLCwXQ/0?wx_fmt=gif" alt="image"></li><li><strong>全卷积</strong> </li></ol><h3 id="局部连接"><a href="#局部连接" class="headerlink" title="局部连接"></a>局部连接</h3><p>下图上中下分别是局部连接、卷积、全连接<img src="http://xiaosheng.me/img/article/article_65_3.png" alt="局部连接"></p><h3 id="平铺卷积"><a href="#平铺卷积" class="headerlink" title="平铺卷积"></a>平铺卷积</h3><p>下图上中下分别为局部连接、平铺卷积、卷积<img src="http://xiaosheng.me/img/article/article_65_5.png" alt="image"></p><h2 id="CNN的其他应用"><a href="#CNN的其他应用" class="headerlink" title="CNN的其他应用"></a>CNN的其他应用</h2><p>比如，AlphaGo, 语音、自然语言处理都有应用，关键怎么构造卷积，可参考<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2016/Lecture/CNN%20(v2" target="_blank" rel="noopener">台大李宏毅最后几页PPT</a>.pdf)</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
