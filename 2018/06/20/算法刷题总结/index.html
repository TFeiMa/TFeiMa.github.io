<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">


  <meta name="baidu-site-verification" content="ZzeYB5nB9Y">


  <meta name="baidu-site-verification" content="”ZzeYB5nB9Y“/">


  <meta name="google-site-verification" content="T3WdGKE58QRxIaM-hmJyQYxQU034EoB3YHlSkgq0a0g">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="true">








  <meta name="baidu-site-verification" content="ZzeYB5nB9Y">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="leetcode 算法,">










<meta name="description" content="持续更新。。。">
<meta name="keywords" content="leetcode 算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法刷题总结（Python实现）">
<meta property="og:url" content="http://TFeiMa.github.io/2018/06/20/算法刷题总结/index.html">
<meta property="og:site_name" content="phi的博客">
<meta property="og:description" content="持续更新。。。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-02T10:51:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法刷题总结（Python实现）">
<meta name="twitter:description" content="持续更新。。。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://TFeiMa.github.io/2018/06/20/算法刷题总结/">





  <title>算法刷题总结（Python实现） | phi的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/TFeiMa"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">phi的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">慢就是快！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://TFeiMa.github.io/2018/06/20/算法刷题总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="phi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phi的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法刷题总结（Python实现）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T19:49:29+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11.7k
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  持续更新。。。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[toc]</p>
<h1 id="算法刷题总结"><a href="#算法刷题总结" class="headerlink" title="算法刷题总结"></a>算法刷题总结</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h3><p>节点类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line"><span class="comment">#         使用一个辅助节点指向头结点</span></span><br><span class="line">        pstart = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pstart.next = head</span><br><span class="line">        pend = head</span><br><span class="line">        p = head.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            temp = pstart.next</span><br><span class="line">            pre = pstart</span><br><span class="line"><span class="comment">#             找到待插入的位置，需要保留两个节点地址</span></span><br><span class="line">            <span class="keyword">while</span> temp != p <span class="keyword">and</span> temp.val&lt;p.val:</span><br><span class="line">                pre = temp</span><br><span class="line">                temp = temp.next</span><br><span class="line">            <span class="keyword">if</span> temp == p:pend = p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pend.next = p.next</span><br><span class="line">                p.next = temp</span><br><span class="line">                pre.next = p</span><br><span class="line">            p = pend.next</span><br><span class="line">        head = pstart.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line"><span class="comment">#         使用一个辅助节点指向头结点</span></span><br><span class="line">        pstart = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pstart.next = head</span><br><span class="line">        pend = pstart</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> pend.next:</span><br><span class="line">            p,min_p = pend.next,pend.next</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                <span class="keyword">if</span> p.val&lt;min_p.val:</span><br><span class="line">                    min_p = p</span><br><span class="line">                p = p.next</span><br><span class="line">            pend.next.val,min_p.val = min_p.val,pend.next.val</span><br><span class="line">            pend = pend.next</span><br><span class="line">        head = pstart.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bubbleSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        p = <span class="keyword">None</span></span><br><span class="line">        is_change = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> p != head.next <span class="keyword">and</span> is_change:</span><br><span class="line">            q = head</span><br><span class="line">            is_change = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> q.next <span class="keyword">and</span> q.next != p:</span><br><span class="line">                <span class="keyword">if</span> q.val &gt; q.next.val:</span><br><span class="line">                    q.val,q.next.val = q.next.val,q.val</span><br><span class="line">                    is_change = <span class="keyword">True</span></span><br><span class="line">                q = q.next</span><br><span class="line">            p = q</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:<span class="keyword">return</span> head</span><br><span class="line">        self.quick_sort_list(head,<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort_list</span><span class="params">(self,head,tail)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head != tail <span class="keyword">and</span> head.next != tail:</span><br><span class="line">            m = self.partition(head,tail)</span><br><span class="line">            self.quick_sort_list(head,m)</span><br><span class="line">            self.quick_sort_list(m.next,tail)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self,p,r)</span>:</span></span><br><span class="line">        pivot = p</span><br><span class="line">        q = p</span><br><span class="line">        p = p.next</span><br><span class="line">        <span class="keyword">while</span> p != r:</span><br><span class="line">            <span class="keyword">if</span> p.val&lt;pivot.val:</span><br><span class="line">                q = q.next</span><br><span class="line">                q.val,p.val = p.val,q.val</span><br><span class="line">                </span><br><span class="line">            p = p.next</span><br><span class="line">        pivot.val,q.val = q.val,pivot.val</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode23-合并K个有序链表"><a href="#LeetCode23-合并K个有序链表" class="headerlink" title="LeetCode23 合并K个有序链表"></a>LeetCode23 合并K个有序链表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        K = len(lists)</span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> K&gt;<span class="number">1</span>:</span><br><span class="line">            n = (K+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(K&gt;&gt;<span class="number">1</span>):</span><br><span class="line">                lists[i] = self.merge_two_list(lists[i],lists[i+n])</span><br><span class="line">            K = n</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_two_list</span><span class="params">(self,l1,l2)</span>:</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.next = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            cur.next = l2</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode82-删除排序链表中的重复元素"><a href="#LeetCode82-删除排序链表中的重复元素" class="headerlink" title="LeetCode82 删除排序链表中的重复元素"></a>LeetCode82 删除排序链表中的重复元素</h3><blockquote>
<p>类似与集合操作</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = head</span><br><span class="line">        cur = head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> pre.val == cur.val:</span><br><span class="line">                </span><br><span class="line">                cur = cur.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            pre.next = cur</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        pre.next = cur</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode83-删除排序链表中的重复元素II"><a href="#LeetCode83-删除排序链表中的重复元素II" class="headerlink" title="LeetCode83 删除排序链表中的重复元素II"></a>LeetCode83 删除排序链表中的重复元素II</h3><blockquote>
<p>只要有重复的，重复的都要删除，不保留</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        h = ListNode(<span class="number">-1</span>)</span><br><span class="line">        h.next = head</span><br><span class="line">        pre = h</span><br><span class="line">        cur = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            du = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.next.val == cur.val:</span><br><span class="line">                du = <span class="keyword">True</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> du:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            pre.next = cur</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        pre.next = cur</span><br><span class="line">        <span class="keyword">return</span> h.next</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode138-复制带随机指针的链表"><a href="#LeetCode138-复制带随机指针的链表" class="headerlink" title="LeetCode138. 复制带随机指针的链表"></a>LeetCode138. 复制带随机指针的链表</h3><blockquote>
<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。<br>要求返回这个链表的深度拷贝。</p>
</blockquote>
<hr>
<p>分三步进行：</p>
<ol>
<li>生成每个节点的复制，并将其插入后面</li>
<li>再次遍历新的链表，若当前节点有随机指针，那么复制节点的随机指针为当前节点随机指针指向节点的下一个节点</li>
<li>断开</li>
</ol>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class RandomListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#         self.random = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: RandomListNode</span></span><br><span class="line"><span class="string">        :rtype: RandomListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            temp = RandomListNode(p.label)</span><br><span class="line">            temp.next = p.next</span><br><span class="line">            p.next = temp</span><br><span class="line">            p = temp.next</span><br><span class="line">        p1,p2 = head,head.next</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            <span class="keyword">if</span> p1.random:</span><br><span class="line">                p2.random = p1.random.next</span><br><span class="line">            </span><br><span class="line">            p1 = p2.next</span><br><span class="line">            <span class="keyword">if</span> p1:</span><br><span class="line">                p2 = p1.next</span><br><span class="line">            </span><br><span class="line">        p1,p2 = head,head.next</span><br><span class="line">        res = head.next</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            p1.next = p2.next</span><br><span class="line">            <span class="keyword">if</span> p1:</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> p1:</span><br><span class="line">                p2.next = p1.next</span><br><span class="line">                p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode141-环形链表"><a href="#LeetCode141-环形链表" class="headerlink" title="LeetCode141. 环形链表"></a>LeetCode141. 环形链表</h3><blockquote>
<p>给定一个链表，判断链表中是否有环。<br><code>快慢指针</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        p1,p2 = head,head</span><br><span class="line">        <span class="keyword">while</span> p2 <span class="keyword">and</span> p1:</span><br><span class="line">            <span class="keyword">if</span> p2.next <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode142-环形链表-II"><a href="#LeetCode142-环形链表-II" class="headerlink" title="LeetCode142. 环形链表 II"></a>LeetCode142. 环形链表 II</h3><blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        p1,p2 = head,head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p2.next <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> p2.next.next <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            </span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        p2 = p2.next</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p2 = p2.next</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        p1,p2 = head,head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            p2 = p2.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode109-有序链表转换二叉搜索树"><a href="#LeetCode109-有序链表转换二叉搜索树" class="headerlink" title="LeetCode109. 有序链表转换二叉搜索树"></a>LeetCode109. 有序链表转换二叉搜索树</h3><blockquote>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。<br>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p = head</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            p = p.next</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        head = [head]</span><br><span class="line">        root = self.sorted_list2bst(head,<span class="number">0</span>,length<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sorted_list2bst</span><span class="params">(self,head,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start&gt;end: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        m = (start+end)&gt;&gt;<span class="number">1</span></span><br><span class="line">        left = self.sorted_list2bst(head,start,m<span class="number">-1</span>)</span><br><span class="line">        root = TreeNode(head[<span class="number">0</span>].val)</span><br><span class="line">        root.left = left</span><br><span class="line">        head[<span class="number">0</span>] = head[<span class="number">0</span>].next</span><br><span class="line">        root.right = self.sorted_list2bst(head,m+<span class="number">1</span>,end)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode114-二叉树展开为链表"><a href="#LeetCode114-二叉树展开为链表" class="headerlink" title="LeetCode114. 二叉树展开为链表"></a>LeetCode114. 二叉树展开为链表</h3><blockquote>
<p>给定一个二叉树，原地将它展开为链表。<br><code>前序遍历</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">        stack.append(root)</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            p = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> pre:</span><br><span class="line">                pre.left = <span class="keyword">None</span></span><br><span class="line">                pre.right = p</span><br><span class="line">            <span class="keyword">if</span> p.right: stack.append(p.right)</span><br><span class="line">            <span class="keyword">if</span> p.left: stack.append(p.left)</span><br><span class="line">            <span class="comment"># p.right = None</span></span><br><span class="line">            pre = p</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode116-填充同一层的兄弟节点"><a href="#LeetCode116-填充同一层的兄弟节点" class="headerlink" title="LeetCode116. 填充同一层的兄弟节点"></a>LeetCode116. 填充同一层的兄弟节点</h3><blockquote>
<p>给定一个二叉树填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>初始状态下，所有 next 指针都被设置为 NULL。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param root, a tree link node</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">        start = root</span><br><span class="line">        <span class="keyword">while</span> start.left:</span><br><span class="line">            cur = start</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                cur.left.next = cur.right</span><br><span class="line">                <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.right.next = cur.next.left</span><br><span class="line">                cur = cur.next</span><br><span class="line">            start = start.left</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode124-二叉树中的最大路径和"><a href="#LeetCode124-二叉树中的最大路径和" class="headerlink" title="LeetCode124. 二叉树中的最大路径和"></a>LeetCode124. 二叉树中的最大路径和</h3><blockquote>
<p>给定一个非空二叉树，返回其最大路径和。<br>本题中，<strong>路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="number">-10</span>**<span class="number">6</span>]</span><br><span class="line">        self.pathsum_core(root,res)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathsum_core</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = max(self.pathsum_core(root.left,res),<span class="number">0</span>)</span><br><span class="line">        right = max(self.pathsum_core(root.right,res),<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 计算当前节点作为根节点时得到的最大和</span></span><br><span class="line">        res[<span class="number">0</span>] = max(res[<span class="number">0</span>],left + right + root.val)</span><br><span class="line">        <span class="comment"># 当前节点作为一个左（右）子节点返回的时候，智能包含左子树或者右子树的返回值中的一个。</span></span><br><span class="line">        <span class="keyword">return</span> max(left,right)+root.val</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode236-二叉树的最近公共祖先"><a href="#LeetCode236-二叉树的最近公共祖先" class="headerlink" title="LeetCode236. 二叉树的最近公共祖先"></a>LeetCode236. 二叉树的最近公共祖先</h3><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> root) <span class="keyword">or</span> root==p <span class="keyword">or</span> root==q: <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><h3 id="LeetCode33-搜索旋转排序数组-无重复数字"><a href="#LeetCode33-搜索旋转排序数组-无重复数字" class="headerlink" title="LeetCode33 搜索旋转排序数组(无重复数字)"></a>LeetCode33 搜索旋转排序数组(无重复数字)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        l,r = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;=r:</span><br><span class="line">            m = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">if</span> nums[l] &lt;= nums[m]:</span><br><span class="line">                <span class="keyword">if</span> nums[l]&lt;=target&lt;nums[m]:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[m]&lt;target&lt;=nums[r]:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode81-搜索旋转排序数组-II（有重复数字）"><a href="#LeetCode81-搜索旋转排序数组-II（有重复数字）" class="headerlink" title="LeetCode81. 搜索旋转排序数组 II（有重复数字）"></a>LeetCode81. 搜索旋转排序数组 II（有重复数字）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;=r:</span><br><span class="line">            m = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt;nums[m]:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]:</span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt; target &lt;=nums[r]:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = l+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode162-寻找峰值"><a href="#LeetCode162-寻找峰值" class="headerlink" title="LeetCode162. 寻找峰值"></a>LeetCode162. 寻找峰值</h3><blockquote>
<p>峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
</blockquote>
<hr>
<p><strong>分析：</strong><br>如果nums[mid] &gt; nums[mid+1]，则在mid之前一定存在峰值元素<br>如果nums[mid] &lt; nums[mid+1]，则在mid+1之后一定存在峰值元素</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;nums[mid+<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode852-山脉数组的峰顶索引"><a href="#LeetCode852-山脉数组的峰顶索引" class="headerlink" title="LeetCode852. 山脉数组的峰顶索引"></a>LeetCode852. 山脉数组的峰顶索引</h3><blockquote>
<p>我们把符合下列属性的数组 A 称作山脉：</p>
<ul>
<li>A.length &gt;= 3</li>
<li>存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(A)</span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[mid]&gt;A[mid+<span class="number">1</span>]:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="LeetCode56-合并区间"><a href="#LeetCode56-合并区间" class="headerlink" title="LeetCode56. 合并区间"></a>LeetCode56. 合并区间</h3><blockquote>
<p>给出一个区间的集合，请合并所有重叠的区间。<br><code>奇技淫巧</code></p>
</blockquote>
<hr>
<ul>
<li>首先取出每个区间的左边和右边，并对其排序</li>
<li>如果l[i+1]&gt;r[i],说明第l_(i+1)个区间一定在前面i个区间的右边，并且中间有gap，不连续，就将前一次不连续的位置开始到i记录到结果中</li>
<li>j记录当前不连续区间的开始位置</li>
</ul>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = [],[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            l.append(i.start)</span><br><span class="line">            r.append(i.end)</span><br><span class="line">        l,r = sorted(l),sorted(r)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(intervals)):</span><br><span class="line">            <span class="keyword">if</span> i == len(intervals)<span class="number">-1</span> <span class="keyword">or</span> l[i+<span class="number">1</span>] &gt; r[i]:</span><br><span class="line">                res.append([l[j],r[i]])</span><br><span class="line">                j = i+<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode57-插入区间"><a href="#LeetCode57-插入区间" class="headerlink" title="LeetCode57. 插入区间"></a>LeetCode57. 插入区间</h3><blockquote>
<p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。<br><code>细节实现</code></p>
</blockquote>
<hr>
<p>比较list中每个区间的头，先找到第一个比newInterval.start大的位置，所以需要在这个前面插入，然后判断在这个位置插入的时候是否有区间可以与其合并，若可以合并，就合并成为新的newInterval，并且在list中删去与其合并的区间，直到不能合并位置，然后插入。</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :type newInterval: Interval</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(intervals)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> [newInterval]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            <span class="keyword">if</span> intervals[i].start&gt;=newInterval.start:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        l = i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> intervals <span class="keyword">and</span> ((l&gt;=<span class="number">0</span> <span class="keyword">and</span> intervals[l].end&gt;=newInterval.start) <span class="keyword">or</span> (l&lt;n<span class="number">-1</span> <span class="keyword">and</span> intervals[l+<span class="number">1</span>].start&lt;=newInterval.end)):</span><br><span class="line">            <span class="keyword">if</span> l&gt;=<span class="number">0</span> <span class="keyword">and</span> intervals[l].end&gt;=newInterval.start:</span><br><span class="line">                newInterval.start = min(intervals[l].start,newInterval.start)</span><br><span class="line">                newInterval.end = max(intervals[l].end,newInterval.end)</span><br><span class="line">                intervals.pop(l)</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> l&lt;n<span class="number">-1</span> <span class="keyword">and</span> intervals[l+<span class="number">1</span>].start&lt;=newInterval.end:</span><br><span class="line">                newInterval.end = max(intervals[l+<span class="number">1</span>].end,newInterval.end)</span><br><span class="line">                newInterval.start = min(intervals[l+<span class="number">1</span>].start,newInterval.start)</span><br><span class="line">                intervals.pop(l+<span class="number">1</span>)</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        intervals.insert(l+<span class="number">1</span>,newInterval)</span><br><span class="line">        <span class="keyword">return</span> intervals</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-128-最长连续序列"><a href="#LeetCode-128-最长连续序列" class="headerlink" title="LeetCode 128 最长连续序列"></a>LeetCode 128 最长连续序列</h3><blockquote>
<p>给定一个未排序的整数数组，找出最长连续序列的长度。<br>要求算法的时间复杂度为 O(n)。</p>
</blockquote>
<p><code>哈希表</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_table = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            hash_table.add(i)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            j = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j <span class="keyword">in</span> hash_table:</span><br><span class="line">                hash_table.remove(j)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            j = i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> j <span class="keyword">in</span> hash_table:</span><br><span class="line">                hash_table.remove(j)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">            max_len = length <span class="keyword">if</span> length &gt; max_len <span class="keyword">else</span> max_len</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode560-和为K的子数组"><a href="#LeetCode560-和为K的子数组" class="headerlink" title="LeetCode560. 和为K的子数组"></a>LeetCode560. 和为K的子数组</h3><blockquote>
<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。<br><code>哈希表</code></p>
</blockquote>
<hr>
<p>用一个哈希表记录从0开始到当前位置数组的累加和sum(nums[0:i])的值出现的次数，若在第i个位置的和为sum_，那么sum_-k曾经出现过的话，出现的位置j到i的连续子数组的和肯定为k</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        d = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        sum_,count_ = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum_ += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sum_ - k <span class="keyword">in</span> d:</span><br><span class="line">                count_ += d[sum_ - k]</span><br><span class="line">            <span class="keyword">if</span> sum_ <span class="keyword">in</span> d:</span><br><span class="line">                d[sum_] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[sum_] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count_</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="LeetCode5-最长回文字符串"><a href="#LeetCode5-最长回文字符串" class="headerlink" title="LeetCode5 最长回文字符串"></a>LeetCode5 最长回文字符串</h3><p><code>回文</code>，<code>马拉车算法</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ss = <span class="string">'#'</span>.join(s)</span><br><span class="line">        ss = <span class="string">'$#'</span> + ss + <span class="string">'#@'</span></span><br><span class="line">        n = len(ss)</span><br><span class="line">        p = [<span class="number">1</span>]*n</span><br><span class="line">        lc,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        max_center,max_r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line">            p[i] = min(p[<span class="number">2</span>*lc-i],right-i) <span class="keyword">if</span> right-i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(ss[i+p[i]] == ss[i-p[i]]):</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i+p[i] &gt; right:</span><br><span class="line">                lc = i</span><br><span class="line">                right = i+p[i] <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> max_r &lt; p[i]:</span><br><span class="line">                max_center = i</span><br><span class="line">                max_r = p[i]</span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ss[max_center-max_r+<span class="number">1</span>:max_center+max_r<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="string">'#'</span>:</span><br><span class="line">                s = s + i</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode10-正则表达式匹配"><a href="#LeetCode10-正则表达式匹配" class="headerlink" title="LeetCode10. 正则表达式匹配"></a>LeetCode10. 正则表达式匹配</h3><blockquote>
<p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘* ‘ 的正则表达式匹配。</p>
<ul>
<li>‘.’ 匹配任意单个字符。</li>
<li>‘* ‘ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。<br>说明:</li>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># m,n = len(s),len(p)</span></span><br><span class="line">        s = s+<span class="string">'$'</span></span><br><span class="line">        p = p+<span class="string">'$'</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.is_match_core(s,p,i,j)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_match_core</span><span class="params">(self,s,p,i,j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p[j] == <span class="string">'$'</span>:</span><br><span class="line">            <span class="keyword">return</span> s[i] == <span class="string">'$'</span></span><br><span class="line">        <span class="keyword">if</span> p[j+<span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">if</span> s[i] == p[j] <span class="keyword">or</span> (p[j]==<span class="string">'.'</span> <span class="keyword">and</span> s[i]!=<span class="string">'$'</span>):</span><br><span class="line">                <span class="keyword">return</span> self.is_match_core(s,p,i+<span class="number">1</span>,j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> p[j] == s[i] <span class="keyword">or</span> (p[j]==<span class="string">'.'</span> <span class="keyword">and</span> s[i]!=<span class="string">'$'</span>):</span><br><span class="line">                <span class="keyword">if</span> self.is_match_core(s,p,i,j+<span class="number">2</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.is_match_core(s,p,i,j+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode43-字符串相乘"><a href="#LeetCode43-字符串相乘" class="headerlink" title="LeetCode43. 字符串相乘"></a>LeetCode43. 字符串相乘</h3><blockquote>
<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num1: str</span></span><br><span class="line"><span class="string">        :type num2: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(num1),len(num2)</span><br><span class="line">        arr = [<span class="number">0</span>]*(m+n)</span><br><span class="line">        <span class="comment"># carray = 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            carray = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                product = int(num1[i])*int(num2[j]) + carray + arr[i+j+<span class="number">1</span>]</span><br><span class="line">                arr[i+j+<span class="number">1</span>] = product%<span class="number">10</span></span><br><span class="line">                carray = int(product/<span class="number">10</span>)</span><br><span class="line">            arr[i+j] = carray</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m+n<span class="number">-1</span> <span class="keyword">and</span> arr[i] == <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        arr = list(map(str,arr))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(arr[i:])</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode44-通配符匹配"><a href="#LeetCode44-通配符匹配" class="headerlink" title="LeetCode44 通配符匹配"></a>LeetCode44 通配符匹配</h3><blockquote>
<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<ul>
<li>‘?’ 可以匹配任何单个字符。</li>
<li>‘ *’ 可以匹配任意字符串（包括空字符串）。<br>说明:</li>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li>
</ul>
</blockquote>
<hr>
<ol>
<li>若当前比较的两个字符相同，或者p[j]=’?’,两者都往下走</li>
<li>若p[j]==’<em>‘,这时候先保留当前i和j的位置，即为sstar,pstar,同时j往下走一步（先尝试让 </em> 匹配空格），若接下来的步骤都能够匹配就继续下去，否则，让i=sstar+1(匹配一个字符，还不行，匹配两个字符，继续下去，直到s扫描完或者第一个字符匹配成功),同时记录下sstar,以防后面即使出现s[i]==p[j]匹配成功，但其实这样有可能后面的字符不满足，多以还需尝试将这个字符也略过的情况。</li>
</ol>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(s),len(p)</span><br><span class="line">        <span class="comment"># ‘#’作为字符串结束的标识</span></span><br><span class="line">        s,p = s+<span class="string">'#'</span>,p+<span class="string">'#'</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        pstar,sstar = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m:</span><br><span class="line">            <span class="keyword">if</span> s[i]==p[j] <span class="keyword">or</span> p[j] == <span class="string">"?"</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="comment"># 略过多个*连续的情况</span></span><br><span class="line">                <span class="keyword">while</span> p[j]==<span class="string">'*'</span>:</span><br><span class="line">                    pstar,j = j,j+<span class="number">1</span></span><br><span class="line">                sstar = i</span><br><span class="line">            <span class="keyword">elif</span> pstar&gt;<span class="number">-1</span>:</span><br><span class="line">                j = pstar+<span class="number">1</span></span><br><span class="line">                sstar,i = sstar+<span class="number">1</span>,sstar</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> p[j]==<span class="string">'*'</span>: j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若能够匹配，两个字符串都应该走到尾了。</span></span><br><span class="line">        <span class="keyword">return</span> s[i] == p[j]</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode93-复原IP地址"><a href="#LeetCode93-复原IP地址" class="headerlink" title="LeetCode93. 复原IP地址"></a>LeetCode93. 复原IP地址</h3><blockquote>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br><strong>示例：</strong><br>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ip,res = <span class="string">''</span>,[]</span><br><span class="line">        self.dfs(s,<span class="number">0</span>,<span class="number">0</span>,ip,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,s,start,step,ip,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(s) <span class="keyword">and</span> step == <span class="number">4</span>:</span><br><span class="line">            res.append(ip[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> len(s) - start  &gt; (<span class="number">4</span>-step)*<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> len(s) - start  &lt; <span class="number">4</span>-step:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> i&lt;start+<span class="number">3</span>:</span><br><span class="line">            num = num*<span class="number">10</span> + int(s[i])</span><br><span class="line">            <span class="keyword">if</span> num &lt;= <span class="number">255</span>:</span><br><span class="line">                ip += s[i]</span><br><span class="line">                self.dfs(s,i+<span class="number">1</span>,step+<span class="number">1</span>,ip+<span class="string">'.'</span>,res)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="LeetCode84-柱状图中最大的矩形"><a href="#LeetCode84-柱状图中最大的矩形" class="headerlink" title="LeetCode84. 柱状图中最大的矩形"></a>LeetCode84. 柱状图中最大的矩形</h3><blockquote>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><code>递增栈</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type heights: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(heights):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> heights[stack[<span class="number">-1</span>]]&lt;=heights[i]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line"><span class="comment"># 此时的栈顶元素的位置是从cur开始向左数，第一个小于heights[cur]的位置，</span></span><br><span class="line"><span class="comment"># i是从cur开始向右数，第一个小于heights[cur]的位置</span></span><br><span class="line">                width = i <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> i-stack[<span class="number">-1</span>]<span class="number">-1</span></span><br><span class="line">                res = max(res,heights[cur]*width)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode85-最大矩形"><a href="#LeetCode85-最大矩形" class="headerlink" title="LeetCode85. 最大矩形"></a>LeetCode85. 最大矩形</h3><blockquote>
<p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br><code>递增栈</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res  = <span class="number">0</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        height = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            stack = []</span><br><span class="line">            com = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; n+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> com:</span><br><span class="line">                    height[j] = <span class="number">1</span>+height[j] <span class="keyword">if</span> j&lt;n <span class="keyword">and</span> matrix[i][j]==<span class="string">'1'</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    com = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> height[stack[<span class="number">-1</span>]]&lt;=height[j]:</span><br><span class="line">                    stack.append(j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur = stack.pop()</span><br><span class="line">                    width = j <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> j - stack[<span class="number">-1</span>]<span class="number">-1</span></span><br><span class="line">                    res = max(res,height[cur]*width)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                com = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="leetcode150-逆波兰数"><a href="#leetcode150-逆波兰数" class="headerlink" title="leetcode150 逆波兰数"></a>leetcode150 逆波兰数</h3><blockquote>
<p>代码在leetcode.com过了，leetcode-cn.com没过。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type tokens: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        oper = [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>]</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> oper:</span><br><span class="line">                stack.append(token)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 = int(stack.pop())</span><br><span class="line">                p1 = int(stack.pop())</span><br><span class="line">                <span class="keyword">if</span> token == <span class="string">'+'</span>:</span><br><span class="line">                    res = p1+p2</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">'-'</span>:</span><br><span class="line">                    res = p1-p2</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">'*'</span>:</span><br><span class="line">                    res = p1*p2</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = int(p1/p2)</span><br><span class="line">                stack.append(str(res))</span><br><span class="line">        res = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode224-基本计算器"><a href="#LeetCode224-基本计算器" class="headerlink" title="LeetCode224. 基本计算器"></a>LeetCode224. 基本计算器</h3><blockquote>
<p>实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格  。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p = self.infix_2_postfix(s)</span><br><span class="line">        <span class="keyword">return</span> self.evalRPN(p)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">infix_2_postfix</span><span class="params">(self,s)</span>:</span></span><br><span class="line">    <span class="comment"># 前缀表达式转后缀表达式</span></span><br><span class="line">        s = s+<span class="string">'#'</span></span><br><span class="line">        <span class="comment"># 定义运算符栈内和栈外的优先级</span></span><br><span class="line">        isp = &#123;<span class="string">'('</span>:<span class="number">1</span>,<span class="string">"*"</span>:<span class="number">5</span>,<span class="string">"/"</span>:<span class="number">5</span>,<span class="string">'%'</span>:<span class="number">5</span>,<span class="string">'+'</span>:<span class="number">3</span>,<span class="string">'-'</span>:<span class="number">3</span>,<span class="string">')'</span>:<span class="number">6</span>,<span class="string">'#'</span>:<span class="number">0</span>&#125;</span><br><span class="line">        icp = &#123;<span class="string">'('</span>:<span class="number">6</span>,<span class="string">"*"</span>:<span class="number">4</span>,<span class="string">"/"</span>:<span class="number">4</span>,<span class="string">'%'</span>:<span class="number">4</span>,<span class="string">'+'</span>:<span class="number">2</span>,<span class="string">'-'</span>:<span class="number">2</span>,<span class="string">')'</span>:<span class="number">1</span>,<span class="string">'#'</span>:<span class="number">0</span>&#125;</span><br><span class="line">        stack, res =  [<span class="string">'#'</span>],[]</span><br><span class="line">        i,num,is_num = <span class="number">0</span>,<span class="number">0</span>,<span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">                num = num*<span class="number">10</span> + int(s[i])</span><br><span class="line">                is_num = <span class="keyword">True</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> is_num:</span><br><span class="line">                    res.append(str(num))</span><br><span class="line">                    num = <span class="number">0</span></span><br><span class="line">                    is_num = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> icp[s[i]]&gt;isp[stack[<span class="number">-1</span>]]:</span><br><span class="line">                    stack.append(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> icp[s[i]]&lt;isp[stack[<span class="number">-1</span>]]:</span><br><span class="line">                    res.append(stack.pop())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack.pop() == <span class="string">'('</span>:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">    <span class="comment"># 后缀表达（逆波兰数）计算结果</span></span><br><span class="line">        stack = []</span><br><span class="line">        oper = [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>]</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> oper:</span><br><span class="line">                stack.append(token)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 = int(stack.pop())</span><br><span class="line">                p1 = int(stack.pop())</span><br><span class="line">                <span class="keyword">if</span> token == <span class="string">'+'</span>:</span><br><span class="line">                    res = p1+p2</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">'-'</span>:</span><br><span class="line">                    res = p1-p2</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">'*'</span>:</span><br><span class="line">                    res = p1*p2</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = int(p1/p2)</span><br><span class="line">                stack.append(str(res))</span><br><span class="line">        res = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode32-最长有效括号"><a href="#LeetCode32-最长有效括号" class="headerlink" title="LeetCode32 最长有效括号"></a>LeetCode32 最长有效括号</h3><blockquote>
<p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    res = max(res,i-start+<span class="number">1</span>) <span class="keyword">if</span> len(stack) == <span class="number">0</span> <span class="keyword">else</span> max(res,i - stack[<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="LeetCode11-盛最多水的容器"><a href="#LeetCode11-盛最多水的容器" class="headerlink" title="LeetCode11 盛最多水的容器"></a>LeetCode11 盛最多水的容器</h3><blockquote>
<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(height)<span class="number">-1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            area = min(height[l],height[r])*(r-l)</span><br><span class="line">            res = max(res,area)</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt; height[r]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode26-删除排序数组中的重复项"><a href="#LeetCode26-删除排序数组中的重复项" class="headerlink" title="LeetCode26. 删除排序数组中的重复项"></a>LeetCode26. 删除排序数组中的重复项</h3><blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[index] != nums[i]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode80-删除排序数组中的重复项-II"><a href="#LeetCode80-删除排序数组中的重复项-II" class="headerlink" title="LeetCode80. 删除排序数组中的重复项 II"></a>LeetCode80. 删除排序数组中的重复项 II</h3><blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现<strong>两次</strong>，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(nums)</span><br><span class="line">        <span class="keyword">if</span> m &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,m):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[index<span class="number">-1</span>]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode75-颜色分类"><a href="#LeetCode75-颜色分类" class="headerlink" title="LeetCode75. 颜色分类"></a>LeetCode75. 颜色分类</h3><blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(nums)</span><br><span class="line">        r,b = <span class="number">0</span>,m<span class="number">-1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;b+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i],nums[r] = nums[r],nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[i],nums[b] = nums[b],nums[i]</span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode713-乘积小于K的子数组"><a href="#LeetCode713-乘积小于K的子数组" class="headerlink" title="LeetCode713. 乘积小于K的子数组"></a>LeetCode713. 乘积小于K的子数组</h3><blockquote>
<p>给定一个正整数数组 nums。<br>找出该数组内乘积小于 k 的连续的子数组的个数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count,prod,left = <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            prod *= nums[i]</span><br><span class="line">            <span class="keyword">while</span> prod&gt;=k:</span><br><span class="line">                prod /= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            count += i-left+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="LeetCode91-解码方法"><a href="#LeetCode91-解码方法" class="headerlink" title="LeetCode91. 解码方法"></a>LeetCode91. 解码方法</h3><blockquote>
<p>一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(s)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre,cur = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'0'</span>:</span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">2</span> <span class="keyword">or</span> <span class="keyword">not</span>(s[i<span class="number">-2</span>] == <span class="string">'1'</span> <span class="keyword">or</span> (s[i<span class="number">-2</span>]==<span class="string">'2'</span> <span class="keyword">and</span> int(s[i<span class="number">-1</span>])&lt;=<span class="number">6</span>)):</span><br><span class="line">                pre = <span class="number">0</span></span><br><span class="line">            pre,cur = cur,pre+cur</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode152-乘积最大子序列"><a href="#LeetCode152-乘积最大子序列" class="headerlink" title="LeetCode152 乘积最大子序列"></a>LeetCode152 乘积最大子序列</h3><blockquote>
<p>给定一个整数数组 nums， 找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res =nums[<span class="number">0</span>]</span><br><span class="line">        max_res,min_res = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                max_res = max(max_res*nums[i],nums[i])</span><br><span class="line">                min_res = min(min_res*nums[i],nums[i])</span><br><span class="line">            <span class="keyword">elif</span> nums[i]&lt;<span class="number">0</span>:</span><br><span class="line">                max_res,min_res = max(min_res*nums[i],nums[i]),min(max_res*nums[i],nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_res,min_res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            res = max(max_res,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode121-买卖股票的最佳时机"><a href="#LeetCode121-买卖股票的最佳时机" class="headerlink" title="LeetCode121. 买卖股票的最佳时机"></a>LeetCode121. 买卖股票的最佳时机</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你<strong>最多只允许完成一笔交易</strong>（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n== <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        min_p= prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = max(res,prices[i]-min_p)</span><br><span class="line">            <span class="keyword">if</span> min_p&gt;prices[i]:</span><br><span class="line">                min_p = prices[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode122-买卖股票的最佳时机-II"><a href="#LeetCode122-买卖股票的最佳时机-II" class="headerlink" title="LeetCode122. 买卖股票的最佳时机 II"></a>LeetCode122. 买卖股票的最佳时机 II</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以<strong>尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            diff = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                res += diff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode123-买卖股票的最佳时机-III"><a href="#LeetCode123-买卖股票的最佳时机-III" class="headerlink" title="LeetCode123. 买卖股票的最佳时机 III"></a>LeetCode123. 买卖股票的最佳时机 III</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你<strong>最多可以完成两笔交易</strong>。</p>
</blockquote>
<hr>
<p>f[i]表示[0:i]天交易的最大利润<br>g[i]表示[i:n-1]天交易的最大利润</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        f,g = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        valley = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            valley = min(valley,prices[i])</span><br><span class="line">            f[i] = max(f[i<span class="number">-1</span>],prices[i]-valley)</span><br><span class="line">        peak = prices[n<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            peak = max(peak,prices[i])</span><br><span class="line">            g[i] = max(g[i+<span class="number">1</span>],peak-prices[i])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = max(res,f[i]+g[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode714-买卖股票的最佳时机含手续费"><a href="#LeetCode714-买卖股票的最佳时机含手续费" class="headerlink" title="LeetCode714. 买卖股票的最佳时机含手续费"></a>LeetCode714. 买卖股票的最佳时机含手续费</h3><blockquote>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。</p>
</blockquote>
<hr>
<p>sold[i]:表示第i天卖出股票所能获得的最大利润，那么，它的值应该等于前一天手里有股票时所拥有的最大利润加上今天卖出时获得的利润，和前一天手里没有保留股票，而是卖出股票时有的最大利润的较大者<br>hold[i]:表示第i天保留股票时所能获得的最大利润，它的值为前一天卖出了股票所拥有的最大利润减去今天买进股票的价格，和前一天保留了股票的较大者。</p>
<p>sold[i] = max(sold[i-1],hold[i-1]+prices[i]-fee)<br>hold[i] = max(sold[i-1]-prices[i],hold[i-1])</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices, fee)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        sold,hold = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        hold[<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            sold[i] = max(hold[i<span class="number">-1</span>]+prices[i]-fee,sold[i<span class="number">-1</span>])</span><br><span class="line">            hold[i] = max(sold[i<span class="number">-1</span>]-prices[i],hold[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> sold[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode132-分割回文串-II"><a href="#LeetCode132-分割回文串-II" class="headerlink" title="LeetCode132. 分割回文串 II"></a>LeetCode132. 分割回文串 II</h3><blockquote>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回符合要求的最少分割次数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lass Solution(object):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [n-i<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        p = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># p[n-1][n]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span>(j-i&lt;=<span class="number">1</span> <span class="keyword">or</span> p[i+<span class="number">1</span>][j<span class="number">-1</span>] ==<span class="number">1</span>):</span><br><span class="line">                    p[i][j] = <span class="number">1</span></span><br><span class="line">                    f[i] = min(f[i],<span class="number">1</span>+f[j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode139-单词拆分"><a href="#LeetCode139-单词拆分" class="headerlink" title="LeetCode139. 单词拆分"></a>LeetCode139. 单词拆分</h3><blockquote>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [<span class="keyword">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                f[i] = f[i] <span class="keyword">or</span> (f[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict)</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br><span class="line">```            </span><br><span class="line"><span class="comment">### LeetCode338. 比特位计数</span></span><br><span class="line">&gt;给定一个非负整数 num。对于 <span class="number">0</span> ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 <span class="number">1</span> 的数目并将它们作为数组返回。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">dp[i] = dp[i-cycle]+<span class="number">1</span>,其中cycle=<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16.</span>..，</span><br><span class="line">比如，<span class="number">3</span>的二进制：<span class="number">11</span>，此时cycle为<span class="number">2</span>，dp[<span class="number">3</span>] = dp[<span class="number">3</span><span class="number">-2</span>]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(num+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> num==<span class="number">0</span>:<span class="keyword">return</span> dp</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,num+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span>**dp[i<span class="number">-1</span>]:</span><br><span class="line">                cycle = i</span><br><span class="line">            dp[i] = dp[i-cycle]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure>
<p>###LeetCode368. 最大整除子集</p>
<blockquote>
<p>给出一个由无重复的正整数组成的集合, 找出其中最大的整除子集, 子集中任意一对 (Si, Sj) 都要满足: Si % Sj = 0 或 Sj % Si = 0。<br>如果有多个目标子集，返回其中任何一个均可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        parent = [<span class="number">0</span>]*n</span><br><span class="line">        mx,mx_idx = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">                <span class="keyword">if</span> nums[j]%nums[i]==<span class="number">0</span> <span class="keyword">and</span> dp[i]&lt;dp[j]+<span class="number">1</span>:</span><br><span class="line">                    dp[i] = dp[j]+<span class="number">1</span></span><br><span class="line">                    parent[i] = j</span><br><span class="line">                    <span class="keyword">if</span> mx&lt;dp[i]:</span><br><span class="line">                        mx = dp[i]</span><br><span class="line">                        mx_idx = i</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mx):</span><br><span class="line">            res.append(nums[mx_idx])</span><br><span class="line">            mx_idx = parent[mx_idx]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode72-编辑距离"><a href="#LeetCode72-编辑距离" class="headerlink" title="LeetCode72. 编辑距离"></a>LeetCode72. 编辑距离</h3><blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(word1),len(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode97-交错字符串"><a href="#LeetCode97-交错字符串" class="headerlink" title="LeetCode97. 交错字符串"></a>LeetCode97. 交错字符串</h3><blockquote>
<p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :type s3: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(s1),len(s2)</span><br><span class="line">        <span class="keyword">if</span> m+n != len(s3): <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        l = [[<span class="keyword">False</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        l[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> s1[i]==s3[i] <span class="keyword">and</span> l[i][<span class="number">0</span>]:</span><br><span class="line">                l[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> s2[i]==s3[i] <span class="keyword">and</span> l[<span class="number">0</span>][i]:</span><br><span class="line">                l[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                l[i+<span class="number">1</span>][j+<span class="number">1</span>] = (s1[i]==s3[i+j+<span class="number">1</span>] <span class="keyword">and</span> l[i][j+<span class="number">1</span>]) <span class="keyword">or</span> (s2[j] == s3[i+j+<span class="number">1</span>] <span class="keyword">and</span> l[i+<span class="number">1</span>][j])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> l[m][n]</span><br></pre></td></tr></table></figure>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="LeetCode55-跳跃游戏"><a href="#LeetCode55-跳跃游戏" class="headerlink" title="LeetCode55. 跳跃游戏"></a>LeetCode55. 跳跃游戏</h3><blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">0</span>]*len(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> dp[i<span class="number">-1</span>]&gt;=i:</span><br><span class="line">                dp[i] = max(dp[i<span class="number">-1</span>],nums[i]+i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(nums)<span class="number">-1</span>] &gt;= len(nums)<span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode-45-跳跃游戏-II"><a href="#LeetCode-45-跳跃游戏-II" class="headerlink" title="LeetCode 45. 跳跃游戏 II"></a>LeetCode 45. 跳跃游戏 II</h3><blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        last,cur = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            cur = max(cur,i+nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == last:</span><br><span class="line">                last = cur</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur &gt; n<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode134-加油站"><a href="#LeetCode134-加油站" class="headerlink" title="LeetCode134. 加油站"></a>LeetCode134. 加油站</h3><blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<br><strong>说明:</strong> </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sum_,total = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            total += gas[i] - cost[i]</span><br><span class="line">            sum_ += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> sum_&lt;<span class="number">0</span>:</span><br><span class="line">                start = i+<span class="number">1</span></span><br><span class="line">                sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> total&lt;<span class="number">0</span> <span class="keyword">else</span> start</span><br></pre></td></tr></table></figure>
<h2 id="奇技淫巧题"><a href="#奇技淫巧题" class="headerlink" title="奇技淫巧题"></a>奇技淫巧题</h2><h3 id="LeetCode42-接雨水"><a href="#LeetCode42-接雨水" class="headerlink" title="LeetCode42 接雨水"></a>LeetCode42 接雨水</h3><blockquote>
<p><strong>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</strong><br>对于每个柱子，找到它左右两边最高的柱子，它所能容纳的雨水为min(max_left, max_- right) - height,时间空间复杂度都为O(n),</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(height)</span><br><span class="line">        max_left,max_right = [<span class="number">0</span>]*m,[<span class="number">0</span>]*m</span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> l&lt;height[i]:</span><br><span class="line">                l = height[i]</span><br><span class="line">            max_left[i] = l</span><br><span class="line">            <span class="keyword">if</span> r&lt;height[m<span class="number">-1</span>-i]:</span><br><span class="line">                r = height[m<span class="number">-1</span>-i]</span><br><span class="line">            max_right[m<span class="number">-1</span>-i] = r</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            res += min(max_left[i],max_right[i])-height[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode41-缺失的第一个正数"><a href="#LeetCode41-缺失的第一个正数" class="headerlink" title="LeetCode41 缺失的第一个正数"></a>LeetCode41 缺失的第一个正数</h3><blockquote>
<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>思路</strong><br>举个例子:最小的正数有可能是1,2,3,…..,最大是n+1,遍历数组，假设1出现了，就将1放到nums[0],2出现就放在nums[1]，依次类推，等遍历完这次数组，“正确的数字都放到了正确的位置”，所以，再次遍历数组，找出第一个数字与位置不对应的”位置”。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i]&lt;=<span class="number">0</span> <span class="keyword">or</span> nums[i]&gt;len(nums) <span class="keyword">or</span> nums[i] == nums[nums[i]<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j = nums[i]</span><br><span class="line">                nums[i],nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>],nums[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode442-数组中重复的数据"><a href="#LeetCode442-数组中重复的数据" class="headerlink" title="LeetCode442. 数组中重复的数据"></a>LeetCode442. 数组中重复的数据</h3><blockquote>
<p>给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。找到所有出现两次的元素。<br>你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</p>
</blockquote>
<hr>
<p>把“正确”的数放到“正确”的位置，有重复的数字将在“错误的位置”，最后找到这样“错误的”数。</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            idx = nums[i]<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[idx] != nums[i]:</span><br><span class="line">                nums[idx],nums[i] = nums[i],nums[idx]</span><br><span class="line">            <span class="keyword">else</span>: i += <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode448-找到所有数组中消失的数字"><a href="#LeetCode448-找到所有数组中消失的数字" class="headerlink" title="LeetCode448. 找到所有数组中消失的数字"></a>LeetCode448. 找到所有数组中消失的数字</h3><blockquote>
<p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。<br>找到所有在 [1, n] 范围之间没有出现在数组中的数字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i,res = <span class="number">0</span>,[]</span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            idx = nums[i]<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]!=nums[idx]:</span><br><span class="line">                nums[i],nums[idx] = nums[idx],nums[i]</span><br><span class="line">            <span class="keyword">else</span>: i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                res.append(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="TOPK-问题"><a href="#TOPK-问题" class="headerlink" title="TOPK 问题"></a>TOPK 问题</h2><h3 id="Leetcode4-两个排序数组的中位数"><a href="#Leetcode4-两个排序数组的中位数" class="headerlink" title="Leetcode4 两个排序数组的中位数"></a>Leetcode4 两个排序数组的中位数</h3><blockquote>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。 请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。<br><code>二分搜索</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(nums1),len(nums2)</span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.find_kth(nums1,<span class="number">0</span>,m<span class="number">-1</span>,nums2,<span class="number">0</span>,n<span class="number">-1</span>,(m+n)&gt;&gt;<span class="number">1</span>) + self.find_kth(nums1,<span class="number">0</span>,m<span class="number">-1</span>,nums2,<span class="number">0</span>,n<span class="number">-1</span>,((m+n)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>))/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth(nums1,<span class="number">0</span>,m<span class="number">-1</span>,nums2,<span class="number">0</span>,n<span class="number">-1</span>,((m+n)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_kth</span><span class="params">(self,nums1,b1,e1,nums2,b2,e2,k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        nums1,nums2:两个数组</span></span><br><span class="line"><span class="string">        b1,e1,b2,e2:数组1、2开始和结束的位置</span></span><br><span class="line"><span class="string">        k:第k大</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = e1-b1+<span class="number">1</span>, e2-b2+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> m&gt;n:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth(nums2,b2,e2,nums1,b1,e1,k)</span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums2[b2+k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[b1],nums2[b2])</span><br><span class="line">        ia = min(k&gt;&gt;<span class="number">1</span>,m)</span><br><span class="line">        ib = k - ia</span><br><span class="line">        <span class="keyword">if</span> nums1[b1+ia<span class="number">-1</span>] &lt; nums2[b2+ib<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth(nums1,b1+ia,e1,nums2,b2,e2,k-ia)</span><br><span class="line">        <span class="keyword">elif</span> nums1[b1+ia<span class="number">-1</span>]&gt;nums2[b2+ib<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth(nums1,b1,e1,nums2,b2+ib,e2,k-ib)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[b1+ia<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Leetcode378-在行和列都是单调递增的数组中找出第k小的元素。"><a href="#Leetcode378-在行和列都是单调递增的数组中找出第k小的元素。" class="headerlink" title="Leetcode378 在行和列都是单调递增的数组中找出第k小的元素。"></a>Leetcode378 在行和列都是单调递增的数组中找出第k小的元素。</h3><p><code>二分搜索</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        left,right = matrix[<span class="number">0</span>][<span class="number">0</span>],matrix[n<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            counts = self.search_less_count(matrix,mid)</span><br><span class="line">            <span class="keyword">if</span> counts &lt;k:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_less_count</span><span class="params">(self,matrix,target)</span>:</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        i,j = n<span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">        counts = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j]&lt;=target:</span><br><span class="line">                counts += i+<span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure></p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="LeetCode22-括号生成"><a href="#LeetCode22-括号生成" class="headerlink" title="LeetCode22. 括号生成"></a>LeetCode22. 括号生成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = <span class="string">""</span></span><br><span class="line">        self.dfs(res,cur,n,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,res,cur,n,l,r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l==n:</span><br><span class="line">            res.append(cur+<span class="string">')'</span>*(n-r))</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.dfs(res,cur+<span class="string">'('</span>,n,l+<span class="number">1</span>,r)</span><br><span class="line">        <span class="keyword">if</span> r&lt;l:</span><br><span class="line">            self.dfs(res,cur+<span class="string">')'</span>,n,l,r+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode37-解数独"><a href="#LeetCode37-解数独" class="headerlink" title="LeetCode37 解数独"></a>LeetCode37 解数独</h3><blockquote>
<p>编写一个程序，通过已填充的空格来解决数独问题。<br>一个数独的解法需遵循如下规则：</p>
<ol>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>Note:</li>
</ol>
<ul>
<li>给定的数独序列只包含数字 1-9 和字符 ‘.’ 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 9x9 形式的。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.sudoku_core(board)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sudoku_core</span><span class="params">(self,board)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                        <span class="keyword">if</span> self.is_value_sudoku(board,i,j,k):</span><br><span class="line">                            board[i][j] = str(k)</span><br><span class="line">                            <span class="keyword">if</span> self.sudoku_core(board):</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                            board[i][j] = <span class="string">'.'</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_value_sudoku</span><span class="params">(self,board,i,j,k)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> board[i]:</span><br><span class="line">            <span class="keyword">if</span> l == str(k):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[l][j] == str(k):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(int(i/<span class="number">3</span>)*<span class="number">3</span>,int(i/<span class="number">3</span>)*<span class="number">3</span>+<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(int(j/<span class="number">3</span>)*<span class="number">3</span>,int(j/<span class="number">3</span>)*<span class="number">3</span>+<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> board[m][n] == str(k):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode51-N皇后"><a href="#LeetCode51-N皇后" class="headerlink" title="LeetCode51. N皇后"></a>LeetCode51. N皇后</h3><blockquote>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pos = [<span class="number">-1</span>]*n</span><br><span class="line">        res = []</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        self.n_queens_core(res,pos,row,n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n_queens_core</span><span class="params">(self,res,pos,row,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            st = [[<span class="string">'.'</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                st[i][pos[i]] = <span class="string">'Q'</span></span><br><span class="line">            st = [<span class="string">''</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> st]</span><br><span class="line">            res.append(st)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> self.is_value(pos,row,col):</span><br><span class="line">                    pos[row] = col</span><br><span class="line">                    self.n_queens_core(res,pos,row+<span class="number">1</span>,n)</span><br><span class="line">                    pos[row] = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_value</span><span class="params">(self,pos,row,col)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">if</span> col==pos[i] <span class="keyword">or</span> abs(row-i) == abs(pos[i]-col):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode51-N皇后2"><a href="#LeetCode51-N皇后2" class="headerlink" title="LeetCode51. N皇后2"></a>LeetCode51. N皇后2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pos = [<span class="number">-1</span>]*n</span><br><span class="line">        res,row = [<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">        self.n_queens_core(res,pos,row,n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n_queens_core</span><span class="params">(self,res,pos,row,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row==n:</span><br><span class="line">            res[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> self.is_value(pos,row,col):</span><br><span class="line">                    pos[row] = col</span><br><span class="line">                    self.n_queens_core(res,pos,row+<span class="number">1</span>,n)</span><br><span class="line">                    pos[row] = <span class="number">-1</span></span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_value</span><span class="params">(self,pos,row,col)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">if</span> col == pos[i] <span class="keyword">or</span> abs(i-row) == abs(col-pos[i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode79-单词搜索"><a href="#LeetCode79-单词搜索" class="headerlink" title="LeetCode79. 单词搜索"></a>LeetCode79. 单词搜索</h3><blockquote>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(board)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> word:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        has_visit = [[<span class="keyword">False</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> self.search(board,word,i,j,has_visit,<span class="number">0</span>,m,n):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,board,word,i,j,has_visit,k,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        is_word = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> <span class="keyword">not</span> has_visit[i][j] <span class="keyword">and</span> board[i][j] == word[k]:</span><br><span class="line">            has_visit[i][j] = <span class="keyword">True</span></span><br><span class="line">            is_word = self.search(board,word,i+<span class="number">1</span>,j,has_visit,k+<span class="number">1</span>,m,n) <span class="keyword">or</span> self.search(board,word,i<span class="number">-1</span>,j,has_visit,k+<span class="number">1</span>,m,n) \</span><br><span class="line">            <span class="keyword">or</span> self.search(board,word,i,j+<span class="number">1</span>,has_visit,k+<span class="number">1</span>,m,n) <span class="keyword">or</span> self.search(board,word,i,j<span class="number">-1</span>,has_visit,k+<span class="number">1</span>,m,n)</span><br><span class="line">            has_visit[i][j] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> is_word</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode131-分割回文串"><a href="#LeetCode131-分割回文串" class="headerlink" title="LeetCode131. 分割回文串"></a>LeetCode131. 分割回文串</h3><blockquote>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(s,[],<span class="number">0</span>,res,n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(self,s,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            <span class="keyword">if</span> s[start] != s[end]: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            start +=<span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,s,cur,start,res,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == n:</span><br><span class="line">            res.append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n):</span><br><span class="line">            <span class="keyword">if</span> self.is_palindrome(s,start,i):</span><br><span class="line">                self.dfs(s,cur+[s[start:i+<span class="number">1</span>]],i+<span class="number">1</span>,res,n)</span><br></pre></td></tr></table></figure>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="LeetCode130-被围绕的区域"><a href="#LeetCode130-被围绕的区域" class="headerlink" title="LeetCode130. 被围绕的区域"></a>LeetCode130. 被围绕的区域</h3><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。<br>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。<br><strong>解释:</strong><br>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br><strong>示例:</strong><br>X X X X<br>X O O X<br>X X O X<br>X O X X<br>运行你的函数后，矩阵变为：<br>X X X X<br>X X X X<br>X X X X<br>X O X X</p>
<hr>
<p>只需找到边沿的O以及与它相邻的那些O，并标记好，其它的最终都填充为X</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(board)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        mat = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>,n<span class="number">-1</span>]:</span><br><span class="line">                self.bfs(board,mat,i,j,m,n)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,m<span class="number">-1</span>]:</span><br><span class="line">                self.bfs(board,mat,i,j,m,n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> mat[i][j]==<span class="number">0</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self,board,mat,i,j,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> board[i][j] == <span class="string">'O'</span> <span class="keyword">and</span> mat[i][j]==<span class="number">0</span>:</span><br><span class="line">            queue = []</span><br><span class="line">            queue.append((i,j))</span><br><span class="line">            mat[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                u,v = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=u&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=v+<span class="number">1</span>&lt;n <span class="keyword">and</span> board[u][v+<span class="number">1</span>] == <span class="string">'O'</span> <span class="keyword">and</span> mat[u][v+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                    queue.append((u,v+<span class="number">1</span>))</span><br><span class="line">                    mat[u][v+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=u&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=v<span class="number">-1</span>&lt;n <span class="keyword">and</span> board[u][v<span class="number">-1</span>] == <span class="string">'O'</span> <span class="keyword">and</span> mat[u][v<span class="number">-1</span>]==<span class="number">0</span>:</span><br><span class="line">                    queue.append((u,v<span class="number">-1</span>))</span><br><span class="line">                    mat[u][v<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=u+<span class="number">1</span>&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=v&lt;n <span class="keyword">and</span> board[u+<span class="number">1</span>][v] == <span class="string">'O'</span> <span class="keyword">and</span> mat[u+<span class="number">1</span>][v]==<span class="number">0</span>:</span><br><span class="line">                    queue.append((u+<span class="number">1</span>,v))</span><br><span class="line">                    mat[u+<span class="number">1</span>][v] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=u<span class="number">-1</span>&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=v&lt;n <span class="keyword">and</span> board[u<span class="number">-1</span>][v] == <span class="string">'O'</span> <span class="keyword">and</span> mat[u<span class="number">-1</span>][v]==<span class="number">0</span>:</span><br><span class="line">                    queue.append((u<span class="number">-1</span>,v))</span><br><span class="line">                    mat[u<span class="number">-1</span>][v] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><h3 id="LeetCode31-下一个排列"><a href="#LeetCode31-下一个排列" class="headerlink" title="LeetCode31 下一个排列"></a>LeetCode31 下一个排列</h3><blockquote>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>必须原地修改，只允许使用额外常数空间。</p>
</blockquote>
<hr>
<p><strong>思路：</strong></p>
<ol>
<li>从右向左找到第一个开始降序的数字a</li>
<li>从右向左找到第一个比a大的数字b</li>
<li>交换a和b</li>
<li>反转a后面的数组</li>
</ol>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pivot = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j]&lt;nums[j+<span class="number">1</span>]:</span><br><span class="line">                pivot = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> pivot != <span class="number">-1</span>:</span><br><span class="line">            j = n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;pivot:</span><br><span class="line">                <span class="keyword">if</span> nums[j]&gt;nums[pivot]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[pivot],nums[j] = nums[j],nums[pivot]</span><br><span class="line">        </span><br><span class="line">        r = n<span class="number">-1</span></span><br><span class="line">        j = pivot+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r&gt;j:</span><br><span class="line">            nums[r],nums[j] = nums[j],nums[r]</span><br><span class="line">            r -=<span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="LeetCode39-组合总和"><a href="#LeetCode39-组合总和" class="headerlink" title="LeetCode39. 组合总和"></a>LeetCode39. 组合总和</h3><blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        self.dfs(candidates,<span class="number">0</span>,res,[],target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,candidates,start,res,cur,target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target&lt;<span class="number">0</span>:<span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="number">0</span>==target:</span><br><span class="line">            res.append(cur)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                self.dfs(candidates,i,res,cur+[candidates[i]],target-candidates[i])</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode40-组合总和-II-不能重复使用同一个数"><a href="#LeetCode40-组合总和-II-不能重复使用同一个数" class="headerlink" title="LeetCode40. 组合总和 II(不能重复使用同一个数)"></a>LeetCode40. 组合总和 II(不能重复使用同一个数)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        self.dfs(candidates,<span class="number">-1</span>,res,[],target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,candidates,start,res,cur,target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target&lt;<span class="number">0</span>:<span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> target==<span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start+<span class="number">1</span>,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;start+<span class="number">1</span> <span class="keyword">and</span> candidates[i]==candidates[i<span class="number">-1</span>]:<span class="keyword">continue</span></span><br><span class="line">                self.dfs(candidates,i,res,cur+[candidates[i]],target-candidates[i])</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode46-全排列"><a href="#LeetCode46-全排列" class="headerlink" title="LeetCode46. 全排列"></a>LeetCode46. 全排列</h3><blockquote>
<p>给定一个<strong>没有重复数字</strong>的序列，返回其所有可能的全排列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        self.dfs(nums,res,cur,n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,nums,res,cur,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">        <span class="keyword">elif</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                self.dfs(nums[:i]+nums[i+<span class="number">1</span>:],res,cur+[nums[i]],n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode47-全排列-II-有重复数字"><a href="#LeetCode47-全排列-II-有重复数字" class="headerlink" title="LeetCode47. 全排列 II(有重复数字)"></a>LeetCode47. 全排列 II(有重复数字)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        self.dfs(nums,res,cur,n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,nums,res,cur,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">        <span class="keyword">elif</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&lt;len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[i]==nums[i+<span class="number">1</span>]:<span class="keyword">continue</span></span><br><span class="line">                self.dfs(nums[:i]+nums[i+<span class="number">1</span>:],res,cur+[nums[i]],n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode77-组合"><a href="#LeetCode77-组合" class="headerlink" title="LeetCode77. 组合"></a>LeetCode77. 组合</h3><blockquote>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        self.dfs(n,k,cur,<span class="number">0</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,n,k,cur,start,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start+<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                self.dfs(n,k<span class="number">-1</span>,cur+[i],i,res)</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode78-子集"><a href="#LeetCode78-子集" class="headerlink" title="LeetCode78. 子集"></a>LeetCode78. 子集</h3><blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        self.dfs(nums,cur,<span class="number">0</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,nums,cur,start,res)</span>:</span></span><br><span class="line">        res.append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(nums)):</span><br><span class="line">            self.dfs(nums,cur+[nums[i]],i+<span class="number">1</span>,res)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="LeetCode90-子集-II"><a href="#LeetCode90-子集-II" class="headerlink" title="LeetCode90. 子集 II"></a>LeetCode90. 子集 II</h3><blockquote>
<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur = [],[]</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        self.dfs(nums,res,cur)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,nums,res,cur)</span>:</span></span><br><span class="line">        res.append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(nums[i+<span class="number">1</span>:],res,cur+[nums[i]])</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    phi
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://TFeiMa.github.io/2018/06/20/算法刷题总结/" title="算法刷题总结（Python实现）">http://TFeiMa.github.io/2018/06/20/算法刷题总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/leetcode-算法/" rel="tag"><i class="fa fa-tag"></i> leetcode 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/14/支持向量机/" rel="next" title="支持向量机">
                <i class="fa fa-chevron-left"></i> 支持向量机
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/26/ldrq/" rel="prev" title="分式二次规划问题的线性时间算法">
                分式二次规划问题的线性时间算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/me.jpg" alt="phi">
            
              <p class="site-author-name" itemprop="name">phi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#算法刷题总结"><span class="nav-number">1.</span> <span class="nav-text">算法刷题总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">1.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#链表排序"><span class="nav-number">1.1.1.</span> <span class="nav-text">链表排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冒泡排序"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode23-合并K个有序链表"><span class="nav-number">1.1.2.</span> <span class="nav-text">LeetCode23 合并K个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode82-删除排序链表中的重复元素"><span class="nav-number">1.1.3.</span> <span class="nav-text">LeetCode82 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode83-删除排序链表中的重复元素II"><span class="nav-number">1.1.4.</span> <span class="nav-text">LeetCode83 删除排序链表中的重复元素II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode138-复制带随机指针的链表"><span class="nav-number">1.1.5.</span> <span class="nav-text">LeetCode138. 复制带随机指针的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode141-环形链表"><span class="nav-number">1.1.6.</span> <span class="nav-text">LeetCode141. 环形链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode142-环形链表-II"><span class="nav-number">1.1.7.</span> <span class="nav-text">LeetCode142. 环形链表 II</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树"><span class="nav-number">1.2.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode109-有序链表转换二叉搜索树"><span class="nav-number">1.2.1.</span> <span class="nav-text">LeetCode109. 有序链表转换二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode114-二叉树展开为链表"><span class="nav-number">1.2.2.</span> <span class="nav-text">LeetCode114. 二叉树展开为链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode116-填充同一层的兄弟节点"><span class="nav-number">1.2.3.</span> <span class="nav-text">LeetCode116. 填充同一层的兄弟节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode124-二叉树中的最大路径和"><span class="nav-number">1.2.4.</span> <span class="nav-text">LeetCode124. 二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode236-二叉树的最近公共祖先"><span class="nav-number">1.2.5.</span> <span class="nav-text">LeetCode236. 二叉树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分搜索"><span class="nav-number">1.3.</span> <span class="nav-text">二分搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode33-搜索旋转排序数组-无重复数字"><span class="nav-number">1.3.1.</span> <span class="nav-text">LeetCode33 搜索旋转排序数组(无重复数字)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode81-搜索旋转排序数组-II（有重复数字）"><span class="nav-number">1.3.2.</span> <span class="nav-text">LeetCode81. 搜索旋转排序数组 II（有重复数字）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode162-寻找峰值"><span class="nav-number">1.3.3.</span> <span class="nav-text">LeetCode162. 寻找峰值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode852-山脉数组的峰顶索引"><span class="nav-number">1.3.4.</span> <span class="nav-text">LeetCode852. 山脉数组的峰顶索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">1.4.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode56-合并区间"><span class="nav-number">1.4.1.</span> <span class="nav-text">LeetCode56. 合并区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode57-插入区间"><span class="nav-number">1.4.2.</span> <span class="nav-text">LeetCode57. 插入区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode-128-最长连续序列"><span class="nav-number">1.4.3.</span> <span class="nav-text">LeetCode 128 最长连续序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode560-和为K的子数组"><span class="nav-number">1.4.4.</span> <span class="nav-text">LeetCode560. 和为K的子数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">1.5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode5-最长回文字符串"><span class="nav-number">1.5.1.</span> <span class="nav-text">LeetCode5 最长回文字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode10-正则表达式匹配"><span class="nav-number">1.5.2.</span> <span class="nav-text">LeetCode10. 正则表达式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode43-字符串相乘"><span class="nav-number">1.5.3.</span> <span class="nav-text">LeetCode43. 字符串相乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode44-通配符匹配"><span class="nav-number">1.5.4.</span> <span class="nav-text">LeetCode44 通配符匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode93-复原IP地址"><span class="nav-number">1.5.5.</span> <span class="nav-text">LeetCode93. 复原IP地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈和队列"><span class="nav-number">1.6.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode84-柱状图中最大的矩形"><span class="nav-number">1.6.1.</span> <span class="nav-text">LeetCode84. 柱状图中最大的矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode85-最大矩形"><span class="nav-number">1.6.2.</span> <span class="nav-text">LeetCode85. 最大矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode150-逆波兰数"><span class="nav-number">1.6.3.</span> <span class="nav-text">leetcode150 逆波兰数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode224-基本计算器"><span class="nav-number">1.6.4.</span> <span class="nav-text">LeetCode224. 基本计算器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode32-最长有效括号"><span class="nav-number">1.6.5.</span> <span class="nav-text">LeetCode32 最长有效括号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双指针"><span class="nav-number">1.7.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode11-盛最多水的容器"><span class="nav-number">1.7.1.</span> <span class="nav-text">LeetCode11 盛最多水的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode26-删除排序数组中的重复项"><span class="nav-number">1.7.2.</span> <span class="nav-text">LeetCode26. 删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode80-删除排序数组中的重复项-II"><span class="nav-number">1.7.3.</span> <span class="nav-text">LeetCode80. 删除排序数组中的重复项 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode75-颜色分类"><span class="nav-number">1.7.4.</span> <span class="nav-text">LeetCode75. 颜色分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode713-乘积小于K的子数组"><span class="nav-number">1.7.5.</span> <span class="nav-text">LeetCode713. 乘积小于K的子数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">1.8.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode91-解码方法"><span class="nav-number">1.8.1.</span> <span class="nav-text">LeetCode91. 解码方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode152-乘积最大子序列"><span class="nav-number">1.8.2.</span> <span class="nav-text">LeetCode152 乘积最大子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode121-买卖股票的最佳时机"><span class="nav-number">1.8.3.</span> <span class="nav-text">LeetCode121. 买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode122-买卖股票的最佳时机-II"><span class="nav-number">1.8.4.</span> <span class="nav-text">LeetCode122. 买卖股票的最佳时机 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode123-买卖股票的最佳时机-III"><span class="nav-number">1.8.5.</span> <span class="nav-text">LeetCode123. 买卖股票的最佳时机 III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode714-买卖股票的最佳时机含手续费"><span class="nav-number">1.8.6.</span> <span class="nav-text">LeetCode714. 买卖股票的最佳时机含手续费</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode132-分割回文串-II"><span class="nav-number">1.8.7.</span> <span class="nav-text">LeetCode132. 分割回文串 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode139-单词拆分"><span class="nav-number">1.8.8.</span> <span class="nav-text">LeetCode139. 单词拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode72-编辑距离"><span class="nav-number">1.8.9.</span> <span class="nav-text">LeetCode72. 编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode97-交错字符串"><span class="nav-number">1.8.10.</span> <span class="nav-text">LeetCode97. 交错字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪心算法"><span class="nav-number">1.9.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode55-跳跃游戏"><span class="nav-number">1.9.1.</span> <span class="nav-text">LeetCode55. 跳跃游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode-45-跳跃游戏-II"><span class="nav-number">1.9.2.</span> <span class="nav-text">LeetCode 45. 跳跃游戏 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode134-加油站"><span class="nav-number">1.9.3.</span> <span class="nav-text">LeetCode134. 加油站</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#奇技淫巧题"><span class="nav-number">1.10.</span> <span class="nav-text">奇技淫巧题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode42-接雨水"><span class="nav-number">1.10.1.</span> <span class="nav-text">LeetCode42 接雨水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode41-缺失的第一个正数"><span class="nav-number">1.10.2.</span> <span class="nav-text">LeetCode41 缺失的第一个正数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode442-数组中重复的数据"><span class="nav-number">1.10.3.</span> <span class="nav-text">LeetCode442. 数组中重复的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode448-找到所有数组中消失的数字"><span class="nav-number">1.10.4.</span> <span class="nav-text">LeetCode448. 找到所有数组中消失的数字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TOPK-问题"><span class="nav-number">1.11.</span> <span class="nav-text">TOPK 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode4-两个排序数组的中位数"><span class="nav-number">1.11.1.</span> <span class="nav-text">Leetcode4 两个排序数组的中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode378-在行和列都是单调递增的数组中找出第k小的元素。"><span class="nav-number">1.11.2.</span> <span class="nav-text">Leetcode378 在行和列都是单调递增的数组中找出第k小的元素。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-number">1.12.</span> <span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode22-括号生成"><span class="nav-number">1.12.1.</span> <span class="nav-text">LeetCode22. 括号生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode37-解数独"><span class="nav-number">1.12.2.</span> <span class="nav-text">LeetCode37 解数独</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode51-N皇后"><span class="nav-number">1.12.3.</span> <span class="nav-text">LeetCode51. N皇后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode51-N皇后2"><span class="nav-number">1.12.4.</span> <span class="nav-text">LeetCode51. N皇后2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode79-单词搜索"><span class="nav-number">1.12.5.</span> <span class="nav-text">LeetCode79. 单词搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode131-分割回文串"><span class="nav-number">1.12.6.</span> <span class="nav-text">LeetCode131. 分割回文串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-number">1.13.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode130-被围绕的区域"><span class="nav-number">1.13.1.</span> <span class="nav-text">LeetCode130. 被围绕的区域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排列组合"><span class="nav-number">1.14.</span> <span class="nav-text">排列组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode31-下一个排列"><span class="nav-number">1.14.1.</span> <span class="nav-text">LeetCode31 下一个排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode39-组合总和"><span class="nav-number">1.14.2.</span> <span class="nav-text">LeetCode39. 组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode40-组合总和-II-不能重复使用同一个数"><span class="nav-number">1.14.3.</span> <span class="nav-text">LeetCode40. 组合总和 II(不能重复使用同一个数)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode46-全排列"><span class="nav-number">1.14.4.</span> <span class="nav-text">LeetCode46. 全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode47-全排列-II-有重复数字"><span class="nav-number">1.14.5.</span> <span class="nav-text">LeetCode47. 全排列 II(有重复数字)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode77-组合"><span class="nav-number">1.14.6.</span> <span class="nav-text">LeetCode77. 组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode78-子集"><span class="nav-number">1.14.7.</span> <span class="nav-text">LeetCode78. 子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode90-子集-II"><span class="nav-number">1.14.8.</span> <span class="nav-text">LeetCode90. 子集 II</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">phi</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">47.4k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
